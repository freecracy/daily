# 2021年03月29日 code
<a href="https://toutiao.io/k/47wemjf">超实用的 IDEA 插件推荐！百万级下载量</a><br /><a href="https://toutiao.io/k/cifpaoe">如何吃透一个 Java 项目？（附学习实践）</a><br /><a href="https://toutiao.io/k/tpmw10f">集群管理系统 Mesos 的设计原理</a><br /><a href="https://toutiao.io/k/uaiufr5">Spring Boot 第一弹，问候一下世界</a><br /><a href="https://toutiao.io/k/7as4kva">使用 FFmpeg 与 WebAssembly 实现纯前端视频截帧</a><br /><a href="https://toutiao.io/k/30dhzjh">任务队列神器：Celery 入门到进阶指南</a><br /><a href="https://toutiao.io/k/01ikarf">用 JavaScript 实现队列</a><br /><a href="https://toutiao.io/k/1ackb6e">第三方 cookie 的消失，会暴露谷歌的阿喀琉斯之踵吗？</a><br /><a href="https://toutiao.io/k/i2o3u7w">[译] 借助 Pod 删除事件的传播实现 Pod 摘流</a><br /><a href="https://toutiao.io/k/ps4rt7c">春招冲冲冲（钉钉 + 腾讯）</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/5apgnxp">[推荐] Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/xpyufe6">[推荐] 你对天天挂在嘴边的高并发，怕是有什么误解吧？</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/nvr0l12">[推荐] 权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/ghs0i7r">[推荐] 不懂什么是云原生？看完这篇文章就够了！</a><br /><a href="https://toutiao.io/k/lq6l2fa">[推荐] 加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/vhnnxpo">[推荐] Rhit：高效可视化 Nginx 日志查看工具，每秒处理百万行日志数据</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><hr /><a href="https://github.com/fogleman/physarum">Physarum polycephalum slime mold simulation</a><br /><a href="https://github.com/rms-support-letter/rms-support-letter.github.io">An open letter in support of Richard Matthew Stallman being reinstated by the Free Software Foundation</a><br /><a href="https://github.com/benawad/dogehouse">Taking voice conversations to the moon 🚀</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/alexgurr/react-coding-challenges">A series of ReactJS coding challenges with a variety of difficulties.</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs such as http://ipstack.com, http://fixer.io/, https://numverify.com/, etc. for use in software and web development.</a><br /><a href="https://github.com/MarlinFirmware/Marlin">Marlin is an optimized firmware for RepRap 3D printers based on the Arduino platform. | Many commercial 3D printers come with Marlin installed. Check with your vendor if you need source code for your specific machine.</a><br /><a href="https://github.com/lnishan/awesome-competitive-programming">💎 A curated list of awesome Competitive Programming, Algorithm and Data Structure resources</a><br /><a href="https://github.com/lydiahallie/javascript-questions">A long list of (advanced) JavaScript questions, and their explanations ✨</a><br /><a href="https://github.com/ventoy/Ventoy">A new bootable USB solution.</a><br /><a href="https://github.com/davidbombal/red-python-scripts"></a><br /><a href="https://github.com/Asabeneh/30-Days-Of-React">30 Days of React challenge is a step by step guide to learn React in 30 days. It requires HTML, CSS, and JavaScript knowledge. You should be comfortable with JavaScript before you start to React. If you are not comfortable with JavaScript check out 30DaysOfJavaScript. This is a continuation of 30 Days Of JS. This challenge may take up to 100 day…</a><br /><a href="https://github.com/storm-devs/storm-engine">Game engine behind Sea Dogs, Pirates of the Caribbean and Age of Pirates games.</a><br /><a href="https://github.com/mentebinaria/retoolkit">Reverse Engineer's Toolkit</a><br /><a href="https://github.com/lucidrains/deep-daze">Simple command line tool for text to image generation using OpenAI's CLIP and Siren (Implicit neural representation network)</a><br /><a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite">PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)</a><br /><a href="https://github.com/davepl/Primes">Prime Number Projects in C#/C++/Python</a><br /><a href="https://github.com/sebastianruder/NLP-progress">Repository to track the progress in Natural Language Processing (NLP), including the datasets and the current state-of-the-art for the most common NLP tasks.</a><br /><a href="https://github.com/morpheusthewhite/spicetify-themes">A community-driven collection of themes for Spicetify (https://github.com/khanhas/spicetify-cli)</a><br /><a href="https://github.com/signalapp/Signal-iOS">A private messenger for iOS.</a><br /><a href="https://github.com/MarlinFirmware/Configurations">Configurations for Marlin Firmware</a><br /><a href="https://github.com/freddier/hyperblog">Un blog increíble para el curso de Git y Github de Platzi</a><br /><a href="https://github.com/iamadamdev/bypass-paywalls-chrome">Bypass Paywalls web browser extension for Chrome and Firefox.</a><br /><a href="https://github.com/login?return_to=%2Fneovim%2Fneovim">Vim-fork focused on extensibility and usability</a><br /><hr />颠倒二进制位<br /><p>颠倒给定的 32 位无符号整数的二进制位。</p>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
	<li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284" target="_blank">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>
</ul>

<p> </p>

<p><strong>进阶</strong>:<br />
如果多次调用这个函数，你将如何优化你的算法？</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入:</strong> 00000010100101000001111010011100
<strong>输出:</strong> 00111001011110000010100101000000
<strong>解释: </strong>输入的二进制串 <strong>00000010100101000001111010011100 </strong>表示无符号整数<strong> 43261596</strong><strong>，
</strong>     因此返回 964176192，其二进制表示形式为 <strong>00111001011110000010100101000000</strong>。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>11111111111111111111111111111101
<strong>输出：</strong>10111111111111111111111111111111
<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 <strong>10111111111111111111111111111111 。</strong></pre>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 00000010100101000001111010011100
<strong>输出：</strong>964176192 (00111001011110000010100101000000)
<strong>解释：</strong>输入的二进制串 <strong>00000010100101000001111010011100 </strong>表示无符号整数<strong> 43261596</strong><strong>，
    </strong> 因此返回 964176192，其二进制表示形式为 <strong>00111001011110000010100101000000</strong>。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 11111111111111111111111111111101
<strong>输出：</strong>3221225471 (10111111111111111111111111111111)
<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 <strong>10111111111111111111111111111111 。</strong></pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>输入是一个长度为 <code>32</code> 的二进制字符串</li>
</ul>
<br />#### 方法一：逐位颠倒

**思路**

将 $n$ 视作一个长为 $32$ 的二进制串，从低位往高位枚举 $n$ 的每一位，将其倒序添加到翻转结果 $\textit{rev}$ 中。

代码实现中，每枚举一位就将 $n$ 右移一位，这样当前 $n$ 的最低位就是我们要枚举的比特位。当 $n$ 为 $0$ 时即可结束循环。

需要注意的是，在某些语言（如 $\texttt{Java}$）中，没有无符号整数类型，因此对 $n$ 的右移操作应使用逻辑右移。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t rev = 0;
        for (int i = 0; i < 32 && n > 0; ++i) {
            rev |= (n & 1) << (31 - i);
            n >>= 1;
        }
        return rev;
    }
};
```

```Java [sol1-Java]
public class Solution {
    public int reverseBits(int n) {
        int rev = 0;
        for (int i = 0; i < 32 && n != 0; ++i) {
            rev |= (n & 1) << (31 - i);
            n >>>= 1;
        }
        return rev;
    }
}
```

```go [sol1-Golang]
func reverseBits(n uint32) (rev uint32) {
    for i := 0; i < 32 && n > 0; i++ {
        rev |= n & 1 << (31 - i)
        n >>= 1
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var reverseBits = function(n) {
    let rev = 0;
    for (let i = 0; i < 32 && n > 0; ++i) {
        rev |= (n & 1) << (31 - i);
        n >>>= 1;
    }
    return rev >>> 0;
};
```

```C [sol1-C]
uint32_t reverseBits(uint32_t n) {
    uint32_t rev = 0;
    for (int i = 0; i < 32 && n > 0; ++i) {
        rev |= (n & 1) << (31 - i);
        n >>= 1;
    }
    return rev;
}
```

**复杂度分析**

- 时间复杂度：$O(\log n)$。

- 空间复杂度：$O(1)$。

#### 方法二：位运算分治

**思路**

若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。

由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。

![fig1](https://assets.leetcode-cn.com/solution-static/190/190_fig1.png){:width="60%"}

对于递归的最底层，我们需要交换所有奇偶位：

1. 取出所有奇数位和偶数位；
2. 将奇数位移到偶数位上，偶数位移到奇数位上。

类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。

需要注意的是，在某些语言（如 $\texttt{Java}$）中，没有无符号整数类型，因此对 $n$ 的右移操作应使用逻辑右移。

**代码**

```C++ [sol2-C++]
class Solution {
private:
    const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101
    const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011
    const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111

public:
    uint32_t reverseBits(uint32_t n) {
        n = n >> 1 & M1 | (n & M1) << 1;
        n = n >> 2 & M2 | (n & M2) << 2;
        n = n >> 4 & M4 | (n & M4) << 4;
        n = n >> 8 & M8 | (n & M8) << 8;
        return n >> 16 | n << 16;
    }
};
```

```Java [sol2-Java]
public class Solution {
    private static final int M1 = 0x55555555; // 01010101010101010101010101010101
    private static final int M2 = 0x33333333; // 00110011001100110011001100110011
    private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111

    public int reverseBits(int n) {
        n = n >>> 1 & M1 | (n & M1) << 1;
        n = n >>> 2 & M2 | (n & M2) << 2;
        n = n >>> 4 & M4 | (n & M4) << 4;
        n = n >>> 8 & M8 | (n & M8) << 8;
        return n >>> 16 | n << 16;
    }
}
```

```go [sol2-Golang]
const (
    m1 = 0x55555555 // 01010101010101010101010101010101
    m2 = 0x33333333 // 00110011001100110011001100110011
    m4 = 0x0f0f0f0f // 00001111000011110000111100001111
    m8 = 0x00ff00ff // 00000000111111110000000011111111
)

func reverseBits(n uint32) uint32 {
    n = n>>1&m1 | n&m1<<1
    n = n>>2&m2 | n&m2<<2
    n = n>>4&m4 | n&m4<<4
    n = n>>8&m8 | n&m8<<8
    return n>>16 | n<<16
}
```

```JavaScript [sol2-JavaScript]
var reverseBits = function(n) {
    const M1 = 0x55555555; // 01010101010101010101010101010101
    const M2 = 0x33333333; // 00110011001100110011001100110011
    const M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    const M8 = 0x00ff00ff; // 00000000111111110000000011111111

    n = n >>> 1 & M1 | (n & M1) << 1;
    n = n >>> 2 & M2 | (n & M2) << 2;
    n = n >>> 4 & M4 | (n & M4) << 4;
    n = n >>> 8 & M8 | (n & M8) << 8;
    return (n >>> 16 | n << 16) >>> 0;
};
```

```C [sol2-C]
const uint32_t M1 = 0x55555555;  // 01010101010101010101010101010101
const uint32_t M2 = 0x33333333;  // 00110011001100110011001100110011
const uint32_t M4 = 0x0f0f0f0f;  // 00001111000011110000111100001111
const uint32_t M8 = 0x00ff00ff;  // 00000000111111110000000011111111

uint32_t reverseBits(uint32_t n) {
    n = n >> 1 & M1 | (n & M1) << 1;
    n = n >> 2 & M2 | (n & M2) << 2;
    n = n >> 4 & M4 | (n & M4) << 4;
    n = n >> 8 & M8 | (n & M8) << 8;
    return n >> 16 | n << 16;
}
```

**复杂度分析**

- 时间复杂度：$O(1)$。

- 空间复杂度：$O(1)$。