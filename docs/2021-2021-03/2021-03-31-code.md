# 2021年03月31日 code
<a href="https://toutiao.io/k/f0361xm">高并发下如何保证接口的幂等性？</a><br /><a href="https://toutiao.io/k/nh6jij4">我，第一次做项目经理，干赔了</a><br /><a href="https://toutiao.io/k/3j6wxlw">数据采集组件：Flume 基础用法和 Kafka 集成</a><br /><a href="https://toutiao.io/k/3kqi349">AQS 是如何控制线程的</a><br /><a href="https://toutiao.io/k/65w6bft">JVM 进阶之路（六）：垃圾收集理论和算法</a><br /><a href="https://toutiao.io/k/w2tps5t">全量同步 Elasticsearch 方案之 Canal</a><br /><a href="https://toutiao.io/k/7y8t1lw">TCP/IP 协议的经典面试知识点总结</a><br /><a href="https://toutiao.io/k/h617382">大厂的面试官是如何挑人的？</a><br /><a href="https://toutiao.io/k/3l32umv">聊聊 DNS 的那些小知识</a><br /><a href="https://toutiao.io/k/l9hnc29">大红大紫的 Golang 真的是后端开发中的万能药吗？</a><br /><a href="https://toutiao.io/k/rmvyfcq">有赞 App 如何实现动态域名</a><br /><a href="https://toutiao.io/k/1a0v2hn">编程角度谈抽象</a><br /><a href="https://toutiao.io/k/57jid6q">设计稿（UI 视图）自动生成代码方案的探索</a><br /><a href="https://toutiao.io/k/05qve4s">熬夜肝了个 IDEA 插件整合程序员常用的工具，总有你能用上的</a><br /><a href="https://toutiao.io/k/dtuuqu5">苦于没有 Go 实战项目？也许本文的一些想法可以试试</a><br /><a href="https://toutiao.io/k/pjzon5x">如何提高 Debug 效率</a><br /><a href="https://toutiao.io/k/hmp3z65">实时数据聚合怎么破</a><br /><a href="https://toutiao.io/k/ol2xx31">JS 编码技巧：技巧掌握的好，业务代码才能写的溜</a><br /><a href="https://toutiao.io/k/e7llpmp">[译] ASP.NET Core 基于角色的 JWT 令牌</a><br /><a href="https://toutiao.io/k/fzg1pti">PHP 的 Git 服务器被黑客入侵，源代码被插入后门代码</a><br /><a href="https://toutiao.io/k/bkhurax">Arthas Star 突破 2.5W，排名 Github Alibaba Group 第一</a><br /><a href="https://toutiao.io/k/6hopkg8">工具 | 滴滴开源的一套 Android 路由框架</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><a href="https://toutiao.io/k/7aczn5o">[推荐] 面试官常问的垃圾回收器，这次全搞懂</a><br /><a href="https://toutiao.io/k/vhnnxpo">[推荐] Rhit：高效可视化 Nginx 日志查看工具，每秒处理百万行日志数据</a><br /><a href="https://toutiao.io/k/adg4qv6">[推荐] Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/nvr0l12">[推荐] 权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/lq6l2fa">[推荐] 加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/ny7vvdw">[推荐] 万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><hr /><a href="https://github.com/lucidrains/deep-daze">Simple command line tool for text to image generation using OpenAI's CLIP and Siren (Implicit neural representation network)</a><br /><a href="https://github.com/php/php-src">The PHP Interpreter</a><br /><a href="https://github.com/Datalux/Osintgram">Osintgram is a OSINT tool on Instagram. It offers an interactive shell to perform analysis on Instagram account of any users by its nickname</a><br /><a href="https://github.com/NAalytics/Assemblies-of-putative-SARS-CoV2-spike-encoding-mRNA-sequences-for-vaccines-BNT-162b2-and-mRNA-1273">RNA vaccines have become a key tool in moving forward through the challenges raised both in the current pandemic and in numerous other public health and medical challenges. With the rollout of vaccines for COVID-19, these synthetic mRNAs have become broadly distributed RNA species in numerous human populations. Despite their ubiquity, sequences …</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/login?return_to=%2Fnuxt%2Fnuxt.js">The Intuitive Vue Framework</a><br /><a href="https://github.com/intel-isl/DPT">Dense Prediction Transformers</a><br /><a href="https://github.com/randallkanna/awesome-job-list"></a><br /><a href="https://github.com/hneemann/Digital">A digital logic designer and circuit simulator.</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs such as http://ipstack.com, http://fixer.io/, https://numverify.com/, etc. for use in software and web development.</a><br /><a href="https://github.com/1ndianl33t/Bug-Bounty-Roadmaps">Bug Bounty Roadmaps</a><br /><a href="https://github.com/donnemartin/data-science-ipython-notebooks">Data science Python notebooks: Deep learning (TensorFlow, Theano, Caffe, Keras), scikit-learn, Kaggle, big data (Spark, Hadoop MapReduce, HDFS), matplotlib, pandas, NumPy, SciPy, Python essentials, AWS, and various command lines.</a><br /><a href="https://github.com/login?return_to=%2F3096%2Fgenshin_scripts"></a><br /><a href="https://github.com/jychp/cloudflare-bypass">Bypass Coudflare bot protection using Cloudflare Workers</a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/russsiq/laravel-docs-8.x-ru">Неофициальная документация Laravel 8.x на русском языке.</a><br /><a href="https://github.com/microsoft/Swin-Transformer">a general-purpose Transformer based vision backbone</a><br /><a href="https://github.com/harryheman/React-Total">Ресурс для изучения React.js и связанных с ним технологий на русском языке</a><br /><a href="https://github.com/Asabeneh/30-Days-Of-React">30 Days of React challenge is a step by step guide to learn React in 30 days. It requires HTML, CSS, and JavaScript knowledge. You should be comfortable with JavaScript before you start to React. If you are not comfortable with JavaScript check out 30DaysOfJavaScript. This is a continuation of 30 Days Of JS. This challenge may take up to 100 day…</a><br /><a href="https://github.com/dromara/sa-token">这可能是史上功能最全的Java权限认证框架！目前已集成——登录验证、权限验证、Session会话、踢人下线、分布式会话、单点登录、OAuth2.0、记住我模式、模拟他人账号、临时身份切换、集成Redis、多账号认证体系、前后台分离模式、注解式鉴权、路由拦截式鉴权、花式token生成、自动续签、同端互斥登录、会话治理、密码加密、jwt集成、Spring集成...</a><br /><a href="https://github.com/CyberPunkMetalHead/bitcoin-bot-buy-if-elon-tweets">This is a bitcoin bot that will automatically buy bitcoin if Elon Musk Tweets about it. It is a configurable crypto trading bot that listens to Technoking Musk to express his opinions on Bitcoin and buy as soon as he's tweeted.</a><br /><a href="https://github.com/nvm-sh/nvm">Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</a><br /><a href="https://github.com/nccgroup/ScoutSuite">Multi-Cloud Security Auditing Tool</a><br /><a href="https://github.com/Tylous/Limelighter">A tool for generating fake code signing certificates or signing real ones</a><br /><hr />子集 II<br /><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>

<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>

<div class="original__bRMd">
<div>
<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,2]
<strong>输出：</strong>[[],[1],[1,2],[1,2,2],[2],[2,2]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>[[],[0]]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 10</code></li>
	<li><code>-10 <= nums[i] <= 10</code></li>
</ul>
</div>
</div>
<br />#### 前言

本题解基于「[78. 子集的官方题解](https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/)」，请读者在充分理解该题解后继续阅读。

#### 方法一：迭代法实现子集枚举

**思路**

考虑数组 $[1,2,2]$，选择前两个数，或者第一、三个数，都会得到相同的子集。

也就是说，对于当前选择的数 $x$，若前面有与其相同的数 $y$，且没有选择 $y$，此时包含 $x$ 的子集，必然会出现在包含 $y$ 的所有子集中。

我们可以通过判断这种情况，来避免生成重复的子集。代码实现时，可以先将数组排序；迭代时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    vector<int> t;
    vector<vector<int>> ans;

    vector<vector<int>> subsetsWithDup(vector<int> &nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int mask = 0; mask < (1 << n); ++mask) {
            t.clear();
            bool flag = true;
            for (int i = 0; i < n; ++i) {
                if (mask & (1 << i)) {
                    if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {
                        flag = false;
                        break;
                    }
                    t.push_back(nums[i]);
                }
            }
            if (flag) {
                ans.push_back(t);
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for (int mask = 0; mask < (1 << n); ++mask) {
            t.clear();
            boolean flag = true;
            for (int i = 0; i < n; ++i) {
                if ((mask & (1 << i)) != 0) {
                    if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {
                        flag = false;
                        break;
                    }
                    t.add(nums[i]);
                }
            }
            if (flag) {
                ans.add(new ArrayList<Integer>(t));
            }
        }
        return ans;
    }
}
```

```go [sol1-Golang]
func subsetsWithDup(nums []int) (ans [][]int) {
    sort.Ints(nums)
    n := len(nums)
outer:
    for mask := 0; mask < 1<<n; mask++ {
        t := []int{}
        for i, v := range nums {
            if mask>>i&1 > 0 {
                if i > 0 && mask>>(i-1)&1 == 0 && v == nums[i-1] {
                    continue outer
                }
                t = append(t, v)
            }
        }
        ans = append(ans, append([]int(nil), t...))
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var subsetsWithDup = function(nums) {
    nums.sort((a, b) => a - b);
    let t = [], ans = [];
    const n = nums.length;
    for (let mask = 0; mask < (1 << n); ++mask) {
        t = [];
        let flag = true;
        for (let i = 0; i < n; ++i) {
            if ((mask & (1 << i)) != 0) {
                if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {
                    flag = false;
                    break;
                }
                t.push(nums[i]);
            }
        }
        if (flag) {
            ans.push(t.slice());
        }
    }
    return ans;
};
```

```C [sol1-C]
int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    qsort(nums, numsSize, sizeof(int), cmp);
    int n = numsSize;
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * (1 << n));
    int** ans = malloc(sizeof(int*) * (1 << n));
    for (int mask = 0; mask < (1 << n); ++mask) {
        int* t = malloc(sizeof(int) * n);
        int tSize = 0;
        bool flag = true;
        for (int i = 0; i < n; ++i) {
            if (mask & (1 << i)) {
                if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {
                    flag = false;
                    break;
                }
                t[tSize++] = nums[i];
            }
        }
        t = realloc(t, sizeof(int) * tSize);
        if (flag) {
            ans[*returnSize] = t;
            (*returnColumnSizes)[(*returnSize)++] = tSize;
        }
    }
    ans = realloc(ans, sizeof(int*) * (*returnSize));
    return ans;
}
```

**复杂度分析**

- 时间复杂度：$O(n \times 2^n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。排序的时间复杂度为 $O(n \log n)$。一共 $2^n$ 个状态，每种状态需要 $O(n)$ 的时间来构造子集，一共需要 $O(n \times 2^n)$ 的时间来构造子集。由于在渐进意义上 $O(n \log n)$ 小于 $O(n \times 2^n)$，故总的时间复杂度为 $O(n \times 2^n)$。

- 空间复杂度：$O(n)$。即构造子集使用的临时数组 $t$ 的空间代价。

#### 方法二：递归法实现子集枚举

**思路**

与方法一类似，在递归时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    vector<int> t;
    vector<vector<int>> ans;

    void dfs(bool choosePre, int cur, vector<int> &nums) {
        if (cur == nums.size()) {
            ans.push_back(t);
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.push_back(nums[cur]);
        dfs(true, cur + 1, nums);
        t.pop_back();
    }

    vector<vector<int>> subsetsWithDup(vector<int> &nums) {
        sort(nums.begin(), nums.end());
        dfs(false, 0, nums);
        return ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(false, 0, nums);
        return ans;
    }

    public void dfs(boolean choosePre, int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.add(nums[cur]);
        dfs(true, cur + 1, nums);
        t.remove(t.size() - 1);
    }
}
```

```go [sol2-Golang]
func subsetsWithDup(nums []int) (ans [][]int) {
    sort.Ints(nums)
    t := []int{}
    var dfs func(bool, int)
    dfs = func(choosePre bool, cur int) {
        if cur == len(nums) {
            ans = append(ans, append([]int(nil), t...))
            return
        }
        dfs(false, cur+1)
        if !choosePre && cur > 0 && nums[cur-1] == nums[cur] {
            return
        }
        t = append(t, nums[cur])
        dfs(true, cur+1)
        t = t[:len(t)-1]
    }
    dfs(false, 0)
    return
}
```

```JavaScript [sol2-JavaScript]
var subsetsWithDup = function(nums) {
    nums.sort((a, b) => a - b);
    let t = [], ans = [];
    const dfs = (choosePre, cur, nums) => {
        if (cur === nums.length) {
            ans.push(t.slice());
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] === nums[cur]) {
            return;
        }
        t.push(nums[cur]);
        dfs(true, cur + 1, nums);
        t = t.slice(0, t.length - 1);
    }
    dfs(false, 0, nums);
    return ans;
};
```

```C [sol1-C]
int cmp(int* a, int* b) {
    return *a - *b;
}

int* t;
int tSize;

void dfs(bool choosePre, int cur, int* nums, int numSize, int** ret, int* returnSize, int** returnColumnSizes) {
    if (cur == numSize) {
        int* tmp = malloc(sizeof(int) * tSize);
        memcpy(tmp, t, sizeof(int) * tSize);
        ret[*returnSize] = tmp;
        (*returnColumnSizes)[(*returnSize)++] = tSize;
        return;
    }
    dfs(false, cur + 1, nums, numSize, ret, returnSize, returnColumnSizes);
    if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
        return;
    }
    t[tSize++] = nums[cur];
    dfs(true, cur + 1, nums, numSize, ret, returnSize, returnColumnSizes);
    tSize--;
}

int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    qsort(nums, numsSize, sizeof(int), cmp);
    int n = numsSize;
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * (1 << n));
    int** ret = malloc(sizeof(int*) * (1 << n));
    t = malloc(sizeof(int) * n);
    dfs(false, 0, nums, n, ret, returnSize, returnColumnSizes);
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(n \times 2^n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。排序的时间复杂度为 $O(n \log n)$。最坏情况下 $\textit{nums}$ 中无重复元素，需要枚举其所有 $2^n$ 个子集，每个子集加入答案时需要拷贝一份，耗时 $O(n)$，一共需要 $O(n \times 2^n)+O(n)=O(n \times 2^n)$ 的时间来构造子集。由于在渐进意义上 $O(n \log n)$ 小于 $O(n \times 2^n)$，故总的时间复杂度为 $O(n \times 2^n)$。 

- 空间复杂度：$O(n)$。临时数组 $\textit{t}$ 的空间代价是 $O(n)$，递归时栈空间的代价为 $O(n)$。