# 2021年03月11日 code
<a href="https://toutiao.io/k/dux0ogl">这几款 JVM 故障诊断处理工具你还不会？</a><br /><a href="https://toutiao.io/k/tgp1ua8">面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</a><br /><a href="https://toutiao.io/k/r5kgujp">从技术专家到技术管理，我对管理的思考</a><br /><a href="https://toutiao.io/k/hxrinvv">下一代微服务 Service Mesh 原理及实践</a><br /><a href="https://toutiao.io/k/fyysozx">2021 技术展望 | 走向未来的实时生成技术</a><br /><a href="https://toutiao.io/k/ss4ai4h">告诉你 5 个足以让你装逼到飞的 Excel 小技巧</a><br /><a href="https://toutiao.io/k/ga340bq">MySQL 读写分离，写完读不到问题如何解决</a><br /><a href="https://toutiao.io/k/qh7wgrx">去哪里找 Java 练手项目？</a><br /><a href="https://toutiao.io/k/on8e69z">手摸手 Go 深入剖析 sync.Pool</a><br /><a href="https://toutiao.io/k/yduqoev">Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis</a><br /><a href="https://toutiao.io/k/8lvy3ef">Eureka Server 开关流程</a><br /><a href="https://toutiao.io/k/ihhl9au">书单：互联网企业面试案头书之程序员技术篇</a><br /><a href="https://toutiao.io/k/d8c7pym">几乎刷完了力扣所有的二分题，我发现了这些东西（上）</a><br /><a href="https://toutiao.io/k/ugfcoby">Git 文章集锦</a><br /><a href="https://toutiao.io/k/8gc0m8s">iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践</a><br /><a href="https://toutiao.io/k/my0ws7p">详细聊聊 RecyclerView 缓存机制</a><br /><a href="https://toutiao.io/k/77gyr7m">程序员必须知道的数据结构：队列与栈</a><br /><a href="https://toutiao.io/k/ai9nb69">那些有趣/实用的 Chrome 扩展神器系列（三）</a><br /><a href="https://toutiao.io/k/8nlra4s">漫画｜程序员：大师，我想写个操作系统</a><br /><a href="https://toutiao.io/k/fgc5g8r">[译] Jetpack Compose Beta 版现已发布</a><br /><a href="https://toutiao.io/k/9v93x32">[推荐] 帮助阅读源码的 8 个技巧</a><br /><a href="https://toutiao.io/k/3loin1u">[推荐] Golang 性能诊断看这篇就够了</a><br /><a href="https://toutiao.io/k/jfopywh">[推荐] Web 安全头号大敌 XSS 漏洞解决最佳实践</a><br /><a href="https://toutiao.io/k/cpf8p4q">[推荐] 流量复制方案对比：TCPCopy vs Goreplay</a><br /><a href="https://toutiao.io/k/671eano">[推荐] 快手超大规模集群调度优化实践</a><br /><a href="https://toutiao.io/k/g6xlwp2">[推荐] 做一个很出色的程序员</a><br /><a href="https://toutiao.io/k/txzl2gg">[推荐] 2021 阿里淘系工程师推荐书单</a><br /><a href="https://toutiao.io/k/jpow46x">[推荐] 最新互联网大厂职位薪资，快来对号入座吧</a><br /><a href="https://toutiao.io/k/hueiax0">[推荐] MySQL 索引从基础到原理，看这一篇就够了</a><br /><a href="https://toutiao.io/k/x6ro69m">[推荐] 高并发系统的限流策略：漏桶和令牌桶（附源码剖析）</a><br /><a href="https://toutiao.io/k/gheevc3">[推荐] ​程序员划水指南</a><br /><a href="https://toutiao.io/k/c1uc4c2">[推荐] 万字长文聊缓存（下）：应用级缓存</a><br /><a href="https://toutiao.io/k/j7v5pee">[推荐] 国内有哪些顶级技术团队的博客值得推荐？</a><br /><a href="https://toutiao.io/k/h2vf9va">[推荐] Linux 内存管理</a><br /><a href="https://toutiao.io/k/pys6jzz">[推荐] 一次 MySQL 线上死锁分析实战</a><br /><hr /><a href="https://github.com/sherlock-project/sherlock">🔎 Hunt down social media accounts by username across social networks</a><br /><a href="https://github.com/microsoft/CSS-Exchange">Exchange Server support tools and scripts</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/LeCoupa/awesome-cheatsheets">👩‍💻👨‍💻 Awesome cheatsheets for popular programming languages, frameworks and development tools. They include everything you should know in one single file.</a><br /><a href="https://github.com/qier222/YesPlayMusic">高颜值的第三方网易云播放器，支持 Windows / macOS / Linux</a><br /><a href="https://github.com/leonardomso/33-js-concepts">📜 33 concepts every JavaScript developer should know.</a><br /><a href="https://github.com/login?return_to=%2Fkootenpv%2Fwhereami">Uses WiFi signals 📶 and machine learning to predict where you are</a><br /><a href="https://github.com/bradtraversy/design-resources-for-developers">Curated list of design and UI resources from stock photos, web templates, CSS frameworks, UI libraries, tools and much more</a><br /><a href="https://github.com/d2l-ai/d2l-zh">《动手学深度学习》：面向中文读者、能运行、可讨论。中英文版被全球175所大学采用教学。</a><br /><a href="https://github.com/SeleniumHQ/selenium">A browser automation framework and ecosystem.</a><br /><a href="https://github.com/diasurgical/devilutionX">Diablo build for modern operating systems</a><br /><a href="https://github.com/pavlobu/deskreen">Deskreen turns any device with a web browser into a secondary screen for your computer</a><br /><a href="https://github.com/srcrs/UnicomTask">联通手机营业厅自动做任务、签到、领流量、领积分等。</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/ageron/handson-ml2">A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in Python using Scikit-Learn, Keras and TensorFlow 2.</a><br /><a href="https://github.com/evanw/esbuild">An extremely fast JavaScript bundler and minifier</a><br /><a href="https://github.com/ryanmcdermott/clean-code-javascript">🛁 Clean Code concepts adapted for JavaScript</a><br /><a href="https://github.com/globalaihub/introduction-to-python"></a><br /><a href="https://github.com/hashicorp/consul">Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure.</a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/vmware-tanzu/octant">Highly extensible platform for developers to better understand the complexity of Kubernetes clusters.</a><br /><a href="https://github.com/labuladong/fucking-algorithm">刷算法全靠套路，认准 labuladong 就够了！English version supported! Crack LeetCode, not only how, but also why.</a><br /><a href="https://github.com/Azure/azure-sdk-for-net">This repository is for active development of the Azure SDK for .NET. For consumers of the SDK we recommend visiting our public developer docs at https://docs.microsoft.com/en-us/dotnet/azure/ or our versioned developer docs at https://azure.github.io/azure-sdk-for-net.</a><br /><a href="https://github.com/angular/angular">One framework. Mobile & desktop.</a><br /><a href="https://github.com/MrXujiang/h5-Dooring">H5 Page Maker, H5 Editor. Make H5 as easy as building blocks. | 让H5制作像搭积木一样简单, 致力于提供一套简单方便、专业可靠、无限可能的H5/PC落地页解决方案.</a><br /><hr />基本计算器 II<br /><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>

<p>整数除法仅保留整数部分。</p>

<div class="original__bRMd">
<div>
<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "3+2*2"
<strong>输出：</strong>7
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = " 3/2 "
<strong>输出：</strong>1
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = " 3+5 / 2 "
<strong>输出：</strong>5
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= s.length <= 3 * 10<sup>5</sup></code></li>
	<li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>
	<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>
	<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 2<sup>31</sup> - 1]</code> 内</li>
	<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>
</ul>
</div>
</div>
<br />#### 方法一：栈

**思路**

由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。

基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。

具体来说，遍历字符串 $s$，并用变量 $\textit{preSign}$ 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 $\textit{preSign}$ 来决定计算方式：

- 加号：将数字压入栈；
- 减号：将数字的相反数压入栈；
- 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。

代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 $\textit{preSign}$ 为当前遍历的字符。

遍历完字符串 $s$ 后，将栈中元素累加，即为该字符串表达式的值。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int calculate(string s) {
        vector<int> stk;
        char preSign = '+';
        int num = 0;
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            if (isdigit(s[i])) {
                num = num * 10 + int(s[i] - '0');
            }
            if (!isdigit(s[i]) && s[i] != ' ' || i == n - 1) {
                switch (preSign) {
                    case '+':
                        stk.push_back(num);
                        break;
                    case '-':
                        stk.push_back(-num);
                        break;
                    case '*':
                        stk.back() *= num;
                        break;
                    default:
                        stk.back() /= num;
                }
                preSign = s[i];
                num = 0;
            }
        }
        return accumulate(stk.begin(), stk.end(), 0);
    }
};
```

```Java [sol1-Java]
class Solution {
    public int calculate(String s) {
        Deque<Integer> stack = new LinkedList<Integer>();
        char preSign = '+';
        int num = 0;
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            if (Character.isDigit(s.charAt(i))) {
                num = num * 10 + s.charAt(i) - '0';
            }
            if (!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ' || i == n - 1) {
                switch (preSign) {
                    case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop() * num);
                        break;
                    default:
                        stack.push(stack.pop() / num);
                }
                preSign = s.charAt(i);
                num = 0;
            }
        }
        int ans = 0;
        while (!stack.isEmpty()) {
            ans += stack.pop();
        }
        return ans;
    }
}
```

```go [sol1-Golang]
func calculate(s string) (ans int) {
    stack := []int{}
    preSign := '+'
    num := 0
    for i, ch := range s {
        isDigit := '0' <= ch && ch <= '9'
        if isDigit {
            num = num*10 + int(ch-'0')
        }
        if !isDigit && ch != ' ' || i == len(s)-1 {
            switch preSign {
            case '+':
                stack = append(stack, num)
            case '-':
                stack = append(stack, -num)
            case '*':
                stack[len(stack)-1] *= num
            default:
                stack[len(stack)-1] /= num
            }
            preSign = ch
            num = 0
        }
    }
    for _, v := range stack {
        ans += v
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var calculate = function(s) {
    s = s.trim();
    const stack = new Array();
    let preSign = '+';
    let num = 0;
    const n = s.length;
    for (let i = 0; i < n; ++i) {
        if (!isNaN(Number(s[i])) && s[i] !== ' ') {
            num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt();
        }
        if (isNaN(Number(s[i])) || i === n - 1) {
            switch (preSign) {
                case '+':
                    stack.push(num);
                    break;
                case '-':
                    stack.push(-num);
                    break;
                case '*':
                    stack.push(stack.pop() * num);
                    break;
                default:
                    stack.push(stack.pop() / num | 0);
            }   
            preSign = s[i];
            num = 0;
        }
    }
    let ans = 0;
    while (stack.length) {
        ans += stack.pop();
    }
    return ans;
};
```

```C [sol1-C]
int calculate(char* s) {
    int n = strlen(s);
    int stk[n], top = 0;
    char preSign = '+';
    int num = 0;
    for (int i = 0; i < n; ++i) {
        if (isdigit(s[i])) {
            num = num * 10 + (int)(s[i] - '0');
        }
        if (!isdigit(s[i]) && s[i] != ' ' || i == n - 1) {
            switch (preSign) {
                case '+':
                    stk[top++] = num;
                    break;
                case '-':
                    stk[top++] = -num;
                    break;
                case '*':
                    stk[top - 1] *= num;
                    break;
                default:
                    stk[top - 1] /= num;
            }
            preSign = s[i];
            num = 0;
        }
    }
    int ret = 0;
    for (int i = 0; i < top; i++) {
        ret += stk[i];
    }
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。需要遍历字符串 $s$ 一次，计算表达式的值。

- 空间复杂度：$O(n)$，其中 $n$ 为字符串 $s$ 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 $n$。