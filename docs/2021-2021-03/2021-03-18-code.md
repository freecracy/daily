# 2021年03月18日 code
<a href="https://toutiao.io/k/vsxwjpf">Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/jdslwhk">[译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/151twp1">浅谈数仓、数仓模型分层</a><br /><a href="https://toutiao.io/k/8ku8lte">史上超强拷贝仓：GitHub 热点速览 v.21.11</a><br /><a href="https://toutiao.io/k/vhnnxpo">Rhit：高效可视化 Nginx 日志查看工具，每秒处理百万行日志数据</a><br /><a href="https://toutiao.io/k/i85nyvh">硬核操作系统讲解</a><br /><a href="https://toutiao.io/k/rmj15hr">2021 技术展望 | 弱网下的极限实时视频通信</a><br /><a href="https://toutiao.io/k/krfy529">免费的 Mac 电脑录屏方式（支持 M1 芯片）</a><br /><a href="https://toutiao.io/k/id8aj81">如何算法实现加减乘除四则运算</a><br /><a href="https://toutiao.io/k/zegwvzr">SpEL 这么香的功能都没有使用过，还敢说玩转 Spring？</a><br /><a href="https://toutiao.io/k/17cuy5c">架构设计笔记（十）：关键模式之负载均衡</a><br /><a href="https://toutiao.io/k/l0omohg">浅谈 Pull Request 与 Change Request 研发协作模式</a><br /><a href="https://toutiao.io/k/wfqc8oc">手摸手 Go 并发编程基石 atomic</a><br /><a href="https://toutiao.io/k/hq5eqo8">存量用户运营企业微信的 “用户端小程序” 优化方案</a><br /><a href="https://toutiao.io/k/wjrep39">AI 入行那些事儿（五）：以模型为驱动学习机器学习</a><br /><a href="https://toutiao.io/k/drasg6f">[译] Kubernetes 群集的零停机服务器更新</a><br /><a href="https://toutiao.io/k/zplzay4">[译] 在 .NET Core 中构建 REST API</a><br /><a href="https://toutiao.io/k/apveexq">Intellij 使用 Jenkins 插件快速构建</a><br /><a href="https://toutiao.io/k/lhikp72">书单：互联网企业面试案头书之程序员软技能篇</a><br /><a href="https://toutiao.io/k/krjsgu0">如何知人善用？</a><br /><a href="https://toutiao.io/k/g620cqe">工具 | 阿里妈妈出品的，简单易上手，可读性强的 AST 处理工具</a><br /><a href="https://toutiao.io/k/1d2mnjh">[推荐] 职场：3 天准备 5 天面试，跳槽完成</a><br /><a href="https://toutiao.io/k/xuv7rlf">[推荐] 8 张图带你了解大型应用架构演进历程</a><br /><a href="https://toutiao.io/k/yduqoev">[推荐] Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis</a><br /><a href="https://toutiao.io/k/tm4wyb0">[推荐] Redis 专题：深入解读哨兵模式</a><br /><a href="https://toutiao.io/k/g6xlwp2">[推荐] 做一个很出色的程序员</a><br /><a href="https://toutiao.io/k/txzl2gg">[推荐] 2021 阿里淘系工程师推荐书单</a><br /><a href="https://toutiao.io/k/0ic2o68">[推荐] 带你深入理解 Java 内存模型理论</a><br /><a href="https://toutiao.io/k/671eano">[推荐] 快手超大规模集群调度优化实践</a><br /><a href="https://toutiao.io/k/pmxukkm">[推荐] 面试被吊打：Redis 原理</a><br /><a href="https://toutiao.io/k/4f2u3c5">[推荐] 内存管理设计精要</a><br /><a href="https://toutiao.io/k/r5kgujp">[推荐] 从技术专家到技术管理，我对管理的思考</a><br /><a href="https://toutiao.io/k/a595tmo">[推荐] 有赞 BI 平台设计及实现</a><br /><a href="https://toutiao.io/k/2n0entj">[推荐] 21 大软件架构特点的全面解析</a><br /><a href="https://toutiao.io/k/kldrkzc">[推荐] Tomcat 性能调优应该注意什么？</a><br /><a href="https://toutiao.io/k/e3lq37o">[推荐] 2021 有哪些不容错过的后端技术趋势</a><br /><hr /><a href="https://github.com/DidierRLopes/GamestonkTerminal">The next best thing after Bloomberg Terminal</a><br /><a href="https://github.com/harskish/ganspace">Discovering Interpretable GAN Controls [NeurIPS 2020]</a><br /><a href="https://github.com/sundowndev/PhoneInfoga">Advanced information gathering & OSINT framework for phone numbers</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/flameshot-org/flameshot">Powerful yet simple to use screenshot software 🖥️ 📸</a><br /><a href="https://github.com/Ryujinx/Ryujinx">Experimental Nintendo Switch Emulator written in C#</a><br /><a href="https://github.com/google/security-research-pocs">Proof-of-concept codes created as part of security research done by Google Security Team.</a><br /><a href="https://github.com/sickcodes/osx-serial-generator">Mac Serial Generator - Generate complete sets of Serial Numbers for OSX-KVM, Docker-OSX and of course, OpenCore.</a><br /><a href="https://github.com/mentebinaria/retoolkit">Reverse Engineer's Toolkit</a><br /><a href="https://github.com/stefan-jansen/machine-learning-for-trading">Code for Machine Learning for Algorithmic Trading, 2nd edition.</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/login?return_to=%2Foppia%2Foppia">A free, online learning platform to make quality education accessible for all.</a><br /><a href="https://github.com/beurtschipper/Depix">Recovers passwords from pixelized screenshots</a><br /><a href="https://github.com/bettercap/bettercap">The Swiss Army knife for 802.11, BLE and Ethernet networks reconnaissance and MITM attacks.</a><br /><a href="https://github.com/firstcontributions/first-contributions">🚀✨ Help beginners to contribute to open source projects</a><br /><a href="https://github.com/docker/awesome-compose">Awesome Docker Compose samples</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/goabstract/Awesome-Design-Tools">The best design tools and plugins for everything 👉</a><br /><a href="https://github.com/TheAlgorithms/C">Collection of various algorithms in mathematics, machine learning, computer science, physics, etc implemented in C for educational purposes.</a><br /><a href="https://github.com/lotusirous/go-concurrency-patterns">Concurrency patterns in Go</a><br /><a href="https://github.com/naman14/adb-tools-mac">Mac menu bar app for common adb tools</a><br /><a href="https://github.com/siduck76/neovim-dots">my neovim configs</a><br /><a href="https://github.com/sudheerj/reactjs-interview-questions">List of top 500 ReactJS Interview Questions & Answers....Coding exercise questions are coming soon!!</a><br /><a href="https://github.com/sickcodes/Docker-OSX">Run Mac in a Docker! Run near native OSX-KVM in Docker! X11 Forwarding! CI/CD for OS X!</a><br /><a href="https://github.com/facebook/rocksdb">A library that provides an embeddable, persistent key-value store for fast storage.</a><br /><hr />反转链表 II<br /><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>

<p><strong>说明:</strong><br>
1 &le;&nbsp;<em>m</em>&nbsp;&le;&nbsp;<em>n</em>&nbsp;&le; 链表长度。</p>

<p><strong>示例:</strong></p>

<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4
<strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</pre>
<br />#### 前言

链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。

思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。

#### 方法一：穿针引线

我们以下图中黄色区域的链表反转为例。

![image.png](https://pic.leetcode-cn.com/1615105129-iUPoGi-image.png){:width=700}

使用「[206. 反转链表](/problems/reverse-linked-list/)」的解法，反转 `left` 到 `right` 部分以后，再拼接起来。我们还需要记录 `left` 的前一个节点，和 `right` 的后一个节点。如图所示：

![image.png](https://pic.leetcode-cn.com/1615105150-pfWiGq-image.png){:width=500}
{:align=center}

**算法步骤：**

+ 第 1 步：先将待反转的区域反转；
+ 第 2 步：把 `pre` 的 `next` 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 `next` 指针指向 `succ`。

![image.png](https://pic.leetcode-cn.com/1615105168-ZQRZew-image.png){:width=500}
{:align=center}

**说明**：编码细节我们不在题解中介绍了，请见下方代码。思路想明白以后，编码不是一件很难的事情。这里要提醒大家的是，链接什么时候切断，什么时候补上去，先后顺序一定要想清楚，如果想不清楚，可以在纸上模拟，让思路清晰。

**代码**

```C++ [sol1-C++]
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // 也可以使用递归反转一个链表
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode->next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // 注意：切断链接
        pre->next = nullptr;
        rightNode->next = nullptr;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};
```

```Java [sol1-Java]
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;

        ListNode pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode.next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode leftNode = pre.next;
        ListNode curr = rightNode.next;

        // 注意：切断链接
        pre.next = null;
        rightNode.next = null;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre.next = rightNode;
        leftNode.next = curr;
        return dummyNode.next;
    }

    private void reverseLinkedList(ListNode head) {
        // 也可以使用递归反转一个链表
        ListNode pre = null;
        ListNode cur = head;

        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
}
```

```Python [sol1-Python3]
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        def reverse_linked_list(head: ListNode):
            # 也可以使用递归反转一个链表
            pre = None
            cur = head
            while cur:
                next = cur.next
                cur.next = pre
                pre = cur
                cur = next

        # 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        dummy_node = ListNode(-1)
        dummy_node.next = head
        pre = dummy_node
        # 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        # 建议写在 for 循环里，语义清晰
        for _ in range(left - 1):
            pre = pre.next

        # 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        right_node = pre
        for _ in range(right - left + 1):
            right_node = right_node.next
        # 第 3 步：切断出一个子链表（截取链表）
        left_node = pre.next
        curr = right_node.next

        # 注意：切断链接
        pre.next = None
        right_node.next = None

        # 第 4 步：同第 206 题，反转链表的子区间
        reverse_linked_list(left_node)
        # 第 5 步：接回到原来的链表中
        pre.next = right_node
        left_node.next = curr
        return dummy_node.next
```

```go [sol1-Golang]
func reverseLinkedList(head *ListNode) {
    var pre *ListNode
    cur := head
    for cur != nil {
        next := cur.Next
        cur.Next = pre
        pre = cur
        cur = next
    }
}

func reverseBetween(head *ListNode, left, right int) *ListNode {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    dummyNode := &ListNode{Val: -1}
    dummyNode.Next = head

    pre := dummyNode
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for i := 0; i < left-1; i++ {
        pre = pre.Next
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    rightNode := pre
    for i := 0; i < right-left+1; i++ {
        rightNode = rightNode.Next
    }

    // 第 3 步：切断出一个子链表（截取链表）
    leftNode := pre.Next
    curr := rightNode.Next

    // 注意：切断链接
    pre.Next = nil
    rightNode.Next = nil

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode)

    // 第 5 步：接回到原来的链表中
    pre.Next = rightNode
    leftNode.Next = curr
    return dummyNode.Next
}
```

```C [sol1-C]
void reverseLinkedList(struct ListNode *head) {
    // 也可以使用递归反转一个链表
    struct ListNode *pre = NULL;
    struct ListNode *cur = head;

    while (cur != NULL) {
        struct ListNode *next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
}

struct ListNode *reverseBetween(struct ListNode *head, int left, int right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));
    dummyNode->val = -1;
    dummyNode->next = head;

    struct ListNode *pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (int i = 0; i < left - 1; i++) {
        pre = pre->next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    struct ListNode *rightNode = pre;
    for (int i = 0; i < right - left + 1; i++) {
        rightNode = rightNode->next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    struct ListNode *leftNode = pre->next;
    struct ListNode *curr = rightNode->next;

    // 注意：切断链接
    pre->next = NULL;
    rightNode->next = NULL;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre->next = rightNode;
    leftNode->next = curr;
    return dummyNode->next;
}
```

```JavaScript [sol1-JavaScript]
var reverseBetween = function(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;
    return dummyNode.next;
};

const reverseLinkedList = (head) => {
    let pre = null;
    let cur = head;

    while (cur) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
}
```

**复杂度分析**

+ 时间复杂度：$O(N)$，其中 $N$ 是链表总节点数。最坏情况下，需要遍历整个链表。

+ 空间复杂度：$O(1)$。只使用到常数个变量。

#### 方法二：一次遍历「穿针引线」反转链表

方法一的缺点是：如果 `left` 和 `right` 的区域很大，恰好是链表的头节点和尾节点时，找到 `left` 和 `right` 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 $O(N)$，但遍历了链表 $2$ 次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。

我们依然以方法一的示例为例进行说明。

![image.png](https://pic.leetcode-cn.com/1615105232-cvTINs-image.png)

整理思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。

![image.png](https://pic.leetcode-cn.com/1615105242-ZHlvOn-image.png){:width=500}
{:align=center}

下面我们具体解释如何实现。使用三个指针变量 `pre`、`curr`、`next` 来记录反转的过程中需要的变量，它们的意义如下：

+ `curr`：指向待反转区域的第一个节点 `left`；
+ `next`：永远指向 `curr` 的下一个节点，循环过程中，`curr` 变化以后 `next` 会变化；
+ `pre`：永远指向待反转区域的第一个节点 `left` 的前一个节点，在循环过程中不变。

第 1 步，我们使用 ①、②、③ 标注「穿针引线」的步骤。

![image.png](https://pic.leetcode-cn.com/1615105296-bmiPxl-image.png){:width=500}
{:align=center}

**操作步骤**：

+ 先将 `curr` 的下一个节点记录为 `next`；
+ 执行操作 ①：把 `curr` 的下一个节点指向 `next` 的下一个节点；
+ 执行操作 ②：把 `next` 的下一个节点指向 `pre` 的下一个节点；
+ 执行操作 ③：把 `pre` 的下一个节点指向 `next`。

第 1 步完成以后「拉直」的效果如下：

![image.png](https://pic.leetcode-cn.com/1615105340-UBnTBZ-image.png){:width=500}
{:align=center}


第 2 步，同理。同样需要注意 **「穿针引线」操作的先后顺序**。

![image.png](https://pic.leetcode-cn.com/1615105353-PsCmzb-image.png){:width=500}
{:align=center}


第 2 步完成以后「拉直」的效果如下：

![image.png](https://pic.leetcode-cn.com/1615105364-aDIFqy-image.png){:width=500}
{:align=center}

第 3 步，同理。

![image.png](https://pic.leetcode-cn.com/1615105376-jIyGwv-image.png){:width=500}
{:align=center}

第 3 步完成以后「拉直」的效果如下：

![image.png](https://pic.leetcode-cn.com/1615105395-EJQnMe-image.png){:width=500}
{:align=center}

**代码**

```C++ [sol2-C++]
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // 设置 dummyNode 是这一类问题的一般做法
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;
        ListNode *pre = dummyNode;
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }
        ListNode *cur = pre->next;
        ListNode *next;
        for (int i = 0; i < right - left; i++) {
            next = cur->next;
            cur->next = next->next;
            next->next = pre->next;
            pre->next = next;
        }
        return dummyNode->next;
    }
};
```

```Java [sol2-Java]
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 设置 dummyNode 是这一类问题的一般做法
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;
        ListNode pre = dummyNode;
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }
        ListNode cur = pre.next;
        ListNode next;
        for (int i = 0; i < right - left; i++) {
            next = cur.next;
            cur.next = next.next;
            next.next = pre.next;
            pre.next = next;
        }
        return dummyNode.next;
    }
}
```

```Python [sol2-Python3]
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        # 设置 dummyNode 是这一类问题的一般做法
        dummy_node = ListNode(-1)
        dummy_node.next = head
        pre = dummy_node
        for _ in range(left - 1):
            pre = pre.next

        cur = pre.next
        for _ in range(right - left):
            next = cur.next
            cur.next = next.next
            next.next = pre.next
            pre.next = next
        return dummy_node.next
```

```go [sol2-Golang]
func reverseBetween(head *ListNode, left, right int) *ListNode {
    // 设置 dummyNode 是这一类问题的一般做法
    dummyNode := &ListNode{Val: -1}
    dummyNode.Next = head
    pre := dummyNode
    for i := 0; i < left-1; i++ {
        pre = pre.Next
    }
    cur := pre.Next
    for i := 0; i < right-left; i++ {
        next := cur.Next
        cur.Next = next.Next
        next.Next = pre.Next
        pre.Next = next
    }
    return dummyNode.Next
}
```

```C [sol2-C]
struct ListNode *reverseBetween(struct ListNode *head, int left, int right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));
    dummyNode->val = -1;
    dummyNode->next = head;

    struct ListNode *pre = dummyNode;
    for (int i = 0; i < left - 1; i++) {
        pre = pre->next;
    }
    struct ListNode *cur = pre->next;
    struct ListNode *next;
    for (int i = 0; i < right - left; i++) {
        next = cur->next;
        cur->next = next->next;
        next->next = pre->next;
        pre->next = next;
    }
    return dummyNode->next;
}
```

```JavaScript [sol2-JavaScript]
var reverseBetween = function(head, left, right) {
    // 设置 dummyNode 是这一类问题的一般做法
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```

**复杂度分析**：

+ 时间复杂度：$O(N)$，其中 $N$ 是链表总节点数。最多只遍历了链表一次，就完成了反转。

+ 空间复杂度：$O(1)$。只使用到常数个变量。