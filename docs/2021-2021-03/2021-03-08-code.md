# 2021年03月08日 code
<a href="https://toutiao.io/k/xuv7rlf">8 张图带你了解大型应用架构演进历程</a><br /><a href="https://toutiao.io/k/a595tmo">有赞 BI 平台设计及实现</a><br /><a href="https://toutiao.io/k/f7fdiw9">[译] Offer 薪资不如预期？你或许需要薪酬谈判服务</a><br /><a href="https://toutiao.io/k/febn4rp">终于讲清楚了：深入理解 Java 应用程序中 final 关键字的各种使用场景</a><br /><a href="https://toutiao.io/k/3j3kd2k">不用代码趣讲 ZooKeeper 集群</a><br /><a href="https://toutiao.io/k/zwp7jms">美团外卖特征平台的建设与实践</a><br /><a href="https://toutiao.io/k/8464zt2">HBase 架构及原理</a><br /><a href="https://toutiao.io/k/lxa0q4p">一个开源的服务器框架，特别适用于开发小游戏</a><br /><a href="https://toutiao.io/k/2uja06c">一次完整的源码阅读过程</a><br /><a href="https://toutiao.io/k/pev3zzj">​Python 如何仅用 5000 行代码，实现强大的 logging 模块？</a><br /><a href="https://toutiao.io/k/ijrpjrx">Netty 源码解析：零拷贝机制与 ByteBuf</a><br /><a href="https://toutiao.io/k/tnz13qb">Figma：跨平台 UI 设计工具</a><br /><a href="https://toutiao.io/k/7msedjb">WinMerge：一个免费开源的文件对比神器</a><br /><a href="https://toutiao.io/k/7twdtvt">进行架构设计要了解的几种思维方式</a><br /><a href="https://toutiao.io/k/h6qcdyf">如何构建系统优化成本，携程出海云原生实践</a><br /><a href="https://toutiao.io/k/v9n8i3p">你的内存对齐了吗</a><br /><a href="https://toutiao.io/k/mz6tg81">如何编写 C++ 20 协程 (Coroutines)</a><br /><a href="https://toutiao.io/k/i4ij6n4">我花了 5 小时死磕这个俄罗斯套娃信封问题</a><br /><a href="https://toutiao.io/k/7p6qxks">入门 Serverless：简介与实践</a><br /><a href="https://toutiao.io/k/tqukert">在主动要求涨工资这事上，不要学我</a><br /><a href="https://toutiao.io/k/h2vf9va">[推荐] Linux 内存管理</a><br /><a href="https://toutiao.io/k/gheevc3">[推荐] ​程序员划水指南</a><br /><a href="https://toutiao.io/k/ix2e9ja">[推荐] 中高级前端须注意的 40 条移动端 H5 坑位指南（网易三年实践）</a><br /><a href="https://toutiao.io/k/95yxept">[推荐] 我用 Kafka 两年踩过的一些非比寻常的坑</a><br /><a href="https://toutiao.io/k/xxk05uj">[推荐] Spring Boot 异步调用</a><br /><a href="https://toutiao.io/k/90116j8">[推荐] Redis 为什么变慢了？一文讲透如何排查 Redis 性能问题</a><br /><a href="https://toutiao.io/k/jfopywh">[推荐] Web 安全头号大敌 XSS 漏洞解决最佳实践</a><br /><a href="https://toutiao.io/k/6s1vey3">[推荐] Java 高并发编程基础之 AQS</a><br /><a href="https://toutiao.io/k/9v93x32">[推荐] 帮助阅读源码的 8 个技巧</a><br /><a href="https://toutiao.io/k/r9tqaw3">[推荐] 副业刚需：在 GitHub 上也能年入百万？</a><br /><a href="https://toutiao.io/k/cpf8p4q">[推荐] 流量复制方案对比：TCPCopy vs Goreplay</a><br /><a href="https://toutiao.io/k/ycdmy3y">[推荐] 看完这篇你一定能掌握 Linux</a><br /><a href="https://toutiao.io/k/g6xlwp2">[推荐] 做一个很出色的程序员</a><br /><a href="https://toutiao.io/k/6w82jhc">[推荐] 互联网架构演进之路</a><br /><a href="https://toutiao.io/k/ep472ts">[推荐] HTTP header 中的黑科技</a><br /><hr /><a href="https://github.com/dolthub/dolt">Dolt – It's Git for Data</a><br /><a href="https://github.com/sherlock-project/sherlock">🔎 Hunt down social media accounts by username across social networks</a><br /><a href="https://github.com/nushell/nushell">A new type of shell</a><br /><a href="https://github.com/getzola/zola">A fast static site generator in a single binary with everything built-in. https://www.getzola.org</a><br /><a href="https://github.com/SerenityOS/serenity">The Serenity Operating System 🐞</a><br /><a href="https://github.com/openai/CLIP">Contrastive Language-Image Pretraining</a><br /><a href="https://github.com/nasa/fprime">F' - A flight software and embedded systems framework</a><br /><a href="https://github.com/login?return_to=%2Fziglang%2Fzig">General-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.</a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/microsoft/CSS-Exchange">Exchange Server support tools and scripts</a><br /><a href="https://github.com/josephmisiti/awesome-machine-learning">A curated list of awesome Machine Learning frameworks, libraries and software.</a><br /><a href="https://github.com/thunlp/GNNPapers">Must-read papers on graph neural networks (GNN)</a><br /><a href="https://github.com/threat9/routersploit">Exploitation Framework for Embedded Devices</a><br /><a href="https://github.com/visenger/awesome-mlops">A curated list of references for MLOps</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/qmk/qmk_firmware">Open-source keyboard firmware for Atmel AVR and Arm USB families</a><br /><a href="https://github.com/brillout/awesome-react-components">Curated List of React Components & Libraries.</a><br /><a href="https://github.com/torvalds/linux">Linux kernel source tree</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/nodegui/react-nodegui">Build performant, native and cross-platform desktop applications with native React + powerful CSS like styling.🚀</a><br /><a href="https://github.com/diasurgical/devilutionX">Diablo build for modern operating systems</a><br /><a href="https://github.com/projectdiscovery/nuclei-templates">Community curated list of templates for the nuclei engine to find a security vulnerability in the application.</a><br /><a href="https://github.com/abuanwar072/Chat-Messaging-App-Light-and-Dark-Theme"></a><br /><a href="https://github.com/monero-project/monero">Monero: the secure, private, untraceable cryptocurrency</a><br /><a href="https://github.com/ageron/handson-ml2">A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in Python using Scikit-Learn, Keras and TensorFlow 2.</a><br /><hr />分割回文串 II<br /><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>

<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>

<div class="original__bRMd">
<div>
<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "aab"
<strong>输出：</strong>1
<strong>解释：</strong>只需一次分割就可将 <em>s </em>分割成 ["aa","b"] 这样两个回文子串。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "a"
<strong>输出：</strong>0
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "ab"
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= s.length <= 2000</code></li>
	<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</div>
</div>
<br />#### 方法一：动态规划

**思路与算法**

设 $f[i]$ 表示字符串的前缀 $s[0..i]$ 的**最少**分割次数。要想得出 $f[i]$ 的值，我们可以考虑枚举 $s[0..i]$ 分割出的最后一个回文串，这样我们就可以写出状态转移方程：

$$
f[i] = \min_{0 \leq j < i} \{ f[j] \} + 1, \quad 其中 ~ s[j+1..i] ~是一个回文串
$$

即我们枚举最后一个回文串的起始位置 $j+1$，保证 $s[j+1..i]$ 是一个回文串，那么 $f[i]$ 就可以从 $f[j]$ 转移而来，附加 $1$ 次额外的分割次数。

注意到上面的状态转移方程中，我们还少考虑了一种情况，即 $s[0..i]$ 本身就是一个回文串。此时其不需要进行任何分割，即：

$$
f[i] = 0
$$

那么我们如何知道 $s[j+1..i]$ 或者 $s[0..i]$ 是否为回文串呢？我们可以使用与「[131. 分割回文串的官方题解](https://leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/)」中相同的预处理方法，将字符串 $s$ 的每个子串是否为回文串预先计算出来，即：

> 设 $g(i, j)$ 表示 $s[i..j]$ 是否为回文串，那么有状态转移方程：
>
>   $$
>   g(i, j) = \begin{cases}
>   \texttt{True}, & \quad i \geq j \\
>   g(i+1,j-1) \wedge (s[i]=s[j]), & \quad \text{otherwise}
>   \end{cases}
>   $$
>
>   其中 $\wedge$ 表示逻辑与运算，即 $s[i..j]$ 为回文串，当且仅当其为空串（$i>j$），其长度为 $1$（$i=j$），或者首尾字符相同且 $s[i+1..j-1]$ 为回文串。

这样一来，我们只需要 $O(1)$ 的时间就可以判断任意 $s[i..j]$ 是否为回文串了。通过动态规划计算出所有的 $f$ 值之后，最终的答案即为 $f[n-1]$，其中 $n$ 是字符串 $s$ 的长度。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector<vector<int>> g(n, vector<int>(n, true));

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                g[i][j] = (s[i] == s[j]) && g[i + 1][j - 1];
            }
        }

        vector<int> f(n, INT_MAX);
        for (int i = 0; i < n; ++i) {
            if (g[0][i]) {
                f[i] = 0;
            }
            else {
                for (int j = 0; j < i; ++j) {
                    if (g[j + 1][i]) {
                        f[i] = min(f[i], f[j] + 1);
                    }
                }
            }
        }

        return f[n - 1];
    }
};
```

```Java [sol1-Java]
class Solution {
    public int minCut(String s) {
        int n = s.length();
        boolean[][] g = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(g[i], true);
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                g[i][j] = s.charAt(i) == s.charAt(j) && g[i + 1][j - 1];
            }
        }

        int[] f = new int[n];
        Arrays.fill(f, Integer.MAX_VALUE);
        for (int i = 0; i < n; ++i) {
            if (g[0][i]) {
                f[i] = 0;
            } else {
                for (int j = 0; j < i; ++j) {
                    if (g[j + 1][i]) {
                        f[i] = Math.min(f[i], f[j] + 1);
                    }
                }
            }
        }

        return f[n - 1];
    }
}
```

```Python [sol1-Python3]
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        g = [[True] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                g[i][j] = (s[i] == s[j]) and g[i + 1][j - 1]

        f = [float("inf")] * n
        for i in range(n):
            if g[0][i]:
                f[i] = 0
            else:
                for j in range(i):
                    if g[j + 1][i]:
                        f[i] = min(f[i], f[j] + 1)
        
        return f[n - 1]
```

```JavaScript [sol1-JavaScript]
var minCut = function(s) {
    const n = s.length;
    const g = new Array(n).fill(0).map(() => new Array(n).fill(true));

    for (let i = n - 1; i >= 0; --i) {
        for (let j = i + 1; j < n; ++j) {
            g[i][j] = s[i] == s[j] && g[i + 1][j - 1];
        }
    }

    const f = new Array(n).fill(Number.MAX_SAFE_INTEGER);
    for (let i = 0; i < n; ++i) {
        if (g[0][i]) {
            f[i] = 0;
        } else {
            for (let j = 0; j < i; ++j) {
                if (g[j + 1][i]) {
                    f[i] = Math.min(f[i], f[j] + 1);
                }
            }
        }
    }

    return f[n - 1];
};
```

```go [sol1-Golang]
func minCut(s string) int {
    n := len(s)
    g := make([][]bool, n)
    for i := range g {
        g[i] = make([]bool, n)
        for j := range g[i] {
            g[i][j] = true
        }
    }
    for i := n - 1; i >= 0; i-- {
        for j := i + 1; j < n; j++ {
            g[i][j] = s[i] == s[j] && g[i+1][j-1]
        }
    }

    f := make([]int, n)
    for i := range f {
        if g[0][i] {
            continue
        }
        f[i] = math.MaxInt64
        for j := 0; j < i; j++ {
            if g[j+1][i] && f[j]+1 < f[i] {
                f[i] = f[j] + 1
            }
        }
    }
    return f[n-1]
}
```

```C [sol1-C]
int minCut(char* s) {
    int n = strlen(s);
    bool g[n][n];
    memset(g, 1, sizeof(g));

    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            g[i][j] = (s[i] == s[j]) && g[i + 1][j - 1];
        }
    }

    int f[n];
    for (int i = 0; i < n; ++i) {
        f[i] = INT_MAX;
    }
    for (int i = 0; i < n; ++i) {
        if (g[0][i]) {
            f[i] = 0;
        } else {
            for (int j = 0; j < i; ++j) {
                if (g[j + 1][i]) {
                    f[i] = fmin(f[i], f[j] + 1);
                }
            }
        }
    }

    return f[n - 1];
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$，其中 $n$ 是字符串 $s$ 的长度。预处理计算 $g$ 和动态规划计算 $f$ 的时间复杂度均为 $O(n^2)$。

- 空间复杂度：$O(n^2)$，数组 $g$ 需要使用 $O(n^2)$ 的空间，数组 $f$ 需要使用 $O(n^2)$ 的空间。