# 2021年03月30日 code
<a href="https://toutiao.io/k/2fe4jjq">再见 Go 面试官：GMP 模型，为什么要有 P？</a><br /><a href="https://toutiao.io/k/sso4l2l">我在架构设计和代码开发中的一些常用原则</a><br /><a href="https://toutiao.io/k/eq90xv4">Elasticsearch 警惕使用 wildcard 检索！然后呢？</a><br /><a href="https://toutiao.io/k/poubxrt">一次性总结了 Pandas 提取数据的 15 种方法，统统只需 1 行代码</a><br /><a href="https://toutiao.io/k/8labbkw">进程与线程：入门知识篇</a><br /><a href="https://toutiao.io/k/tbg8xj9">面试官再问你 ThreadLocal，就这样狠狠 “怼” 回去</a><br /><a href="https://toutiao.io/k/m0d1fm2">独立开发者如何快速从 0 到 1 设计一款 App 的 Logo（三）</a><br /><a href="https://toutiao.io/k/qfi5wvy">漫画 Go 语言 struct 转 map 或 struct 的各种方式及性能</a><br /><a href="https://toutiao.io/k/wfkmex2">[译] 使用 Vue.js 和 MJML 创建响应式电子邮件</a><br /><a href="https://toutiao.io/k/dllg2zb">基于 NextCloud 打造个人工作台</a><br /><a href="https://toutiao.io/k/m5og81o">在 Flutter 项目下安卓 flavor 打包配置实践</a><br /><a href="https://toutiao.io/k/v9aar7o">这 30 个我精选的含答案的面试题，硬不硬你说吧</a><br /><a href="https://toutiao.io/k/2svmp0r">bashrc 与 profile 的加载顺序</a><br /><a href="https://toutiao.io/k/33jacz7">使用 Python 和 VTK 库进行科学可视化</a><br /><a href="https://toutiao.io/k/dgme7ae">JavaScript 控制语句之 if/switch</a><br /><a href="https://toutiao.io/k/m731com">使用 Cosign 进行镜像签名和校验</a><br /><a href="https://toutiao.io/k/dc5hxw2">Cronet 网络协议选择之 HTTP 2 与 QUIC 的竞速</a><br /><a href="https://toutiao.io/k/q71c3hg">由 GRAFANA-IMAGE-RENDERER 引出的一个问题</a><br /><a href="https://toutiao.io/k/cjshflw">AI 入行那些事儿（七）：深度神经网络的发展及其应用</a><br /><a href="https://toutiao.io/k/sbtskq4">Emacs Lisp 语法介绍（一）</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/adg4qv6">[推荐] Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/5apgnxp">[推荐] Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><a href="https://toutiao.io/k/lq6l2fa">[推荐] 加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/vhnnxpo">[推荐] Rhit：高效可视化 Nginx 日志查看工具，每秒处理百万行日志数据</a><br /><a href="https://toutiao.io/k/nvr0l12">[推荐] 权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><hr /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/vueschool/vue-masterclass">🗂 Source code for The Vue 3 Masterclass</a><br /><a href="https://github.com/MarlinFirmware/Marlin">Marlin is an optimized firmware for RepRap 3D printers based on the Arduino platform. | Many commercial 3D printers come with Marlin installed. Check with your vendor if you need source code for your specific machine.</a><br /><a href="https://github.com/fogleman/physarum">Physarum polycephalum slime mold simulation</a><br /><a href="https://github.com/freqtrade/freqtrade">Free, open source crypto trading bot</a><br /><a href="https://github.com/NoahFetz/F1AppleTV">F1TV Client for AppleTV</a><br /><a href="https://github.com/john-smilga/javascript-basic-projects"></a><br /><a href="https://github.com/gothinkster/realworld">"The mother of all demo apps" — Exemplary fullstack Medium.com clone powered by React, Angular, Node, Django, and many more 🏅</a><br /><a href="https://github.com/SerenityOS/serenity">The Serenity Operating System 🐞</a><br /><a href="https://github.com/signalapp/Signal-iOS">A private messenger for iOS.</a><br /><a href="https://github.com/ageron/handson-ml2">A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in Python using Scikit-Learn, Keras and TensorFlow 2.</a><br /><a href="https://github.com/Ryujinx/Ryujinx">Experimental Nintendo Switch Emulator written in C#</a><br /><a href="https://github.com/harryheman/React-Total">Ресурс для изучения React.js и связанных с ним технологий на русском языке</a><br /><a href="https://github.com/Asabeneh/30-Days-Of-React">30 Days of React challenge is a step by step guide to learn React in 30 days. It requires HTML, CSS, and JavaScript knowledge. You should be comfortable with JavaScript before you start to React. If you are not comfortable with JavaScript check out 30DaysOfJavaScript. This is a continuation of 30 Days Of JS. This challenge may take up to 100 day…</a><br /><a href="https://github.com/londonappbrewery/Flutter-Course-Resources">Learn to Code While Building Apps - The Complete Flutter Development Bootcamp</a><br /><a href="https://github.com/storm-devs/storm-engine">Game engine behind Sea Dogs, Pirates of the Caribbean and Age of Pirates games.</a><br /><a href="https://github.com/ventoy/Ventoy">A new bootable USB solution.</a><br /><a href="https://github.com/sherlock-project/sherlock">🔎 Hunt down social media accounts by username across social networks</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/benawad/dogehouse">Taking voice conversations to the moon 🚀</a><br /><a href="https://github.com/monosans/vk-slaves-bot">Бот для мини-игры "Рабы" ("Рабство") ВКонтакте.</a><br /><a href="https://github.com/davepl/Primes">Prime Number Projects in C#/C++/Python</a><br /><a href="https://github.com/ramitsurana/awesome-kubernetes">A curated list for awesome kubernetes sources 🚢🎉</a><br /><a href="https://github.com/donnemartin/data-science-ipython-notebooks">Data science Python notebooks: Deep learning (TensorFlow, Theano, Caffe, Keras), scikit-learn, Kaggle, big data (Spark, Hadoop MapReduce, HDFS), matplotlib, pandas, NumPy, SciPy, Python essentials, AWS, and various command lines.</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs such as http://ipstack.com, http://fixer.io/, https://numverify.com/, etc. for use in software and web development.</a><br /><hr />搜索二维矩阵<br /><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>

<ul>
	<li>每行中的整数从左到右按升序排列。</li>
	<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
<strong>输出：</strong>false
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 <= m, n <= 100</code></li>
	<li><code>-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup></code></li>
</ul>
<br />#### 方法一：两次二分查找

**思路**

由于每行的第一个元素大于前一行的最后一个元素，且每行元素是升序的，所以每行的第一个元素大于前一行的第一个元素，因此矩阵第一列的元素是升序的。

我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    bool searchMatrix(vector<vector<int>> matrix, int target) {
        auto row = upper_bound(matrix.begin(), matrix.end(), target, [](const int b, const vector<int> &a) {
            return b < a[0];
        });
        if (row == matrix.begin()) {
            return false;
        }
        --row;
        return binary_search(row->begin(), row->end(), target);
    }
};
```

```Java [sol1-Java]
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rowIndex = binarySearchFirstColumn(matrix, target);
        if (rowIndex < 0) {
            return false;
        }
        return binarySearchRow(matrix[rowIndex], target);
    }

    public int binarySearchFirstColumn(int[][] matrix, int target) {
        int low = -1, high = matrix.length - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (matrix[mid][0] <= target) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    public boolean binarySearchRow(int[] row, int target) {
        int low = 0, high = row.length - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            if (row[mid] == target) {
                return true;
            } else if (row[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return false;
    }
}
```

```go [sol1-Golang]
func searchMatrix(matrix [][]int, target int) bool {
    row := sort.Search(len(matrix), func(i int) bool { return matrix[i][0] > target }) - 1
    if row < 0 {
        return false
    }
    col := sort.SearchInts(matrix[row], target)
    return col < len(matrix[row]) && matrix[row][col] == target
}
```

```JavaScript [sol1-JavaScript]
var searchMatrix = function(matrix, target) {
    const rowIndex = binarySearchFirstColumn(matrix, target);
    if (rowIndex < 0) {
        return false;
    }
    return binarySearchRow(matrix[rowIndex], target);
};

const binarySearchFirstColumn = (matrix, target) => {
    let low = -1, high = matrix.length - 1;
    while (low < high) {
        const mid = Math.floor((high - low + 1) / 2) + low;
        if (matrix[mid][0] <= target) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}

const binarySearchRow = (row, target) => {
    let low = 0, high = row.length - 1;
    while (low <= high) {
        const mid = Math.floor((high - low) / 2) + low;
        if (row[mid] == target) {
            return true;
        } else if (row[mid] > target) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return false;
}
```

```C [sol1-C]
int binarySearchFirstColumn(int** matrix, int matrixSize, int target) {
    int low = -1, high = matrixSize - 1;
    while (low < high) {
        int mid = (high - low + 1) / 2 + low;
        if (matrix[mid][0] <= target) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}

bool binarySearchRow(int* row, int rowSize, int target) {
    int low = 0, high = rowSize - 1;
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        if (row[mid] == target) {
            return true;
        } else if (row[mid] > target) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return false;
}

bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {
    int rowIndex = binarySearchFirstColumn(matrix, matrixSize, target);
    if (rowIndex < 0) {
        return false;
    }
    return binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target);
}
```

**复杂度分析**

- 时间复杂度：$O(\log m+\log n)=O(\log mn)$，其中 $m$ 和 $n$ 分别是矩阵的行数和列数。

- 空间复杂度：$O(1)$。

#### 方法二：一次二分查找

**思路**

若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。

代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int low = 0, high = m * n - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int x = matrix[mid / n][mid % n];
            if (x < target) {
                low = mid + 1;
            } else if (x > target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```

```Java [sol2-Java]
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int low = 0, high = m * n - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int x = matrix[mid / n][mid % n];
            if (x < target) {
                low = mid + 1;
            } else if (x > target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
}
```

```go [sol2-Golang]
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    i := sort.Search(m*n, func(i int) bool { return matrix[i/n][i%n] >= target })
    return i < m*n && matrix[i/n][i%n] == target
}
```

```JavaScript [sol2-JavaScript]
var searchMatrix = function(matrix, target) {
    const m = matrix.length, n = matrix[0].length;
    let low = 0, high = m * n - 1;
    while (low <= high) {
        const mid = Math.floor((high - low) / 2) + low;
        const x = matrix[Math.floor(mid / n)][mid % n];
        if (x < target) {
            low = mid + 1;
        } else if (x > target) {
            high = mid - 1;
        } else {
            return true;
        }
    }
    return false;
};
```

```C [sol2-C]
bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {
    int m = matrixSize, n = matrixColSize[0];
    int low = 0, high = m * n - 1;
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        int x = matrix[mid / n][mid % n];
        if (x < target) {
            low = mid + 1;
        } else if (x > target) {
            high = mid - 1;
        } else {
            return true;
        }
    }
    return false;
}
```

**复杂度分析**

- 时间复杂度：$O(\log mn)$，其中 $m$ 和 $n$ 分别是矩阵的行数和列数。

- 空间复杂度：$O(1)$。

#### 结语

两种方法殊途同归，都利用了二分查找，在二维矩阵上寻找目标值。值得注意的是，若二维数组中的一维数组的元素个数不一，方法二将会失效，而方法一则能正确处理。