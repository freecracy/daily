# 2021年03月22日 code
<a href="https://toutiao.io/k/e3lq37o">[推荐] 2021 有哪些不容错过的后端技术趋势</a><br /><a href="https://toutiao.io/k/yduqoev">[推荐] Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis</a><br /><a href="https://toutiao.io/k/av396i0">[推荐] Redis 教程：Redis 知识体系详解</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><a href="https://toutiao.io/k/a595tmo">[推荐] 有赞 BI 平台设计及实现</a><br /><a href="https://toutiao.io/k/ghs0i7r">[推荐] 不懂什么是云原生？看完这篇文章就够了！</a><br /><a href="https://toutiao.io/k/gqpcukq">[推荐] TCP/IP 常见攻击手段</a><br /><a href="https://toutiao.io/k/r5kgujp">[推荐] 从技术专家到技术管理，我对管理的思考</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/xpyufe6">[推荐] 你对天天挂在嘴边的高并发，怕是有什么误解吧？</a><br /><a href="https://toutiao.io/k/xuv7rlf">[推荐] 8 张图带你了解大型应用架构演进历程</a><br /><a href="https://toutiao.io/k/ga340bq">[推荐] MySQL 读写分离，写完读不到问题如何解决</a><br /><a href="https://toutiao.io/k/2n0entj">[推荐] 21 大软件架构特点的全面解析</a><br /><a href="https://toutiao.io/k/dux0ogl">[推荐] 这几款 JVM 故障诊断处理工具你还不会？</a><br /><hr /><a href="https://github.com/holo-gfx/mangadex"></a><br /><a href="https://github.com/login?return_to=%2Fmathiasbynens%2Fdotfiles">🔧 .files, including ~/.macos — sensible hacker defaults for macOS</a><br /><a href="https://github.com/DrKLO/Telegram">Telegram for Android source</a><br /><a href="https://github.com/521xueweihan/GitHub520">😘 让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。（无需安装软件）</a><br /><a href="https://github.com/cisagov/CHIRP">A forensic collection tool written in Python.</a><br /><a href="https://github.com/pointfreeco/swift-composable-architecture">A library for building applications in a consistent and understandable way, with composition, testing, and ergonomics in mind.</a><br /><a href="https://github.com/login?return_to=%2Fchatwoot%2Fchatwoot">Open-source customer engagement suite, an alternative to Intercom, Zendesk, Salesforce Service Cloud etc. 🔥💬</a><br /><a href="https://github.com/edeng23/binance-trade-bot">Automated cryptocurrency trading bot</a><br /><a href="https://github.com/ARKInvest/ARK-Invest-Tesla-Valuation-Model">An excerpt from our financial valuation model of Tesla</a><br /><a href="https://github.com/login?return_to=%2FLukeSmithxyz%2Fbased.cooking">A simple culinary website.</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/florinpop17/app-ideas">A Collection of application ideas which can be used to improve your coding skills.</a><br /><a href="https://github.com/adamschwartz/magic-of-css">A CSS course to turn you into a magician.</a><br /><a href="https://github.com/Defi-Cartel/salmonella">Wrecking sandwich traders for fun and profit</a><br /><a href="https://github.com/blazorhero/CleanArchitecture">Clean Architecture Template for Blazor WebAssembly Built with MudBlazor Components.</a><br /><a href="https://github.com/login?return_to=%2FDavidBuchanan314%2Ftweetable-polyglot-png">Pack up to 3MB of data into a tweetable PNG polyglot file.</a><br /><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</a><br /><a href="https://github.com/backstage/backstage">Backstage is an open platform for building developer portals</a><br /><a href="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">Kalman Filter book using Jupyter Notebook. Focuses on building intuition and experience, not formal proofs. Includes Kalman filters,extended Kalman filters, unscented Kalman filters, particle filters, and more. All exercises include solutions.</a><br /><a href="https://github.com/Overv/outrun">Execute a local command using the processing power of another Linux machine.</a><br /><a href="https://github.com/XTLS/Xray-core">Xray, Penetrates Everything. Also the best v2ray-core, with XTLS support. Fully compatible configuration.</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/kkoomen/qbr">A webcam-based 3x3x3 rubik's cube solver written in Python 3 and OpenCV.</a><br /><a href="https://github.com/openwrt/openwrt">This repository is a mirror of https://git.openwrt.org/openwrt/openwrt.git It is for reference only and is not active for check-ins or for reporting issues. We will continue to accept Pull Requests here. They will be merged via staging trees then into openwrt.git. All issues should be reported at: https://bugs.openwrt.org</a><br /><a href="https://github.com/Hari-Nagarajan/fairgame">Tool to help us buy hard to find items.</a><br /><hr />位1的个数<br /><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F" target="_blank">汉明重量</a>）。</p>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
	<li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284" target="_blank">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>00000000000000000000000000001011
<strong>输出：</strong>3
<strong>解释：</strong>输入的二进制串 <code><strong>00000000000000000000000000001011</strong> 中，共有三位为 '1'。</code>
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>00000000000000000000000010000000
<strong>输出：</strong>1
<strong>解释：</strong>输入的二进制串 <strong>00000000000000000000000010000000</strong> 中，共有一位为 '1'。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>11111111111111111111111111111101
<strong>输出：</strong>31
<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 31 位为 '1'。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>

<ul>
</ul>

<p> </p>

<p><strong>进阶</strong>：</p>

<ul>
	<li>如果多次调用这个函数，你将如何优化你的算法？</li>
</ul>
<br />#### 方法一：循环检查二进制位

**思路及解法**

我们可以直接循环检查给定整数 $n$ 的二进制位的每一位是否为 $1$。

具体代码中，当检查第 $i$ 位时，我们可以让 $n$ 与 $2^i$ 进行与运算，当且仅当 $n$ 的第 $i$ 位为 $1$ 时，运算结果不为 $0$。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                ret++;
            }
        }
        return ret;
    }
};
```

```Java [sol1-Java]
public class Solution {
    public int hammingWeight(int n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                ret++;
            }
        }
        return ret;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i)) 
        return ret
```

```go [sol1-Golang]
func hammingWeight(num uint32) (ones int) {
    for i := 0; i < 32; i++ {
        if 1<<i&num > 0 {
            ones++
        }
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var hammingWeight = function(n) {
    let ret = 0;
    for (let i = 0; i < 32; i++) {
        if ((n & (1 << i)) !== 0) {
            ret++;
        }
    }
    return ret;
};
```

```C [sol1-C]
int hammingWeight(uint32_t n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) {
        if (n & (1u << i)) {
            ret++;
        }
    }
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(k)$，其中 $k$ 是 $\texttt{int}$ 型的二进制位数，$k=32$。我们需要检查 $n$ 的二进制位的每一位，一共需要检查 $32$ 位。

- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。

#### 方法二：位运算优化

**思路及解法**

观察这个运算：$n~\&~(n - 1)$，其预算结果恰为把 $n$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

如：$6~\&~(6-1) = 4, 6 = (110)_2, 4 = (100)_2$，运算结果 $4$ 即为把 $6$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 $n$ 与 $n - 1$ 做与运算，直到 $n$ 变为 $0$ 即可。因为每次运算会使得 $n$ 的最低位的 $1$ 被翻转，因此运算次数就等于 $n$ 的二进制位中 $1$ 的个数。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};
```

```Java [sol2-Java]
public class Solution {
    public int hammingWeight(int n) {
        int ret = 0;
        while (n != 0) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
}
```

```Python [sol2-Python3]
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = 0
        while n:
            n &= n - 1
            ret += 1
        return ret
```

```go [sol2-Golang]
func hammingWeight(num uint32) (ones int) {
    for ; num > 0; num &= num - 1 {
        ones++
    }
    return
}
```

```JavaScript [sol2-JavaScript]
var hammingWeight = function(n) {
    let ret = 0;
    while (n) {
        n &= n - 1;
        ret++;
    }
    return ret;
};
```

```C [sol2-C]
int hammingWeight(uint32_t n) {
    int ret = 0;
    while (n) {
        n &= n - 1;
        ret++;
    }
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(\log n)$。循环次数等于 $n$ 的二进制位中 $1$ 的个数，最坏情况下 $n$ 的二进制位全部为 $1$。我们需要循环 $\log n$ 次。

- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。