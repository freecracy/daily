# 2021年03月27日 code
<a href="https://toutiao.io/k/ukg83qx">值得拥有的手绘风格画图工具</a><br /><a href="https://toutiao.io/k/adg4qv6">Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/9q7xgh3">漫画 Go 语言 Defer 机制及妙用</a><br /><a href="https://toutiao.io/k/7sfy943">不懂就问：ZooKeeper 集群如何进行数据同步？</a><br /><a href="https://toutiao.io/k/icrka3o">京东个性化推荐系统解析</a><br /><a href="https://toutiao.io/k/zgrp470">几乎刷完了力扣所有的二分题，我发现了这些东西（下）</a><br /><a href="https://toutiao.io/k/iju0qaz">漫话：如何给女朋友解释为什么 Java 里面的 String 对象是不可变的？</a><br /><a href="https://toutiao.io/k/lbl0dcp">第 046 期「码农周刊 VIP 会员专属邮件周报」今晚发送，请查收！</a><br /><a href="https://toutiao.io/k/le20s21">Synchronized 原理及锁升级分析</a><br /><a href="https://toutiao.io/k/vblur29">2021 Raft 实现细节</a><br /><a href="https://toutiao.io/k/ahb5tl0">ElasticSearch 聚合自定义排序</a><br /><a href="https://toutiao.io/k/6eipm5d">[译] 云原生：阿里巴巴的 Dapr 实践与探索</a><br /><a href="https://toutiao.io/k/y19x9mx">答读者问：为什么 Go 里面不能把任意切片转换为 []interface{} ？</a><br /><a href="https://toutiao.io/k/819kqs1">[译] 彻底掌握 Python 函数的 5 种参数</a><br /><a href="https://toutiao.io/k/ikikkes">个人角度阐述 OKR </a><br /><a href="https://toutiao.io/k/c7f5ftp">SQLAlchemy 1.4 异步特性真香</a><br /><a href="https://toutiao.io/k/kfavrus">一套 Flutter 混排瀑布流解决方案</a><br /><a href="https://toutiao.io/k/zwek0t9">该如何设计数仓的汇总层 (DWS)</a><br /><a href="https://toutiao.io/k/yo2lcsa">用 JS 解释 JS ！详解 AST 及其应用</a><br /><a href="https://toutiao.io/k/aqaom3o">实践之后，我们来谈谈如何做好威胁建模</a><br /><a href="https://toutiao.io/k/et0t2lk">[推荐] Go 工程化（九）：项目重构实践</a><br /><a href="https://toutiao.io/k/5apgnxp">[推荐] Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/lq6l2fa">[推荐] 加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/vhnnxpo">[推荐] Rhit：高效可视化 Nginx 日志查看工具，每秒处理百万行日志数据</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/ghs0i7r">[推荐] 不懂什么是云原生？看完这篇文章就够了！</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/gqpcukq">[推荐] TCP/IP 常见攻击手段</a><br /><a href="https://toutiao.io/k/av396i0">[推荐] Redis 教程：Redis 知识体系详解</a><br /><a href="https://toutiao.io/k/nvr0l12">[推荐] 权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><a href="https://toutiao.io/k/xpyufe6">[推荐] 你对天天挂在嘴边的高并发，怕是有什么误解吧？</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><hr /><a href="https://github.com/rms-support-letter/rms-support-letter.github.io">An open letter in support of Richard Matthew Stallman being reinstated by the Free Software Foundation</a><br /><a href="https://github.com/rails/rails">Ruby on Rails</a><br /><a href="https://github.com/ClearURLs/Addon">ClearURLs is an add-on based on the new WebExtensions technology and will automatically remove tracking elements from URLs to help protect your privacy.</a><br /><a href="https://github.com/alexgurr/react-coding-challenges">A series of ReactJS coding challenges with a variety of difficulties.</a><br /><a href="https://github.com/sveltejs/kit">A monorepo for SvelteKit and friends</a><br /><a href="https://github.com/ZENALC/algobot">Cryptocurrency trading bot with a graphical user interface.</a><br /><a href="https://github.com/rails/marcel">Find the mime type of files, examining file, filename and declared type</a><br /><a href="https://github.com/Uniswap/uniswap-v3-core">🦄 🦄 🦄 Core smart contracts of Uniswap v3</a><br /><a href="https://github.com/microsoft/playwright">Node.js library to automate Chromium, Firefox and WebKit with a single API</a><br /><a href="https://github.com/NAalytics/Assemblies-of-putative-SARS-CoV2-spike-encoding-mRNA-sequences-for-vaccines-BNT-162b2-and-mRNA-1273">RNA vaccines have become a key tool in moving forward through the challenges raised both in the current pandemic and in numerous other public health and medical challenges. With the rollout of vaccines for COVID-19, these synthetic mRNAs have become broadly distributed RNA species in numerous human populations. Despite their ubiquity, sequences …</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/rms-open-letter/rms-open-letter.github.io"></a><br /><a href="https://github.com/lucidrains/deep-daze">Simple command line tool for text to image generation using OpenAI's CLIP and Siren (Implicit neural representation network)</a><br /><a href="https://github.com/Daniel-Liu-c0deb0t/uwu">fastest text uwuifier in the west</a><br /><a href="https://github.com/appwrite/appwrite">Appwrite is a secure end-to-end backend server for Web, Mobile, and Flutter developers that is packaged as a set of Docker containers for easy deployment 🚀</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/geekcomputers/Python">My Python Examples</a><br /><a href="https://github.com/Kenzie-Academy-Brasil/portfolio-start-sua-carreira"></a><br /><a href="https://github.com/meng-chuan/Unlock-netease-cloud-music">解锁网易云音乐客户端变灰歌曲</a><br /><a href="https://github.com/Azure/azure-quickstart-templates">Azure Quickstart Templates</a><br /><a href="https://github.com/iPERDance/iPERCore">Liquid Warping GAN with Attention: A Unified Framework for Human Image Synthesis</a><br /><a href="https://github.com/mui-org/material-ui">Material-UI is a simple and customizable component library to build faster, beautiful, and more accessible React applications. Follow your own design system, or start with Material Design.</a><br /><a href="https://github.com/lux-org/lux">Python API for Intelligent Visual Data Discovery</a><br /><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</a><br /><a href="https://github.com/androidmalware/android_hid">Use Android as Rubber Ducky against another Android device</a><br /><hr />旋转链表<br /><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code><em> </em>个位置。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 600px; height: 254px;" />
<pre>
<strong>输入：</strong>head = [1,2,3,4,5], k = 2
<strong>输出：</strong>[4,5,1,2,3]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 472px; height: 542px;" />
<pre>
<strong>输入：</strong>head = [0,1,2], k = 4
<strong>输出：</strong>[2,0,1]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>
	<li><code>-100 <= Node.val <= 100</code></li>
	<li><code>0 <= k <= 2 * 10<sup>9</sup></code></li>
</ul>
<br />#### 方法一：闭合为环

**思路及算法**

记给定链表的长度为 $n$，注意到当向右移动的次数 $k \geq n$ 时，我们仅需要向右移动 $k \bmod n$ 次即可。因为每 $n$ 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 $(n - 1) - (k \bmod n)$ 个节点（从 $0$ 开始计数）。

这样，我们可以先将给定的链表连接成环，然后将指定位置断开。

具体代码中，我们首先计算出链表的长度 $n$，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 $(n - 1) - (k \bmod n)$ 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。

特别地，当链表长度不大于 $1$，或者 $k$ 为 $n$ 的倍数时，新链表将与原链表相同，我们无需进行任何处理。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (k == 0 || head == nullptr || head->next == nullptr) {
            return head;
        }
        int n = 1;
        ListNode* iter = head;
        while (iter->next != nullptr) {
            iter = iter->next;
            n++;
        }
        int add = n - k % n;
        if (add == n) {
            return head;
        }
        iter->next = head;
        while (add--) {
            iter = iter->next;
        }
        ListNode* ret = iter->next;
        iter->next = nullptr;
        return ret;
    }
};
```

```Java [sol1-Java]
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k == 0 || head == null || head.next == null) {
            return head;
        }
        int n = 1;
        ListNode iter = head;
        while (iter.next != null) {
            iter = iter.next;
            n++;
        }
        int add = n - k % n;
        if (add == n) {
            return head;
        }
        iter.next = head;
        while (add-- > 0) {
            iter = iter.next;
        }
        ListNode ret = iter.next;
        iter.next = null;
        return ret;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if k == 0 or not head or not head.next:
            return head
        
        n = 1
        cur = head
        while cur.next:
            cur = cur.next
            n += 1
        
        if (add := n - k % n) == n:
            return head
        
        cur.next = head
        while add:
            cur = cur.next
            add -= 1
        
        ret = cur.next
        cur.next = None
        return ret
```

```JavaScript [sol1-JavaScript]
var rotateRight = function(head, k) {
    if (k === 0 || !head || !head.next) {
        return head;
    }
    let n = 1;
    let cur = head;
    while (cur.next) {
        cur = cur.next;
        n++;
    }

    let add = n - k % n;
    if (add === n) {
        return head;
    }

    cur.next = head;
    while (add) {
        cur = cur.next;
        add--;
    }

    const ret = cur.next;
    cur.next = null;
    return ret;
};
```

```go [sol1-Golang]
func rotateRight(head *ListNode, k int) *ListNode {
    if k == 0 || head == nil || head.Next == nil {
        return head
    }
    n := 1
    iter := head
    for iter.Next != nil {
        iter = iter.Next
        n++
    }
    add := n - k%n
    if add == n {
        return head
    }
    iter.Next = head
    for add > 0 {
        iter = iter.Next
        add--
    }
    ret := iter.Next
    iter.Next = nil
    return ret
}
```

```C [sol1-C]
struct ListNode* rotateRight(struct ListNode* head, int k) {
    if (k == 0 || head == NULL || head->next == NULL) {
        return head;
    }
    int n = 1;
    struct ListNode* iter = head;
    while (iter->next != NULL) {
        iter = iter->next;
        n++;
    }
    int add = n - k % n;
    if (add == n) {
        return head;
    }
    iter->next = head;
    while (add--) {
        iter = iter->next;
    }
    struct ListNode* ret = iter->next;
    iter->next = NULL;
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，最坏情况下，我们需要遍历该链表两次。

- 空间复杂度：$O(1)$，我们只需要常数的空间存储若干变量。