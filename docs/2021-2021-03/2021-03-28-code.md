# 2021年03月28日 code
<a href="https://toutiao.io/k/ny7vvdw">万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/j77ejbu">Go 泛型尝鲜</a><br /><a href="https://toutiao.io/k/4f64ssc">GitHub 时断时续 Flutter 开发如何设置镜像</a><br /><a href="https://toutiao.io/k/2u8h9hg">浅谈 Vite 2.0 原理，依赖预编译，插件机制是如何兼容 Rollup 的？</a><br /><a href="https://toutiao.io/k/0o9r4q5">数据仓库为什么要有 ODS 层？</a><br /><a href="https://toutiao.io/k/6lglrtb">你可能并不懂 Apache Pulsar 的消息存储模型</a><br /><a href="https://toutiao.io/k/m10aa47">AI 入行那些事儿（六）：深度学习之神经网络</a><br /><a href="https://toutiao.io/k/k6f7crm">vivo 应用商店推荐系统探索与实践</a><br /><a href="https://toutiao.io/k/l50u2pi">使用开源工具进行 3D 数据可视化：使用 VTK 的教程</a><br /><a href="https://toutiao.io/k/xvw3q8v">Facebook 的人机交互技术：手部追踪、虚拟键盘、脑机接口……</a><br /><a href="https://toutiao.io/k/ghs0i7r">[推荐] 不懂什么是云原生？看完这篇文章就够了！</a><br /><a href="https://toutiao.io/k/lq6l2fa">[推荐] 加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/vhnnxpo">[推荐] Rhit：高效可视化 Nginx 日志查看工具，每秒处理百万行日志数据</a><br /><a href="https://toutiao.io/k/nvr0l12">[推荐] 权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/et0t2lk">[推荐] Go 工程化（九）：项目重构实践</a><br /><a href="https://toutiao.io/k/5apgnxp">[推荐] Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/xpyufe6">[推荐] 你对天天挂在嘴边的高并发，怕是有什么误解吧？</a><br /><hr /><a href="https://github.com/fogleman/physarum">Physarum polycephalum slime mold simulation</a><br /><a href="https://github.com/mimemagicrb/mimemagic">Mime type detection in ruby via file extension or file content</a><br /><a href="https://github.com/Ryujinx/Ryujinx">Experimental Nintendo Switch Emulator written in C#</a><br /><a href="https://github.com/alexgurr/react-coding-challenges">A series of ReactJS coding challenges with a variety of difficulties.</a><br /><a href="https://github.com/rms-support-letter/rms-support-letter.github.io">An open letter in support of Richard Matthew Stallman being reinstated by the Free Software Foundation</a><br /><a href="https://github.com/microsoft/calculator">Windows Calculator: A simple yet powerful calculator that ships with Windows</a><br /><a href="https://github.com/john-smilga/javascript-basic-projects"></a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/xelatihy/yocto-gl">Yocto/GL: Tiny C++ Libraries for Data-Driven Physically-based Graphics</a><br /><a href="https://github.com/Hammster/windows-terminal-shaders">(Hopefully) a small collection of terminal shaders</a><br /><a href="https://github.com/lydiahallie/javascript-questions">A long list of (advanced) JavaScript questions, and their explanations ✨</a><br /><a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite">PEASS - Privilege Escalation Awesome Scripts SUITE (with colors)</a><br /><a href="https://github.com/crypto-com/chain-desktop-wallet">Crypto.org Chain desktop wallet (Beta)</a><br /><a href="https://github.com/Kenzie-Academy-Brasil/portfolio-start-sua-carreira"></a><br /><a href="https://github.com/mentebinaria/retoolkit">Reverse Engineer's Toolkit</a><br /><a href="https://github.com/appwrite/appwrite">Appwrite is a secure end-to-end backend server for Web, Mobile, and Flutter developers that is packaged as a set of Docker containers for easy deployment 🚀</a><br /><a href="https://github.com/lucidrains/deep-daze">Simple command line tool for text to image generation using OpenAI's CLIP and Siren (Implicit neural representation network)</a><br /><a href="https://github.com/meng-chuan/Unlock-netease-cloud-music">解锁网易云音乐客户端变灰歌曲</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs such as http://ipstack.com, http://fixer.io/, https://numverify.com/, etc. for use in software and web development.</a><br /><a href="https://github.com/benawad/dogehouse">Taking voice conversations to the moon 🚀</a><br /><a href="https://github.com/storybookjs/storybook">📓 The UI component explorer. Develop, document, & test React, Vue, Angular, Web Components, Ember, Svelte & more!</a><br /><a href="https://github.com/magnologan/awesome-k8s-security">A curated list for Awesome Kubernetes Security resources</a><br /><a href="https://github.com/mui-org/material-ui">Material-UI is a simple and customizable component library to build faster, beautiful, and more accessible React applications. Follow your own design system, or start with Material Design.</a><br /><a href="https://github.com/davidbombal/red-python-scripts"></a><br /><a href="https://github.com/morpheusthewhite/spicetify-themes">A community-driven collection of themes for Spicetify (https://github.com/khanhas/spicetify-cli)</a><br /><hr />二叉搜索树迭代器<br />实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
<div class="original__bRMd">
<div>
<ul>
	<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
	<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>
	<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>
</ul>

<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>
</div>
</div>

<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>

<p> </p>

<p><strong>示例：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" style="width: 189px; height: 178px;" />
<pre>
<strong>输入</strong>
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>输出</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>解释</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>
	<li><code>0 <= Node.val <= 10<sup>6</sup></code></li>
	<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>
</ul>

<p> </p>

<p><strong>进阶：</strong></p>

<ul>
	<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>
</ul>
<br />#### 前言

根据二叉搜索树的性质，不难发现，原问题等价于对二叉搜索树进行中序遍历。因此，我们可以采取与「[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)」类似的方法来解决这一问题。

下面基于「[94. 二叉树的中序遍历的官方题解](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)」，给出本题的两种解法。读者将不难发现两篇题解的代码存在诸多相似之处。

#### 方法一：扁平化

我们可以直接对二叉搜索树做一次完全的递归遍历，获取中序遍历的全部结果并保存在数组中。随后，我们利用得到的数组本身来实现迭代器。

```C++ [sol1-C++]
class BSTIterator {
private:
    void inorder(TreeNode* root, vector<int>& res) {
        if (!root) {
            return;
        }
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
    
    vector<int> arr;
    int idx;
public:
    BSTIterator(TreeNode* root): idx(0), arr(inorderTraversal(root)) {}
    
    int next() {
        return arr[idx++];
    }
    
    bool hasNext() {
        return (idx < arr.size());
    }
};
```

```Java [sol1-Java]
class BSTIterator {
    private int idx;
    private List<Integer> arr;

    public BSTIterator(TreeNode root) {
        idx = 0;
        arr = new ArrayList<Integer>();
        inorderTraversal(root, arr);
    }

    public int next() {
        return arr.get(idx++);
    }

    public boolean hasNext() {
        return idx < arr.size();
    }

    private void inorderTraversal(TreeNode root, List<Integer> arr) {
        if (root == null) {
            return;
        }
        inorderTraversal(root.left, arr);
        arr.add(root.val);
        inorderTraversal(root.right, arr);
    }
}
```

```go [sol1-Golang]
type BSTIterator struct {
    arr []int
}

func Constructor(root *TreeNode) (it BSTIterator) {
    it.inorder(root)
    return
}

func (it *BSTIterator) inorder(node *TreeNode) {
    if node == nil {
        return
    }
    it.inorder(node.Left)
    it.arr = append(it.arr, node.Val)
    it.inorder(node.Right)
}

func (it *BSTIterator) Next() int {
    val := it.arr[0]
    it.arr = it.arr[1:]
    return val
}

func (it *BSTIterator) HasNext() bool {
    return len(it.arr) > 0
}
```

```JavaScript [sol1-JavaScript]
var BSTIterator = function(root) {
    this.idx = 0;
    this.arr = [];
    this.inorderTraversal(root, this.arr);
};

BSTIterator.prototype.next = function() {
    return this.arr[this.idx++];
};

BSTIterator.prototype.hasNext = function() {
    return this.idx < this.arr.length;
};

BSTIterator.prototype.inorderTraversal = function(root, arr) {
    if (!root) {
        return;
    }
    this.inorderTraversal(root.left, arr);
    arr.push(root.val);
    this.inorderTraversal(root.right, arr);
};
```

```C [sol1-C]
typedef struct {
    int* res;
    int size;
    int idx;
} BSTIterator;

int getTreeSize(struct TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    return 1 + getTreeSize(root->left) + getTreeSize(root->right);
}

void inorder(int* ret, int* retSize, struct TreeNode* root) {
    if (root == NULL) {
        return;
    }
    inorder(ret, retSize, root->left);
    ret[(*retSize)++] = root->val;
    inorder(ret, retSize, root->right);
}

int* inorderTraversal(int* retSize, struct TreeNode* root) {
    *retSize = 0;
    int* ret = malloc(sizeof(int) * getTreeSize(root));
    inorder(ret, retSize, root);
    return ret;
}

BSTIterator* bSTIteratorCreate(struct TreeNode* root) {
    BSTIterator* ret = malloc(sizeof(BSTIterator));
    ret->res = inorderTraversal(&(ret->size), root);
    ret->idx = 0;
    return ret;
}

int bSTIteratorNext(BSTIterator* obj) {
    return obj->res[(obj->idx)++];
}

bool bSTIteratorHasNext(BSTIterator* obj) {
    return (obj->idx < obj->size);
}

void bSTIteratorFree(BSTIterator* obj) {
    free(obj->res);
    free(obj);
}
```

**复杂度分析**

- 时间复杂度：初始化需要 $O(n)$ 的时间，其中 $n$ 为树中节点的数量。随后每次调用只需要 $O(1)$ 的时间。

- 空间复杂度：$O(n)$，因为需要保存中序遍历的全部结果。

#### 方法二：迭代

除了递归的方法外，我们还可以利用栈这一数据结构，通过迭代的方式对二叉树做中序遍历。此时，我们无需预先计算出中序遍历的全部结果，只需要实时维护当前栈的情况即可。

```C++ [sol2-C++]
class BSTIterator {
private:
    TreeNode* cur;
    stack<TreeNode*> stk;
public:
    BSTIterator(TreeNode* root): cur(root) {}
    
    int next() {
        while (cur != nullptr) {
            stk.push(cur);
            cur = cur->left;
        }
        cur = stk.top();
        stk.pop();
        int ret = cur->val;
        cur = cur->right;
        return ret;
    }
    
    bool hasNext() {
        return cur != nullptr || !stk.empty();
    }
};
```

```Java [sol2-Java]
class BSTIterator {
    private TreeNode cur;
    private Deque<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        cur = root;
        stack = new LinkedList<TreeNode>();
    }
    
    public int next() {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        int ret = cur.val;
        cur = cur.right;
        return ret;
    }
    
    public boolean hasNext() {
        return cur != null || !stack.isEmpty();
    }
}
```

```go [sol2-Golang]
type BSTIterator struct {
    stack []*TreeNode
    cur   *TreeNode
}

func Constructor(root *TreeNode) BSTIterator {
    return BSTIterator{cur: root}
}

func (it *BSTIterator) Next() int {
    for node := it.cur; node != nil; node = node.Left {
        it.stack = append(it.stack, node)
    }
    it.cur, it.stack = it.stack[len(it.stack)-1], it.stack[:len(it.stack)-1]
    val := it.cur.Val
    it.cur = it.cur.Right
    return val
}

func (it *BSTIterator) HasNext() bool {
    return it.cur != nil || len(it.stack) > 0
}
```

```JavaScript [sol2-JavaScript]
var BSTIterator = function(root) {
    this.cur = root;
    this.stack = [];
};

BSTIterator.prototype.next = function() {
    while (this.cur) {
        this.stack.push(this.cur);
        this.cur = this.cur.left;
    }
    this.cur = this.stack.pop();
    const ret = this.cur.val;
    this.cur = this.cur.right;
    return ret;
};

BSTIterator.prototype.hasNext = function() {
    return this.cur !== null || this.stack.length;
};
```

```C [sol2-C]
typedef struct {
    struct TreeNode* cur;
    struct StackTreeNode* stk[128];
    int stkSize;
} BSTIterator;

BSTIterator* bSTIteratorCreate(struct TreeNode* root) {
    BSTIterator* ret = malloc(sizeof(BSTIterator));
    ret->cur = root;
    ret->stkSize = 0;
    return ret;
}

int bSTIteratorNext(BSTIterator* obj) {
    while (obj->cur != NULL) {
        obj->stk[(obj->stkSize)++] = obj->cur;
        obj->cur = obj->cur->left;
    }
    obj->cur = obj->stk[--(obj->stkSize)];
    int ret = obj->cur->val;
    obj->cur = obj->cur->right;
    return ret;
}

bool bSTIteratorHasNext(BSTIterator* obj) {
    return obj->cur != NULL || obj->stkSize;
}

void bSTIteratorFree(BSTIterator* obj) {
    free(obj);
}
```

**复杂度分析**

- 时间复杂度：显然，初始化和调用 $\text{hasNext()}$ 都只需要 $O(1)$ 的时间。每次调用 $\text{next()}$ 函数**最坏情况下**需要 $O(n)$ 的时间；但考虑到 $n$ 次调用 $\text{next()}$ 函数总共会遍历全部的 $n$ 个节点，因此总的时间复杂度为 $O(n)$，因此单次调用平均下来的**均摊复杂度**为 $O(1)$。

- 空间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数量。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 $O(n)$ 的级别。