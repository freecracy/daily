# 2021年03月09日 code
<a href="https://toutiao.io/k/xuv7rlf">8 张图带你了解大型应用架构演进历程</a><br /><a href="https://toutiao.io/k/a595tmo">有赞 BI 平台设计及实现</a><br /><a href="https://toutiao.io/k/f7fdiw9">[译] Offer 薪资不如预期？你或许需要薪酬谈判服务</a><br /><a href="https://toutiao.io/k/febn4rp">终于讲清楚了：深入理解 Java 应用程序中 final 关键字的各种使用场景</a><br /><a href="https://toutiao.io/k/3j3kd2k">不用代码趣讲 ZooKeeper 集群</a><br /><a href="https://toutiao.io/k/zwp7jms">美团外卖特征平台的建设与实践</a><br /><a href="https://toutiao.io/k/8464zt2">HBase 架构及原理</a><br /><a href="https://toutiao.io/k/lxa0q4p">一个开源的服务器框架，特别适用于开发小游戏</a><br /><a href="https://toutiao.io/k/2uja06c">一次完整的源码阅读过程</a><br /><a href="https://toutiao.io/k/pev3zzj">​Python 如何仅用 5000 行代码，实现强大的 logging 模块？</a><br /><a href="https://toutiao.io/k/ijrpjrx">Netty 源码解析：零拷贝机制与 ByteBuf</a><br /><a href="https://toutiao.io/k/tnz13qb">Figma：跨平台 UI 设计工具</a><br /><a href="https://toutiao.io/k/7msedjb">WinMerge：一个免费开源的文件对比神器</a><br /><a href="https://toutiao.io/k/7twdtvt">进行架构设计要了解的几种思维方式</a><br /><a href="https://toutiao.io/k/h6qcdyf">如何构建系统优化成本，携程出海云原生实践</a><br /><a href="https://toutiao.io/k/v9n8i3p">你的内存对齐了吗</a><br /><a href="https://toutiao.io/k/mz6tg81">如何编写 C++ 20 协程 (Coroutines)</a><br /><a href="https://toutiao.io/k/7p6qxks">入门 Serverless：简介与实践</a><br /><a href="https://toutiao.io/k/i4ij6n4">我花了 5 小时死磕这个俄罗斯套娃信封问题</a><br /><a href="https://toutiao.io/k/tqukert">在主动要求涨工资这事上，不要学我</a><br /><a href="https://toutiao.io/k/jpow46x">[推荐] 最新互联网大厂职位薪资，快来对号入座吧</a><br /><a href="https://toutiao.io/k/xl63gz1">[推荐] 看完这篇文章，别再说不会 Redis 的高级特性了</a><br /><a href="https://toutiao.io/k/j7v5pee">[推荐] 国内有哪些顶级技术团队的博客值得推荐？</a><br /><a href="https://toutiao.io/k/tm4wyb0">[推荐] Redis 专题：深入解读哨兵模式</a><br /><a href="https://toutiao.io/k/rmckht1">[推荐] 硬核！漫画图解 HTTP 基础 + 面试题</a><br /><a href="https://toutiao.io/k/h2vf9va">[推荐] Linux 内存管理</a><br /><a href="https://toutiao.io/k/gheevc3">[推荐] ​程序员划水指南</a><br /><a href="https://toutiao.io/k/ix2e9ja">[推荐] 中高级前端须注意的 40 条移动端 H5 坑位指南（网易三年实践）</a><br /><a href="https://toutiao.io/k/jvd3wnb">[推荐] Java 实现大文件多线程下载，提速 30 倍！想学？我教你啊</a><br /><a href="https://toutiao.io/k/90116j8">[推荐] Redis 为什么变慢了？一文讲透如何排查 Redis 性能问题</a><br /><a href="https://toutiao.io/k/jfopywh">[推荐] Web 安全头号大敌 XSS 漏洞解决最佳实践</a><br /><a href="https://toutiao.io/k/kldrkzc">[推荐] Tomcat 性能调优应该注意什么？</a><br /><a href="https://toutiao.io/k/xxk05uj">[推荐] Spring Boot 异步调用</a><br /><a href="https://toutiao.io/k/x6ro69m">[推荐] 高并发系统的限流策略：漏桶和令牌桶（附源码剖析）</a><br /><a href="https://toutiao.io/k/r9tqaw3">[推荐] 副业刚需：在 GitHub 上也能年入百万？</a><br /><hr /><a href="https://github.com/dolthub/dolt">Dolt – It's Git for Data</a><br /><a href="https://github.com/sherlock-project/sherlock">🔎 Hunt down social media accounts by username across social networks</a><br /><a href="https://github.com/nushell/nushell">A new type of shell</a><br /><a href="https://github.com/getzola/zola">A fast static site generator in a single binary with everything built-in. https://www.getzola.org</a><br /><a href="https://github.com/SerenityOS/serenity">The Serenity Operating System 🐞</a><br /><a href="https://github.com/openai/CLIP">Contrastive Language-Image Pretraining</a><br /><a href="https://github.com/nasa/fprime">F' - A flight software and embedded systems framework</a><br /><a href="https://github.com/login?return_to=%2Fziglang%2Fzig">General-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.</a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/microsoft/CSS-Exchange">Exchange Server support tools and scripts</a><br /><a href="https://github.com/josephmisiti/awesome-machine-learning">A curated list of awesome Machine Learning frameworks, libraries and software.</a><br /><a href="https://github.com/thunlp/GNNPapers">Must-read papers on graph neural networks (GNN)</a><br /><a href="https://github.com/threat9/routersploit">Exploitation Framework for Embedded Devices</a><br /><a href="https://github.com/visenger/awesome-mlops">A curated list of references for MLOps</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/qmk/qmk_firmware">Open-source keyboard firmware for Atmel AVR and Arm USB families</a><br /><a href="https://github.com/brillout/awesome-react-components">Curated List of React Components & Libraries.</a><br /><a href="https://github.com/torvalds/linux">Linux kernel source tree</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/nodegui/react-nodegui">Build performant, native and cross-platform desktop applications with native React + powerful CSS like styling.🚀</a><br /><a href="https://github.com/diasurgical/devilutionX">Diablo build for modern operating systems</a><br /><a href="https://github.com/projectdiscovery/nuclei-templates">Community curated list of templates for the nuclei engine to find a security vulnerability in the application.</a><br /><a href="https://github.com/abuanwar072/Chat-Messaging-App-Light-and-Dark-Theme"></a><br /><a href="https://github.com/monero-project/monero">Monero: the secure, private, untraceable cryptocurrency</a><br /><a href="https://github.com/ageron/handson-ml2">A series of Jupyter notebooks that walk you through the fundamentals of Machine Learning and Deep Learning in Python using Scikit-Learn, Keras and TensorFlow 2.</a><br /><hr />删除字符串中的所有相邻重复项<br /><p>给出由小写字母组成的字符串&nbsp;<code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>

<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>

<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre><strong>输入：</strong>&quot;abbaca&quot;
<strong>输出：</strong>&quot;ca&quot;
<strong>解释：</strong>
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li><code>1 &lt;= S.length &lt;= 20000</code></li>
	<li><code>S</code> 仅由小写英文字母组成。</li>
</ol>
<br />#### 方法一：栈

充分理解题意后，我们可以发现，当字符串中同时有多组相邻重复项时，我们无论是先删除哪一个，都不会影响最终的结果。因此我们可以从左向右顺次处理该字符串。

而消除一对相邻重复项可能会导致新的相邻重复项出现，如从字符串 $\text{abba}$ 中删除 $\text{bb}$ 会导致出现新的相邻重复项 $\text{aa}$ 出现。因此我们需要保存当前还未被删除的字符。一种显而易见的数据结构呼之欲出：栈。我们只需要遍历该字符串，如果当前字符和栈顶字符相同，我们就贪心地将其消去，否则就将其入栈即可。

**代码**

在下面的 $\texttt{C++}$ 代码中，由于 $\texttt{std::string}$ 类本身就提供了类似「入栈」和「出栈」的接口，因此我们直接将需要被返回的字符串作为栈即可。对于其他的语言，如果字符串类没有提供相应的接口，则需要在遍历完成字符串后，使用栈中的字符显式地构造出需要被返回的字符串。

```C++ [sol1-C++]
class Solution {
public:
    string removeDuplicates(string S) {
        string stk;
        for (char ch : S) {
            if (!stk.empty() && stk.back() == ch) {
                stk.pop_back();
            } else {
                stk.push_back(ch);
            }
        }
        return stk;
    }
};
```

```Java [sol1-Java]
class Solution {
    public String removeDuplicates(String S) {
        StringBuffer stack = new StringBuffer();
        int top = -1;
        for (int i = 0; i < S.length(); ++i) {
            char ch = S.charAt(i);
            if (top >= 0 && stack.charAt(top) == ch) {
                stack.deleteCharAt(top);
                --top;
            } else {
                stack.append(ch);
                ++top;
            }
        }
        return stack.toString();
    }
}
```

```JavaScript [sol1-JavaScript]
var removeDuplicates = function(S) {
    const stk = [];
    for (const ch of S) {
        if (stk.length && stk[stk.length - 1] === ch) {
            stk.pop();
        } else {
            stk.push(ch);
        }
    }
    return stk.join('');
};
```

```Python [sol1-Python3]
class Solution:
    def removeDuplicates(self, S: str) -> str:
        stk = list()
        for ch in S:
            if stk and stk[-1] == ch:
                stk.pop()
            else:
                stk.append(ch)
        return "".join(stk)
```

```go [sol1-Golang]
func removeDuplicates(s string) string {
    stack := []byte{}
    for i := range s {
        if len(stack) > 0 && stack[len(stack)-1] == s[i] {
            stack = stack[:len(stack)-1]
        } else {
            stack = append(stack, s[i])
        }
    }
    return string(stack)
}
```

```C [sol1-C]
char* removeDuplicates(char* S) {
    int n = strlen(S);
    char* stk = malloc(sizeof(char) * (n + 1));
    int retSize = 0;
    for (int i = 0; i < n; i++) {
        if (retSize > 0 && stk[retSize - 1] == S[i]) {
            retSize--;
        } else {
            stk[retSize++] = S[i];
        }
    }
    stk[retSize] = '\0';
    return stk;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是字符串的长度。我们只需要遍历该字符串一次。

- 空间复杂度：$O(n)$ 或 $O(1)$，取决于使用的语言提供的字符串类是否提供了类似「入栈」和「出栈」的接口。注意返回值不计入空间复杂度。