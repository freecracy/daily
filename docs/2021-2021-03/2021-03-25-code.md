# 2021年03月25日 code
<a href="https://toutiao.io/k/4yqc5t5">资料 | 英语进阶指南</a><br /><a href="https://toutiao.io/k/ubsth9i">优质网站同好者周刊（第 5 期）</a><br /><a href="https://toutiao.io/k/exd77nu">卧槽，线上数据删错了，差点被老板开除</a><br /><a href="https://toutiao.io/k/vulmd0h">浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/ajk71ed">写给开发人员的实用密码学：非对称加密算法</a><br /><a href="https://toutiao.io/k/fhks4c3">Java 线程的那些状态们</a><br /><a href="https://toutiao.io/k/inp5dpc">详解低延时高音质：声音的美化与空间音效篇</a><br /><a href="https://toutiao.io/k/5reyhwy">优雅停机之主动从 Nacos 下线实例</a><br /><a href="https://toutiao.io/k/gm348vn">高性能服务之优雅终止</a><br /><a href="https://toutiao.io/k/82gvxkh">白话讲解，拜占庭将军问题</a><br /><a href="https://toutiao.io/k/6h32ko4">黑科技：基于 Arduino 和 Zabbix 实现温湿度监控告警</a><br /><a href="https://toutiao.io/k/z58kt8e">Canal 高可用架构部署</a><br /><a href="https://toutiao.io/k/ff1sw3m">Rust 异步库：Tokio 的一些资源限制</a><br /><a href="https://toutiao.io/k/1wxmmcs">Spring Cloud 2020：Hystrix 不生效怪我咯</a><br /><a href="https://toutiao.io/k/39cgzvi">美团优选大数据开发岗面试真题（附答案详细解析）</a><br /><a href="https://toutiao.io/k/nib2cpr">问题排查：客户端突如其来的 “白屏” 等待</a><br /><a href="https://toutiao.io/k/w0frawj">本地 Docker 安装 Postgres 12 + pgadmin （支持 Apple M1)</a><br /><a href="https://toutiao.io/k/q5hkkby">动手造轮子：实现一个简单的基于 Console 的日志输出</a><br /><a href="https://toutiao.io/k/i0bzw8q">Kyuubi 与 Spark Thrift Server 的全面对比分析</a><br /><a href="https://toutiao.io/k/dkeq4ff">中标麒麟系统 Ansible 执行 yum 模块报错的问题分析</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/mzszqf0">[推荐] 谈谈 Git 存储原理及相关实现</a><br /><a href="https://toutiao.io/k/e3lq37o">[推荐] 2021 有哪些不容错过的后端技术趋势</a><br /><a href="https://toutiao.io/k/gqpcukq">[推荐] TCP/IP 常见攻击手段</a><br /><a href="https://toutiao.io/k/vzx2ky5">[推荐] 吃透 MQ</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/pmxukkm">[推荐] 面试被吊打：Redis 原理</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><a href="https://toutiao.io/k/av396i0">[推荐] Redis 教程：Redis 知识体系详解</a><br /><a href="https://toutiao.io/k/2n0entj">[推荐] 21 大软件架构特点的全面解析</a><br /><a href="https://toutiao.io/k/et0t2lk">[推荐] Go 工程化（九）：项目重构实践</a><br /><a href="https://toutiao.io/k/xpyufe6">[推荐] 你对天天挂在嘴边的高并发，怕是有什么误解吧？</a><br /><a href="https://toutiao.io/k/5apgnxp">[推荐] Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><hr /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/geekcomputers/Python">My Python Examples</a><br /><a href="https://github.com/ahmedbahaaeldin/From-0-to-Research-Scientist-resources-guide">Detailed and tailored guide for undergraduate students or anybody want to dig deep into the field of AI with solid foundation.</a><br /><a href="https://github.com/hasherezade/malware_training_vol1">Materials for Windows Malware Analysis training (volume 1)</a><br /><a href="https://github.com/papercups-io/papercups">Open-source live customer chat</a><br /><a href="https://github.com/iPERDance/iPERCore">Liquid Warping GAN with Attention: A Unified Framework for Human Image Synthesis</a><br /><a href="https://github.com/globalaihub/introduction-to-machine-learning"></a><br /><a href="https://github.com/ZENALC/algobot">Cryptocurrency trading bot with a graphical user interface.</a><br /><a href="https://github.com/docmirror/dev-sidecar">开发者边车，github打不开，github加速，git clone加速，git release下载加速，stackoverflow加速</a><br /><a href="https://github.com/EleutherAI/gpt-neo">An implementation of model parallel GPT2& GPT3-like models, with the ability to scale up to full GPT3 sizes (and possibly more!), using the mesh-tensorflow library.</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/crystal-lang/crystal">The Crystal Programming Language</a><br /><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</a><br /><a href="https://github.com/livewire/livewire">A full-stack framework for Laravel that takes the pain out of building dynamic UIs.</a><br /><a href="https://github.com/jesse-ai/jesse">An advanced crypto trading bot written in Python</a><br /><a href="https://github.com/edeng23/binance-trade-bot">Automated cryptocurrency trading bot</a><br /><a href="https://github.com/lux-org/lux">Python API for Intelligent Visual Data Discovery</a><br /><a href="https://github.com/appwrite/appwrite">Appwrite is a secure end-to-end backend server for Web, Mobile, and Flutter developers that is packaged as a set of Docker containers for easy deployment 🚀</a><br /><a href="https://github.com/Helsinki-NLP/Tatoeba-Challenge"></a><br /><a href="https://github.com/HolyBugx/HolyTips">Tips and Tutorials on Bug Bounty Hunting and Web App Security.</a><br /><a href="https://github.com/ShapeAI/PYTHON-AND-DATA-ANALYTICS-7-DAYS"></a><br /><a href="https://github.com/facebookresearch/barlowtwins">PyTorch implementation of Barlow Twins.</a><br /><a href="https://github.com/facebook/react">A declarative, efficient, and flexible JavaScript library for building user interfaces.</a><br /><a href="https://github.com/safemoonprotocol/Safemoon.sol">safemoon contract</a><br /><hr />删除排序链表中的重复元素 II<br /><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中&nbsp;<em>没有重复出现&nbsp;</em>的数字。</p>

<p><strong>示例&nbsp;1:</strong></p>

<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
<strong>输出:</strong> 1-&gt;2-&gt;5
</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3
<strong>输出:</strong> 2-&gt;3</pre>
<br />#### 方法一：一次遍历

**思路与算法**

由于给定的链表是排好序的，因此**重复的元素在链表中出现的位置是连续的**，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。

具体地，我们从指针 $\textit{cur}$ 指向链表的哑节点，随后开始对链表进行遍历。如果当前 $\textit{cur.next}$ 与 $\textit{cur.next.next}$ 对应的元素相同，那么我们就需要将 $\textit{cur.next}$ 以及所有后面拥有相同元素值的链表节点全部删除。我们记下这个元素值 $x$，随后不断将 $\textit{cur.next}$ 从链表中移除，直到 $\textit{cur.next}$ 为空节点或者其元素值不等于 $x$ 为止。此时，我们将链表中所有元素值为 $x$ 的节点全部删除。

如果当前 $\textit{cur.next}$ 与 $\textit{cur.next.next}$ 对应的元素不相同，那么说明链表中只有一个元素值为 $\textit{cur.next}$ 的节点，那么我们就可以将 $\textit{cur}$ 指向 $\textit{cur.next}$。

当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 $\textit{dummy.next}$ 即可。

**细节**

需要注意 $\textit{cur.next}$ 以及 $\textit{cur.next.next}$ 可能为空节点，如果不加以判断，可能会产生运行错误。

**代码**

注意下面 $\texttt{C++}$ 代码中并没有释放被删除的链表节点以及哑节点的空间。如果在面试中遇到本题，读者需要针对这一细节与面试官进行沟通。

```C++ [sol1-C++]
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) {
            return head;
        }
        
        ListNode* dummy = new ListNode(0, head);

        ListNode* cur = dummy;
        while (cur->next && cur->next->next) {
            if (cur->next->val == cur->next->next->val) {
                int x = cur->next->val;
                while (cur->next && cur->next->val == x) {
                    cur->next = cur->next->next;
                }
            }
            else {
                cur = cur->next;
            }
        }

        return dummy->next;
    }
};
```

```Java [sol1-Java]
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        
        ListNode dummy = new ListNode(0, head);

        ListNode cur = dummy;
        while (cur.next != null && cur.next.next != null) {
            if (cur.next.val == cur.next.next.val) {
                int x = cur.next.val;
                while (cur.next != null && cur.next.val == x) {
                    cur.next = cur.next.next;
                }
            } else {
                cur = cur.next;
            }
        }

        return dummy.next;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        dummy = ListNode(0, head)

        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur = cur.next

        return dummy.next
```

```JavaScript [sol1-JavaScript]
var deleteDuplicates = function(head) {
    if (!head) {
        return head;
    }

    const dummy = new ListNode(0, head);

    let cur = dummy;
    while (cur.next && cur.next.next) {
        if (cur.next.val === cur.next.next.val) {
            const x = cur.next.val;
            while (cur.next && cur.next.val === x) {
                cur.next = cur.next.next;
            } 
        } else {
            cur = cur.next;
        }
    }
    return dummy.next;
};
```

```go [sol1-Golang]
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }

    dummy := &ListNode{0, head}

    cur := dummy
    for cur.Next != nil && cur.Next.Next != nil {
        if cur.Next.Val == cur.Next.Next.Val {
            x := cur.Next.Val
            for cur.Next != nil && cur.Next.Val == x {
                cur.Next = cur.Next.Next
            }
        } else {
            cur = cur.Next
        }
    }

    return dummy.Next
}
```

```C [sol1-C]
struct ListNode* deleteDuplicates(struct ListNode* head) {
    if (!head) {
        return head;
    }

    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;

    struct ListNode* cur = dummy;
    while (cur->next && cur->next->next) {
        if (cur->next->val == cur->next->next->val) {
            int x = cur->next->val;
            while (cur->next && cur->next->val == x) {
                cur->next = cur->next->next;
            }
        } else {
            cur = cur->next;
        }
    }

    return dummy->next;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是链表的长度。

- 空间复杂度：$O(1)$。