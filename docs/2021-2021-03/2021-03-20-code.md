# 2021年03月20日 code
<a href="https://toutiao.io/k/lq6l2fa">加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/j2jmmcf">如何优雅的让 3 个线程打印 ABC</a><br /><a href="https://toutiao.io/k/nvr0l12">权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/7aczn5o">面试官常问的垃圾回收器，这次全搞懂</a><br /><a href="https://toutiao.io/k/tpejrbn">数仓已死？数据湖当立</a><br /><a href="https://toutiao.io/k/le19zdx">万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/eed1x1z">详解低延时高音质：丢包、抖动与 last mile 优化那些事儿</a><br /><a href="https://toutiao.io/k/3mzv763">都 2021 年了，你还在计划转 Go 语言么？</a><br /><a href="https://toutiao.io/k/qttc0th">怎么推导出《115. 不同的子序列》的动态规划解法</a><br /><a href="https://toutiao.io/k/9pxzn48">[译] Apache Pulsar 集群如何确保消息不丢</a><br /><a href="https://toutiao.io/k/xx5bo1v">深入 JVM 去剖析 Synchronized </a><br /><a href="https://toutiao.io/k/hzhqiaw">C/C++ 性能优化背后的方法论：TMAM</a><br /><a href="https://toutiao.io/k/8jczbp9">Flutter Web 在美团外卖的实践</a><br /><a href="https://toutiao.io/k/al9ejli">Python 基础巩固：位运算的奥妙</a><br /><a href="https://toutiao.io/k/qlibow2">弃繁就简！一行代码搞定 Python 日志</a><br /><a href="https://toutiao.io/k/49joufi">在 C# 中使用 CancellationToken 处理异步任务</a><br /><a href="https://toutiao.io/k/knkfeqe">算法工程师的自我修养</a><br /><a href="https://toutiao.io/k/wb8ic3q">任务运维和数据指标相关的使用</a><br /><a href="https://toutiao.io/k/t4tylre">知识图谱上的图神经网络</a><br /><a href="https://toutiao.io/k/ac00xix">路漫漫其修远兮，吾将上下而求 “锁”​</a><br /><a href="https://toutiao.io/k/mzszqf0">[推荐] 谈谈 Git 存储原理及相关实现</a><br /><a href="https://toutiao.io/k/qh7wgrx">[推荐] 去哪里找 Java 练手项目？</a><br /><a href="https://toutiao.io/k/ga340bq">[推荐] MySQL 读写分离，写完读不到问题如何解决</a><br /><a href="https://toutiao.io/k/pmxukkm">[推荐] 面试被吊打：Redis 原理</a><br /><a href="https://toutiao.io/k/dux0ogl">[推荐] 这几款 JVM 故障诊断处理工具你还不会？</a><br /><a href="https://toutiao.io/k/r5kgujp">[推荐] 从技术专家到技术管理，我对管理的思考</a><br /><a href="https://toutiao.io/k/tgp1ua8">[推荐] 面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</a><br /><a href="https://toutiao.io/k/0ic2o68">[推荐] 带你深入理解 Java 内存模型理论</a><br /><a href="https://toutiao.io/k/e3lq37o">[推荐] 2021 有哪些不容错过的后端技术趋势</a><br /><a href="https://toutiao.io/k/a595tmo">[推荐] 有赞 BI 平台设计及实现</a><br /><a href="https://toutiao.io/k/av396i0">[推荐] Redis 教程：Redis 知识体系详解</a><br /><a href="https://toutiao.io/k/671eano">[推荐] 快手超大规模集群调度优化实践</a><br /><a href="https://toutiao.io/k/xpyufe6">[推荐] 你对天天挂在嘴边的高并发，怕是有什么误解吧？</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/ghs0i7r">[推荐] 不懂什么是云原生？看完这篇文章就够了！</a><br /><hr /><a href="https://github.com/pointfreeco/isowords">Open source game built in SwiftUI and the Composable Architecture.</a><br /><a href="https://github.com/openai/DALL-E">PyTorch package for the discrete VAE used for DALL·E.</a><br /><a href="https://github.com/login?return_to=%2FDavidBuchanan314%2Ftweetable-polyglot-png">Pack up to 3MB of data into a tweetable PNG polyglot file.</a><br /><a href="https://github.com/pointfreeco/swift-composable-architecture">A library for building applications in a consistent and understandable way, with composition, testing, and ergonomics in mind.</a><br /><a href="https://github.com/3b1b/manim">Animation engine for explanatory math videos</a><br /><a href="https://github.com/ChartsCSS/charts.css">Open source CSS framework for data visualization.</a><br /><a href="https://github.com/login?return_to=%2Fchatwoot%2Fchatwoot">Open-source customer engagement suite, an alternative to Intercom, Zendesk, Salesforce Service Cloud etc. 🔥💬</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/paulgp/applied-methods-phd">Repo for Yale Applied Empirical Methods PHD Course</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/simo8102/88-AutoSignMachine">联通挂机任务积分脚本</a><br /><a href="https://github.com/grafana/grafana">The open and composable observability and data visualization platform. Visualize metrics, logs, and traces from multiple sources like Prometheus, Loki, Elasticsearch, InfluxDB, Postgres and many more.</a><br /><a href="https://github.com/stefan-jansen/machine-learning-for-trading">Code for Machine Learning for Algorithmic Trading, 2nd edition.</a><br /><a href="https://github.com/backstage/backstage">Backstage is an open platform for building developer portals</a><br /><a href="https://github.com/521xueweihan/GitHub520">😘 让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/florinpop17/app-ideas">A Collection of application ideas which can be used to improve your coding skills.</a><br /><a href="https://github.com/MicrosoftLearning/DA-100-Analyzing-Data-with-Power-BI"></a><br /><a href="https://github.com/cypress-io/cypress">Fast, easy and reliable testing for anything that runs in a browser.</a><br /><a href="https://github.com/facebook/react-native">A framework for building native apps with React.</a><br /><a href="https://github.com/github/roadmap">GitHub public roadmap</a><br /><a href="https://github.com/lucidrains/big-sleep">A simple command line tool for text to image generation, using OpenAI's CLIP and a BigGAN</a><br /><a href="https://github.com/sudheerj/reactjs-interview-questions">List of top 500 ReactJS Interview Questions & Answers....Coding exercise questions are coming soon!!</a><br /><a href="https://github.com/input-output-hk/cardano-node">The core component that is used to participate in a Cardano decentralised blockchain.</a><br /><a href="https://github.com/TheAlgorithms/C">Collection of various algorithms in mathematics, machine learning, computer science, physics, etc implemented in C for educational purposes.</a><br /><hr />逆波兰表达式求值<br /><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank"> 逆波兰表示法</a>，求表达式的值。</p>

<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>

<p> </p>

<p><strong>说明：</strong></p>

<ul>
	<li>整数除法只保留整数部分。</li>
	<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>tokens = ["2","1","+","3","*"]
<strong>输出：</strong>9
<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>tokens = ["4","13","5","/","+"]
<strong>输出：</strong>6
<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
<strong>输出：</strong>22
<strong>解释：</strong>
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= tokens.length <= 10<sup>4</sup></code></li>
	<li><code>tokens[i]</code> 要么是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li>
</ul>

<p> </p>

<p><strong>逆波兰表达式：</strong></p>

<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>

<ul>
	<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
	<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>

<p>逆波兰表达式主要有以下两个优点：</p>

<ul>
	<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
	<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<br />#### 前言

逆波兰表达式由波兰的逻辑学家卢卡西维兹提出。逆波兰表达式的特点是：没有括号，运算符总是放在和它相关的操作数之后。因此，逆波兰表达式也称后缀表达式。

#### 方法一：栈

逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：

- 如果遇到操作数，则将操作数入栈；

- 如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。

整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。

<![ppt1](https://assets.leetcode-cn.com/solution-static/150/p1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/150/p2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/150/p3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/150/p4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/150/p5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/150/p6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/150/p7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/150/p8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/150/p9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/150/p10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/150/p11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/150/p12.png),![ppt13](https://assets.leetcode-cn.com/solution-static/150/p13.png),![ppt14](https://assets.leetcode-cn.com/solution-static/150/p14.png),![ppt15](https://assets.leetcode-cn.com/solution-static/150/p15.png)>

```Java [sol1-Java]
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = tokens.length;
        for (int i = 0; i < n; i++) {
            String token = tokens[i];
            if (isNumber(token)) {
                stack.push(Integer.parseInt(token));
            } else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (token) {
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":
                        stack.push(num1 / num2);
                        break;
                    default:
                }
            }
        }
        return stack.pop();
    }

    public boolean isNumber(String token) {
        return !("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token));
    }
}
```

```JavaScript [sol1-JavaScript]
var evalRPN = function(tokens) {
    const stack = [];
    const n = tokens.length;
    for (let i = 0; i < n; i++) {
        const token = tokens[i];
        if (isNumber(token)) {
            stack.push(parseInt(token));
        } else {
            const num2 = stack.pop();
            const num1 = stack.pop();
            if (token === '+') {
                stack.push(num1 + num2);
            } else if (token === '-') {
                stack.push(num1 - num2);
            } else if (token === '*') {
                stack.push(num1 * num2);
            } else if (token === '/') {
                stack.push(num1 / num2 > 0 ? Math.floor(num1 / num2) : Math.ceil(num1 / num2));
            }
        }
    }
    return stack.pop();
};

const isNumber = (token) => {
    return !('+' === token || '-' === token || '*' === token || '/' === token );
}
```

```go [sol1-Golang]
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        val, err := strconv.Atoi(token)
        if err == nil {
            stack = append(stack, val)
        } else {
            num1, num2 := stack[len(stack)-2], stack[len(stack)-1]
            stack = stack[:len(stack)-2]
            switch token {
            case "+":
                stack = append(stack, num1+num2)
            case "-":
                stack = append(stack, num1-num2)
            case "*":
                stack = append(stack, num1*num2)
            default:
                stack = append(stack, num1/num2)
            }
        }
    }
    return stack[0]
}
```

```Python [sol1-Python3]
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        op_to_binary_fn = {
            "+": add,
            "-": sub,
            "*": mul,
            "/": lambda x, y: int(x / y),   # 需要注意 python 中负数除法的表现与题目不一致
        }

        stack = list()
        for token in tokens:
            try:
                num = int(token)
            except ValueError:
                num2 = stack.pop()
                num1 = stack.pop()
                num = op_to_binary_fn[token](num1, num2)
            finally:
                stack.append(num)
            
        return stack[0]
```

```C++ [sol1-C++]
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        int n = tokens.size();
        for (int i = 0; i < n; i++) {
            string& token = tokens[i];
            if (isNumber(token)) {
                stk.push(atoi(token.c_str()));
            } else {
                int num2 = stk.top();
                stk.pop();
                int num1 = stk.top();
                stk.pop();
                switch (token[0]) {
                    case '+':
                        stk.push(num1 + num2);
                        break;
                    case '-':
                        stk.push(num1 - num2);
                        break;
                    case '*':
                        stk.push(num1 * num2);
                        break;
                    case '/':
                        stk.push(num1 / num2);
                        break;
                }
            }
        }
        return stk.top();
    }

    bool isNumber(string& token) {
        return !(token == "+" || token == "-" || token == "*" || token == "/");
    }
};
```

```C [sol1-C]
bool isNumber(char* token) {
    return strlen(token) > 1 || ('0' <= token[0] && token[0] <= '9');
}

int evalRPN(char** tokens, int tokensSize) {
    int n = tokensSize;
    int stk[n], top = 0;
    for (int i = 0; i < n; i++) {
        char* token = tokens[i];
        if (isNumber(token)) {
            stk[top++] = atoi(token);
        } else {
            int num2 = stk[--top];
            int num1 = stk[--top];
            switch (token[0]) {
                case '+':
                    stk[top++] = num1 + num2;
                    break;
                case '-':
                    stk[top++] = num1 - num2;
                    break;
                case '*':
                    stk[top++] = num1 * num2;
                    break;
                case '/':
                    stk[top++] = num1 / num2;
                    break;
            }
        }
    }
    return stk[top - 1];
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{tokens}$ 的长度。需要遍历数组 $\textit{tokens}$ 一次，计算逆波兰表达式的值。

- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{tokens}$ 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。

#### 方法二：数组模拟栈

方法一使用栈存储操作数。也可以使用一个数组模拟栈操作。

如果使用数组代替栈，则需要预先定义数组的长度。对于长度为 $n$ 的逆波兰表达式，显然栈内元素个数不会超过 $n$，但是将数组的长度定义为 $n$ 仍然超过了栈内元素个数的上界。那么，栈内元素最多可能有多少个？

对于一个有效的逆波兰表达式，其长度 $n$ 一定是奇数，且操作数的个数一定比运算符的个数多 $1$ 个，即包含 $\frac{n+1}{2}$ 个操作数和 $\frac{n-1}{2}$ 个运算符。考虑遇到操作数和运算符时，栈内元素个数分别会如何变化：

- 如果遇到操作数，则将操作数入栈，因此栈内元素增加 $1$ 个；

- 如果遇到运算符，则将两个操作数出栈，然后将一个新操作数入栈，因此栈内元素先减少 $2$ 个再增加 $1$ 个，结果是栈内元素减少 $1$ 个。

由此可以得到操作数和运算符与栈内元素个数变化的关系：遇到操作数时，栈内元素增加 $1$ 个；遇到运算符时，栈内元素减少 $1$ 个。

最坏情况下，$\frac{n+1}{2}$ 个操作数都在表达式的前面，$\frac{n-1}{2}$ 个运算符都在表达式的后面，此时栈内元素最多为 $\frac{n+1}{2}$ 个。在其余情况下，栈内元素总是少于 $\frac{n+1}{2}$ 个。因此，在任何情况下，栈内元素最多可能有 $\frac{n+1}{2}$ 个，将数组的长度定义为 $\frac{n+1}{2}$ 即可。

具体实现方面，创建数组 $\textit{stack}$ 模拟栈，数组下标 $0$ 的位置对应栈底，定义 $\textit{index}$ 表示栈顶元素的下标位置，初始时栈为空，$\textit{index}=-1$。当遇到操作数和运算符时，进行如下操作：

- 如果遇到操作数，则将 $\textit{index}$ 的值加 $1$，然后将操作数赋给 $\textit{stack}[\textit{index}]$；

- 如果遇到运算符，则将 $\textit{index}$ 的值减 $1$，此时 $\textit{stack}[\textit{index}]$ 和 $\textit{stack}[\textit{index}+1]$ 的元素分别是左操作数和右操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数赋给 $\textit{stack}[\textit{index}]$。

整个逆波兰表达式遍历完毕之后，栈内只有一个元素，因此 $\textit{index}=0$，此时 $\textit{stack}[\textit{index}]$ 即为逆波兰表达式的值。

<![ppt1](https://assets.leetcode-cn.com/solution-static/150/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/150/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/150/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/150/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/150/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/150/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/150/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/150/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/150/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/150/10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/150/11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/150/12.png),![ppt13](https://assets.leetcode-cn.com/solution-static/150/13.png),![ppt14](https://assets.leetcode-cn.com/solution-static/150/14.png),![ppt15](https://assets.leetcode-cn.com/solution-static/150/15.png)>

```Java [sol2-Java]
class Solution {
    public int evalRPN(String[] tokens) {
        int n = tokens.length;
        int[] stack = new int[(n + 1) / 2];
        int index = -1;
        for (int i = 0; i < n; i++) {
            String token = tokens[i];
            switch (token) {
                case "+":
                    index--;
                    stack[index] += stack[index + 1];
                    break;
                case "-":
                    index--;
                    stack[index] -= stack[index + 1];
                    break;
                case "*":
                    index--;
                    stack[index] *= stack[index + 1];
                    break;
                case "/":
                    index--;
                    stack[index] /= stack[index + 1];
                    break;
                default:
                    index++;
                    stack[index] = Integer.parseInt(token);
            }
        }
        return stack[index];
    }
}
```

```JavaScript [sol2-JavaScript]
var evalRPN = function(tokens) {
    const n = tokens.length;
    const stack = new Array(Math.floor((n + 1) / 2)).fill(0);
    let index = -1;
    for (let i = 0; i < n; i++) {
        const token = tokens[i];
        if (token === '+') {
            index--;
            stack[index] += stack[index + 1];
        } else if (token === '-') {
            index--;
            stack[index] -= stack[index + 1];
        } else if (token === '*') {
            index--;
            stack[index] *= stack[index + 1];
        } else if (token === '/') {
            index--;
            stack[index] = stack[index] / stack[index + 1] > 0 ? Math.floor(stack[index] / stack[index + 1]) : Math.ceil(stack[index] / stack[index + 1]);
        } else {
            index++;
            stack[index] = parseInt(token);
        }
    }
    return stack[index];
}; 
```

```go [sol2-Golang]
func evalRPN(tokens []string) int {
    stack := make([]int, (len(tokens)+1)/2)
    index := -1
    for _, token := range tokens {
        val, err := strconv.Atoi(token)
        if err == nil {
            index++
            stack[index] = val
        } else {
            index--
            switch token {
            case "+":
                stack[index] += stack[index+1]
            case "-":
                stack[index] -= stack[index+1]
            case "*":
                stack[index] *= stack[index+1]
            default:
                stack[index] /= stack[index+1]
            }
        }
    }
    return stack[0]
}
```

```Python [sol2-Python3]
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        op_to_binary_fn = {
            "+": add,
            "-": sub,
            "*": mul,
            "/": lambda x, y: int(x / y),   # 需要注意 python 中负数除法的表现与题目不一致
        }

        n = len(tokens)
        stack = [0] * ((n + 1) // 2)
        index = -1
        for token in tokens:
            try:
                num = int(token)
                index += 1
                stack[index] = num
            except ValueError:
                index -= 1
                stack[index] = op_to_binary_fn[token](stack[index], stack[index + 1])
            
        return stack[0]
```

```C++ [sol2-C++]
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int n = tokens.size();
        vector<int> stk((n + 1) / 2);
        int index = -1;
        for (int i = 0; i < n; i++) {
            string& token = tokens[i];
            if (token.length() > 1 || isdigit(token[0])) {
                index++;
                stk[index] = atoi(token.c_str());
            } else {
                switch (token[0]) {
                    case '+':
                        index--;
                        stk[index] += stk[index + 1];
                        break;
                    case '-':
                        index--;
                        stk[index] -= stk[index + 1];
                        break;
                    case '*':
                        index--;
                        stk[index] *= stk[index + 1];
                        break;
                    case '/':
                        index--;
                        stk[index] /= stk[index + 1];
                        break;
                }
            }
        }
        return stk[index];
    }
};
```

```C [sol2-C]
int evalRPN(char** tokens, int tokensSize) {
    int n = tokensSize;
    int stk[(n + 1) / 2];
    memset(stk, 0, sizeof(stk));
    int index = -1;
    for (int i = 0; i < n; i++) {
        char* token = tokens[i];
        if (strlen(token) > 1 || isdigit(token[0])) {
            index++;
            stk[index] = atoi(token);
        } else {
            switch (token[0]) {
                case '+':
                    index--;
                    stk[index] += stk[index + 1];
                    break;
                case '-':
                    index--;
                    stk[index] -= stk[index + 1];
                    break;
                case '*':
                    index--;
                    stk[index] *= stk[index + 1];
                    break;
                case '/':
                    index--;
                    stk[index] /= stk[index + 1];
                    break;
            }
        }
    }
    return stk[index];
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{tokens}$ 的长度。需要遍历数组 $\textit{tokens}$ 一次，计算逆波兰表达式的值。

- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{tokens}$ 的长度。需要创建长度为 $\frac{n+1}{2}$ 的数组模拟栈操作。