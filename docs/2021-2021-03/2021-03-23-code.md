# 2021年03月23日 code
<a href="https://toutiao.io/k/4xmlwst">看的书多，就有用吗？</a><br /><a href="https://toutiao.io/k/mms9xqu">OCTO 2.0：美团基于 Service Mesh 的服务治理系统详解</a><br /><a href="https://toutiao.io/k/6mcd3q3">我成长最快的那五年</a><br /><a href="https://toutiao.io/k/u4ikq3r">JavaScript 中原型与原型链的简单理解</a><br /><a href="https://toutiao.io/k/2n1unis">[译] 如何优雅地关闭 Kubernetes 集群中的 Pod</a><br /><a href="https://toutiao.io/k/6j2gosr">独立开发者如何快速从 0 到 1 设计一款 App 的 Logo：绘制图形</a><br /><a href="https://toutiao.io/k/dwvl7cy">揭秘手游外挂：基于内存蜜罐的内存修改挂分析技术</a><br /><a href="https://toutiao.io/k/6upyjyc">架构设计笔记（十一）：关键模式_缓存</a><br /><a href="https://toutiao.io/k/plr544h">CRM 数据质量怎么控？来，全球 500 强的经验分享给你</a><br /><a href="https://toutiao.io/k/yuuynmn">大小端序分析以及 go 范例</a><br /><a href="https://toutiao.io/k/yqxap5a">如何写更安全的代码？</a><br /><a href="https://toutiao.io/k/x954hu1">多业务线亿级体量，携程是怎么做账务中台的</a><br /><a href="https://toutiao.io/k/rfq419d">Java 对象组成，对象头分析</a><br /><a href="https://toutiao.io/k/vsmboe2">Cobar SQL 审计的设计与实现</a><br /><a href="https://toutiao.io/k/23hpqcd">Spring/SpringMVC 项目 apollo 支持日志配置</a><br /><a href="https://toutiao.io/k/3hvbcmg">对话交互：封闭域任务型与开放域闲聊算法技术</a><br /><a href="https://toutiao.io/k/67rks7l">[译] 关于 Android 音频延迟的最新动态</a><br /><a href="https://toutiao.io/k/0t9l0j8">软件测试人员该何去何从？</a><br /><a href="https://toutiao.io/k/eolt5hy">如何解决 Netty Channel.isWritable 返回 false</a><br /><a href="https://toutiao.io/k/s0lwst5">从 QuickJS 到 Dart VM：稿定跨端渲染工程的运行时演化</a><br /><a href="https://toutiao.io/k/jdslwhk">[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</a><br /><a href="https://toutiao.io/k/5apgnxp">[推荐] Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/vmimc5g">[推荐] 聊聊 IT 技术人的知识体系</a><br /><a href="https://toutiao.io/k/hxrinvv">[推荐] 下一代微服务 Service Mesh 原理及实践</a><br /><a href="https://toutiao.io/k/mzszqf0">[推荐] 谈谈 Git 存储原理及相关实现</a><br /><a href="https://toutiao.io/k/ga340bq">[推荐] MySQL 读写分离，写完读不到问题如何解决</a><br /><a href="https://toutiao.io/k/av396i0">[推荐] Redis 教程：Redis 知识体系详解</a><br /><a href="https://toutiao.io/k/dux0ogl">[推荐] 这几款 JVM 故障诊断处理工具你还不会？</a><br /><a href="https://toutiao.io/k/vsxwjpf">[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a><br /><a href="https://toutiao.io/k/qh7wgrx">[推荐] 去哪里找 Java 练手项目？</a><br /><a href="https://toutiao.io/k/0ic2o68">[推荐] 带你深入理解 Java 内存模型理论</a><br /><a href="https://toutiao.io/k/tgp1ua8">[推荐] 面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</a><br /><a href="https://toutiao.io/k/ghs0i7r">[推荐] 不懂什么是云原生？看完这篇文章就够了！</a><br /><a href="https://toutiao.io/k/yl7s9sl">[推荐] 算法面试套路知多少</a><br /><a href="https://toutiao.io/k/1d2mnjh">[推荐] 职场：3 天准备 5 天面试，跳槽完成</a><br /><hr /><a href="https://github.com/login?return_to=%2FLukeSmithxyz%2Fbased.cooking">A simple culinary website.</a><br /><a href="https://github.com/holo-gfx/mangadex"></a><br /><a href="https://github.com/papercups-io/papercups">Open-source live customer chat</a><br /><a href="https://github.com/geekcomputers/Python">My Python Examples</a><br /><a href="https://github.com/edeng23/binance-trade-bot">Automated cryptocurrency trading bot</a><br /><a href="https://github.com/login?return_to=%2FDavidBuchanan314%2Ftweetable-polyglot-png">Pack up to 3MB of data into a tweetable PNG polyglot file.</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/blazorhero/CleanArchitecture">Clean Architecture Template for Blazor WebAssembly Built with MudBlazor Components.</a><br /><a href="https://github.com/XTLS/Xray-core">Xray, Penetrates Everything. Also the best v2ray-core, with XTLS support. Fully compatible configuration.</a><br /><a href="https://github.com/521xueweihan/GitHub520">😘 让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。（无需安装）</a><br /><a href="https://github.com/Aircoookie/WLED">Control WS2812B and many more types of digital RGB LEDs with an ESP8266 or ESP32 over WiFi!</a><br /><a href="https://github.com/godotengine/godot">Godot Engine – Multi-platform 2D and 3D game engine</a><br /><a href="https://github.com/EleutherAI/gpt-neo">An implementation of model parallel GPT2& GPT3-like models, with the ability to scale up to full GPT3 sizes (and possibly more!), using the mesh-tensorflow library.</a><br /><a href="https://github.com/iperov/DeepFaceLab">DeepFaceLab is the leading software for creating deepfakes.</a><br /><a href="https://github.com/Developer-Y/cs-video-courses">List of Computer Science courses with video lectures.</a><br /><a href="https://github.com/DrKLO/Telegram">Telegram for Android source</a><br /><a href="https://github.com/ryanburgess/engineer-manager">A list of engineering manager resource links.</a><br /><a href="https://github.com/florinpop17/app-ideas">A Collection of application ideas which can be used to improve your coding skills.</a><br /><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</a><br /><a href="https://github.com/CSSEGISandData/COVID-19">Novel Coronavirus (COVID-19) Cases, provided by JHU CSSE</a><br /><a href="https://github.com/CyC2018/CS-Notes">📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++</a><br /><a href="https://github.com/infosecn1nja/AD-Attack-Defense">Attack and defend active directory using modern post exploitation adversary tradecraft activity</a><br /><a href="https://github.com/login?return_to=%2Fchatwoot%2Fchatwoot">Open-source customer engagement suite, an alternative to Intercom, Zendesk, Salesforce Service Cloud etc. 🔥💬</a><br /><a href="https://github.com/stefanw/voebbot">VOEBBot is a browser extension that removes the paywall on German online news sites using your VÖBB library account.</a><br /><a href="https://github.com/login?return_to=%2Fkamranahmedse%2Fdeveloper-roadmap">Roadmap to becoming a web developer in 2021</a><br /><hr />扁平化嵌套列表迭代器<br /><p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>

<p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入: </strong>[[1,1],2,[1,1]]
<strong>输出: </strong>[1,1,2,1,1]
<strong>解释: </strong>通过重复调用&nbsp;<em>next </em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,1,2,1,1]</code>。</pre>

<p><strong>示例 2:</strong></p>

<pre><strong>输入: </strong>[1,[4,[6]]]
<strong>输出: </strong>[1,4,6]
<strong>解释: </strong>通过重复调用&nbsp;<em>next&nbsp;</em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,4,6]</code>。
</pre>
<br />#### 方法一：深度优先搜索

**思路**

嵌套的整型列表是一个树形结构，树上的叶子节点对应一个整数，非叶节点对应一个列表。

在这棵树上深度优先搜索的顺序就是迭代器遍历的顺序。

我们可以先遍历整个嵌套列表，将所有整数存入一个数组，然后遍历该数组从而实现 $\texttt{next}$ 和 $\texttt{hasNext}$ 方法。

**代码**

```C++ [sol1-C++]
class NestedIterator {
private:
    vector<int> vals;
    vector<int>::iterator cur;

    void dfs(const vector<NestedInteger> &nestedList) {
        for (auto &nest : nestedList) {
            if (nest.isInteger()) {
                vals.push_back(nest.getInteger());
            } else {
                dfs(nest.getList());
            }
        }
    }

public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        dfs(nestedList);
        cur = vals.begin();
    }

    int next() {
        return *cur++;
    }

    bool hasNext() {
        return cur != vals.end();
    }
};
```

```Java [sol1-Java]
public class NestedIterator implements Iterator<Integer> {
    private List<Integer> vals;
    private Iterator<Integer> cur;

    public NestedIterator(List<NestedInteger> nestedList) {
        vals = new ArrayList<Integer>();
        dfs(nestedList);
        cur = vals.iterator();
    }

    @Override
    public Integer next() {
        return cur.next();
    }

    @Override
    public boolean hasNext() {
        return cur.hasNext();
    }

    private void dfs(List<NestedInteger> nestedList) {
        for (NestedInteger nest : nestedList) {
            if (nest.isInteger()) {
                vals.add(nest.getInteger());
            } else {
                dfs(nest.getList());
            }
        }
    }
}
```

```go [sol1-Golang]
type NestedIterator struct {
    vals []int
}

func Constructor(nestedList []*NestedInteger) *NestedIterator {
    var vals []int
    var dfs func([]*NestedInteger)
    dfs = func(nestedList []*NestedInteger) {
        for _, nest := range nestedList {
            if nest.IsInteger() {
                vals = append(vals, nest.GetInteger())
            } else {
                dfs(nest.GetList())
            }
        }
    }
    dfs(nestedList)
    return &NestedIterator{vals}
}

func (it *NestedIterator) Next() int {
    val := it.vals[0]
    it.vals = it.vals[1:]
    return val
}

func (it *NestedIterator) HasNext() bool {
    return len(it.vals) > 0
}
```

```JavaScript [sol1-JavaScript]
var NestedIterator = function(nestedList) {
    vals = [];
    const dfs = (nestedList) => {
        for (const nest of nestedList) {
            if (nest.isInteger()) {
                vals.push(nest.getInteger());
            } else {
                dfs(nest.getList());
            }
        }
    }
    dfs(nestedList);
};

NestedIterator.prototype.hasNext = function() {
    return vals.length > 0;
};

NestedIterator.prototype.next = function() {
    const val = vals[0];
    vals = vals.slice(1);
    return val;
};
```

```C [sol1-C]
struct NestedIterator {
    int *vals;
    int size;
    int cur;
};

void dfs(struct NestedIterator *iter, struct NestedInteger **nestedList, int nestedListSize) {
    for (int i = 0; i < nestedListSize; i++) {
        if (NestedIntegerIsInteger(nestedList[i])) {
            (iter->vals)[(iter->size)++] = NestedIntegerGetInteger(nestedList[i]);
        } else {
            dfs(iter, NestedIntegerGetList(nestedList[i]), NestedIntegerGetListSize(nestedList[i]));
        }
    }
}

struct NestedIterator *nestedIterCreate(struct NestedInteger **nestedList, int nestedListSize) {
    struct NestedIterator *ret = malloc(sizeof(struct NestedIterator));
    ret->vals = malloc(sizeof(int) * 20001);
    ret->size = 0;
    ret->cur = 0;
    dfs(ret, nestedList, nestedListSize);
    return ret;
}

bool nestedIterHasNext(struct NestedIterator *iter) {
    return iter->cur != iter->size;
}

int nestedIterNext(struct NestedIterator *iter) {
    return (iter->vals)[(iter->cur)++];
}

void nestedIterFree(struct NestedIterator *iter) {
    free(iter->vals);
    free(iter);
}
```

**复杂度分析**

- 时间复杂度：初始化为 $O(n)$，$\texttt{next}$ 和 $\texttt{hasNext}$ 为 $O(1)$。其中 $n$ 是嵌套的整型列表中的元素个数。

- 空间复杂度：$O(n)$。需要一个数组存储嵌套的整型列表中的所有元素。

#### 方法二：栈

**思路**

我们可以用一个栈来代替方法一中的递归过程。

具体来说，用一个栈来维护深度优先搜索时，从根节点到当前节点路径上的所有节点。由于非叶节点对应的是一个列表，我们在栈中存储的是指向列表当前遍历的元素的指针（下标）。每次向下搜索时，取出列表的当前指针指向的元素并将其入栈，同时将该指针向后移动一位。如此反复直到找到一个整数。循环时若栈顶指针指向了列表末尾，则将其从栈顶弹出。

下面的代码中，$\texttt{C++}$ 和 $\texttt{Java}$ 的栈存储的是迭代器，迭代器可以起到指向元素的指针的效果，$\texttt{Go}$ 的栈存储的是切片（视作队列），通过将元素弹出队首的操作代替移动指针的操作。

**代码**

```C++ [sol2-C++]
class NestedIterator {
private:
    // pair 中存储的是列表的当前遍历位置，以及一个尾后迭代器用于判断是否遍历到了列表末尾
    stack<pair<vector<NestedInteger>::iterator, vector<NestedInteger>::iterator>> stk;

public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        stk.emplace(nestedList.begin(), nestedList.end());
    }

    int next() {
        // 由于保证调用 next 之前会调用 hasNext，直接返回栈顶列表的当前元素，然后迭代器指向下一个元素
        return stk.top().first++->getInteger();
    }

    bool hasNext() {
        while (!stk.empty()) {
            auto &p = stk.top();
            if (p.first == p.second) { // 遍历到当前列表末尾，出栈
                stk.pop();
                continue;
            }
            if (p.first->isInteger()) {
                return true;
            }
            // 若当前元素为列表，则将其入栈，且迭代器指向下一个元素
            auto &lst = p.first++->getList();
            stk.emplace(lst.begin(), lst.end());
        }
        return false;
    }
};
```

```Java [sol2-Java]
public class NestedIterator implements Iterator<Integer> {
    // 存储列表的当前遍历位置
    private Deque<Iterator<NestedInteger>> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new LinkedList<Iterator<NestedInteger>>();
        stack.push(nestedList.iterator());
    }

    @Override
    public Integer next() {
        // 由于保证调用 next 之前会调用 hasNext，直接返回栈顶列表的当前元素
        return stack.peek().next().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            Iterator<NestedInteger> it = stack.peek();
            if (!it.hasNext()) { // 遍历到当前列表末尾，出栈
                stack.pop();
                continue;
            }
            // 若取出的元素是整数，则通过创建一个额外的列表将其重新放入栈中
            NestedInteger nest = it.next();
            if (nest.isInteger()) {
                List<NestedInteger> list = new ArrayList<NestedInteger>();
                list.add(nest);
                stack.push(list.iterator());
                return true;
            }
            stack.push(nest.getList().iterator());
        }
        return false;
    }
}
```

```go [sol2-Golang]
type NestedIterator struct {
    // 将列表视作一个队列，栈中直接存储该队列
    stack [][]*NestedInteger
}

func Constructor(nestedList []*NestedInteger) *NestedIterator {
    return &NestedIterator{[][]*NestedInteger{nestedList}}
}

func (it *NestedIterator) Next() int {
    // 由于保证调用 Next 之前会调用 HasNext，直接返回栈顶列表的队首元素，将其弹出队首并返回
    queue := it.stack[len(it.stack)-1]
    val := queue[0].GetInteger()
    it.stack[len(it.stack)-1] = queue[1:]
    return val
}

func (it *NestedIterator) HasNext() bool {
    for len(it.stack) > 0 {
        queue := it.stack[len(it.stack)-1]
        if len(queue) == 0 { // 当前队列为空，出栈
            it.stack = it.stack[:len(it.stack)-1]
            continue
        }
        nest := queue[0]
        if nest.IsInteger() {
            return true
        }
        // 若队首元素为列表，则将其弹出队列并入栈
        it.stack[len(it.stack)-1] = queue[1:]
        it.stack = append(it.stack, nest.GetList())
    }
    return false
}
```

```JavaScript [sol2-JavaScript]
var NestedIterator = function(nestedList) {
    this.stack = nestedList;
};

NestedIterator.prototype.hasNext = function() {
    while (this.stack.length !== 0) {
        if (this.stack[0].isInteger()) {
            return true;
        } else {
            let cur = this.stack[0].getList();
            this.stack.shift();
            this.stack.unshift(...cur);
        }
    }
};

NestedIterator.prototype.next = function() {
    return this.stack.shift().getInteger();
};
```

**复杂度分析**

- 时间复杂度：初始化和 $\texttt{next}$ 为 $O(1)$，$\texttt{hasNext}$ 为均摊 $O(1)$。

- 空间复杂度：$O(n)$。最坏情况下嵌套的整型列表是一条链，我们需要一个 $O(n)$ 大小的栈来存储链上的所有元素。