# 2021å¹´03æœˆ24æ—¥ code
<a href="https://toutiao.io/k/2qkwu5f">Spring Boot ä¸­ä¼˜é›…çš„ä½¿ç”¨ Swagger 2ï¼ˆå²ä¸Šæœ€å…¨æ³¨è§£ç¯‡ï¼‰</a><br /><a href="https://toutiao.io/k/bhwr4ne">å°å›¢é˜Ÿå¤–åŒ…å›°å±€</a><br /><a href="https://toutiao.io/k/9injk1e">æ¼«ç”»ï¼šå¦‚ä½•å‘å¤–è¡Œè§£é‡Šï¼ŒBug æ˜¯å¦‚ä½•äº§ç”Ÿçš„ï¼Ÿ</a><br /><a href="https://toutiao.io/k/0z4t2y0">Golang ä¸­çš„æ’ä»¶å¼€å‘</a><br /><a href="https://toutiao.io/k/kzzmbxw">Spring Boot å¯åŠ¨æ—¶æ‰§è¡Œä»»åŠ¡</a><br /><a href="https://toutiao.io/k/3k60qwy">Tyk API Gateway é™æµè®¾è®¡</a><br /><a href="https://toutiao.io/k/cccopgf">[è¯‘] ClickHouse åœ¨æ—¥å¿—å­˜å‚¨ä¸åˆ†ææ–¹é¢ä½œä¸º ElasticSearch å’Œ MySQL çš„æ›¿ä»£æ–¹æ¡ˆ</a><br /><a href="https://toutiao.io/k/ktq1g58">[è¯‘] åœ¨ React åº”ç”¨ä¸­ä½¿ç”¨ Dexie.js è¿›è¡Œç¦»çº¿æ•°æ®å­˜å‚¨</a><br /><a href="https://toutiao.io/k/fuul2bb">MyBatis-plus å¦‚ä½•ç¦ç”¨ä¸€çº§ç¼“å­˜</a><br /><a href="https://toutiao.io/k/s2tczgu">ç”¨ AI â€œå”¤é†’â€ è€ç…§ç‰‡ï¼ˆMixlab æŠ€æœ¯å‰æ²¿ï¼‰</a><br /><a href="https://toutiao.io/k/v654um3">æµ…è°ˆ synchronized ä¸ Object.wait/notify åŸç†</a><br /><a href="https://toutiao.io/k/tprx3d7">Thread ç–¾é£ä¼ </a><br /><a href="https://toutiao.io/k/hlvaaq7">é©¬æ–¯å…‹å¯¹è¯è–›å…¶å¤ï¼šè°ˆç‰©ç†ã€äººå·¥æ™ºèƒ½å’Œå¤§å­¦æ•™è‚²  â€‹</a><br /><a href="https://toutiao.io/k/gh46fi9">JVM è¿›é˜¶ä¹‹è·¯ï¼ˆäºŒï¼‰ï¼šJava å†…å­˜åŒºåŸŸ</a><br /><a href="https://toutiao.io/k/i66efq3">â€œé«˜èŠ¯â€ ç„¦è™‘ï¼Œé™å¾…èŠ±å¼€</a><br /><a href="https://toutiao.io/k/ti6xgmd">AV1 åœ¨ RTC åº”ç”¨å®è·µä¸­çš„ç°çŠ¶ä¸å±•æœ›</a><br /><a href="https://toutiao.io/k/e5la7c7">Netty æºç è§£æï¼šå†…å­˜å¯¹é½ç±» SizeClasses</a><br /><a href="https://toutiao.io/k/s5quj1g">å¦‚ä½•åœ¨ Istio ä¸­è¿›è¡Œæºåœ°å€ä¿æŒï¼Ÿ</a><br /><a href="https://toutiao.io/k/mlbazvx">5G æ—¶ä»£çš„ç›´æ’­ï¼Œå°†å¸¦æ¥æ€æ ·çš„ä½å»¶è¿Ÿä½“éªŒ</a><br /><a href="https://toutiao.io/k/zoz4fhb">å¦‚ä½•ä½¿ç”¨ BenchmarkDotNet å¯¹ C# ä»£ç è¿›è¡ŒåŸºå‡†æµ‹è¯•</a><br /><a href="https://toutiao.io/k/r5kgujp">[æ¨è] ä»æŠ€æœ¯ä¸“å®¶åˆ°æŠ€æœ¯ç®¡ç†ï¼Œæˆ‘å¯¹ç®¡ç†çš„æ€è€ƒ</a><br /><a href="https://toutiao.io/k/ghs0i7r">[æ¨è] ä¸æ‡‚ä»€ä¹ˆæ˜¯äº‘åŸç”Ÿï¼Ÿçœ‹å®Œè¿™ç¯‡æ–‡ç« å°±å¤Ÿäº†ï¼</a><br /><a href="https://toutiao.io/k/yduqoev">[æ¨è] Redis æœ€ä½³å®è·µï¼š7 ä¸ªç»´åº¦ + 43 æ¡ä½¿ç”¨è§„èŒƒï¼Œå¸¦ä½ å½»åº•ç©è½¬ Redis</a><br /><a href="https://toutiao.io/k/yl7s9sl">[æ¨è] ç®—æ³•é¢è¯•å¥—è·¯çŸ¥å¤šå°‘</a><br /><a href="https://toutiao.io/k/ga340bq">[æ¨è] MySQL è¯»å†™åˆ†ç¦»ï¼Œå†™å®Œè¯»ä¸åˆ°é—®é¢˜å¦‚ä½•è§£å†³</a><br /><a href="https://toutiao.io/k/av396i0">[æ¨è] Redis æ•™ç¨‹ï¼šRedis çŸ¥è¯†ä½“ç³»è¯¦è§£</a><br /><a href="https://toutiao.io/k/xpyufe6">[æ¨è] ä½ å¯¹å¤©å¤©æŒ‚åœ¨å˜´è¾¹çš„é«˜å¹¶å‘ï¼Œæ€•æ˜¯æœ‰ä»€ä¹ˆè¯¯è§£å§ï¼Ÿ</a><br /><a href="https://toutiao.io/k/gqpcukq">[æ¨è] TCP/IP å¸¸è§æ”»å‡»æ‰‹æ®µ</a><br /><a href="https://toutiao.io/k/le19zdx">[æ¨è] ä¸‡å­—é•¿æ–‡ï¼šå½»åº•ææ‡‚å®¹å™¨é•œåƒæ„å»º</a><br /><a href="https://toutiao.io/k/mzszqf0">[æ¨è] è°ˆè°ˆ Git å­˜å‚¨åŸç†åŠç›¸å…³å®ç°</a><br /><a href="https://toutiao.io/k/dux0ogl">[æ¨è] è¿™å‡ æ¬¾ JVM æ•…éšœè¯Šæ–­å¤„ç†å·¥å…·ä½ è¿˜ä¸ä¼šï¼Ÿ</a><br /><a href="https://toutiao.io/k/hxrinvv">[æ¨è] ä¸‹ä¸€ä»£å¾®æœåŠ¡ Service Mesh åŸç†åŠå®è·µ</a><br /><a href="https://toutiao.io/k/0ic2o68">[æ¨è] å¸¦ä½ æ·±å…¥ç†è§£ Java å†…å­˜æ¨¡å‹ç†è®º</a><br /><a href="https://toutiao.io/k/pmxukkm">[æ¨è] é¢è¯•è¢«åŠæ‰“ï¼šRedis åŸç†</a><br /><a href="https://toutiao.io/k/ozl31qb">[æ¨è] å¦‚ä½•å†™å‡ºé«˜è´¨é‡çš„æŠ€æœ¯æ–‡ç« ï¼Ÿ</a><br /><hr /><a href="https://github.com/EleutherAI/gpt-neo">An implementation of model parallel GPT2& GPT3-like models, with the ability to scale up to full GPT3 sizes (and possibly more!), using the mesh-tensorflow library.</a><br /><a href="https://github.com/ARKInvest/ARK-Invest-Tesla-Valuation-Model">An excerpt from our financial valuation model of Tesla</a><br /><a href="https://github.com/edeng23/binance-trade-bot">Automated cryptocurrency trading bot</a><br /><a href="https://github.com/geekcomputers/Python">My Python Examples</a><br /><a href="https://github.com/Malfrats/xeuledoc">Fetch information about a public Google document.</a><br /><a href="https://github.com/lux-org/lux">Python API for Intelligent Visual Data Discovery</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/papercups-io/papercups">Open-source live customer chat</a><br /><a href="https://github.com/ShapeAI/PYTHON-AND-DATA-ANALYTICS-7-DAYS"></a><br /><a href="https://github.com/docmirror/dev-sidecar">å¼€å‘è€…è¾¹è½¦ï¼Œgithubæ‰“ä¸å¼€ï¼ŒgithubåŠ é€Ÿï¼Œgit cloneåŠ é€Ÿï¼Œgit releaseä¸‹è½½åŠ é€Ÿï¼ŒstackoverflowåŠ é€Ÿ</a><br /><a href="https://github.com/ryanburgess/engineer-manager">A list of engineering manager resource links.</a><br /><a href="https://github.com/mrcodedev/frontend-developer-resources">Recursos gratuitos para empezar a ser un Frontend Developer o ampliar conocimientos</a><br /><a href="https://github.com/godotengine/godot">Godot Engine â€“ Multi-platform 2D and 3D game engine</a><br /><a href="https://github.com/ccxt/ccxt">A JavaScript / Python / PHP cryptocurrency trading API with support for more than 120 bitcoin/altcoin exchanges</a><br /><a href="https://github.com/vuejs/awesome-vue">ğŸ‰ A curated list of awesome things related to Vue.js</a><br /><a href="https://github.com/owid/covid-19-data">Data on COVID-19 (coronavirus) cases, deaths, hospitalizations, tests â€¢ All countries â€¢ Updated daily by Our World in Data</a><br /><a href="https://github.com/jesse-ai/jesse">An advanced crypto trading bot written in Python</a><br /><a href="https://github.com/jonasschmedtmann/complete-javascript-course">Starter files, final projects and FAQ for my Complete JavaScript course</a><br /><a href="https://github.com/0dayCTF/reverse-shell-generator">Hosted Reverse Shell generator with a ton of functionality. -- (Great for CTFs)</a><br /><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">ğŸ‡¨ğŸ‡³ GitHubä¸­æ–‡æ’è¡Œæ¦œï¼Œå¸®åŠ©ä½ å‘ç°é«˜åˆ†ä¼˜ç§€ä¸­æ–‡é¡¹ç›®ã€æ›´é«˜æ•ˆåœ°å¸æ”¶å›½äººçš„ä¼˜ç§€ç»éªŒæˆæœï¼›æ¦œå•æ¯å‘¨æ›´æ–°ä¸€æ¬¡ï¼Œæ•¬è¯·å…³æ³¨ï¼</a><br /><a href="https://github.com/atlas-engineer/nyxt">Nyxt - the internet on your terms.</a><br /><a href="https://github.com/macrozheng/mall">mallé¡¹ç›®æ˜¯ä¸€å¥—ç”µå•†ç³»ç»Ÿï¼ŒåŒ…æ‹¬å‰å°å•†åŸç³»ç»ŸåŠåå°ç®¡ç†ç³»ç»Ÿï¼ŒåŸºäºSpringBoot+MyBatiså®ç°ï¼Œé‡‡ç”¨Dockerå®¹å™¨åŒ–éƒ¨ç½²ã€‚ å‰å°å•†åŸç³»ç»ŸåŒ…å«é¦–é¡µé—¨æˆ·ã€å•†å“æ¨èã€å•†å“æœç´¢ã€å•†å“å±•ç¤ºã€è´­ç‰©è½¦ã€è®¢å•æµç¨‹ã€ä¼šå‘˜ä¸­å¿ƒã€å®¢æˆ·æœåŠ¡ã€å¸®åŠ©ä¸­å¿ƒç­‰æ¨¡å—ã€‚ åå°ç®¡ç†ç³»ç»ŸåŒ…å«å•†å“ç®¡ç†ã€è®¢å•ç®¡ç†ã€ä¼šå‘˜ç®¡ç†ã€ä¿ƒé”€ç®¡ç†ã€è¿è¥ç®¡ç†ã€å†…å®¹ç®¡ç†ã€ç»Ÿè®¡æŠ¥è¡¨ã€è´¢åŠ¡ç®¡ç†ã€æƒé™ç®¡ç†ã€è®¾ç½®ç­‰æ¨¡å—ã€‚</a><br /><a href="https://github.com/Hari-Nagarajan/fairgame">Tool to help us buy hard to find items.</a><br /><a href="https://github.com/pandas-dev/pandas">Flexible and powerful data analysis / manipulation library for Python, providing labeled data structures similar to R data.frame objects, statistical functions, and much more</a><br /><hr />132æ¨¡å¼<br /><p>ç»™å®šä¸€ä¸ªæ•´æ•°åºåˆ—ï¼ša<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>ï¼Œä¸€ä¸ª132æ¨¡å¼çš„å­åºåˆ—&nbsp;a<sub><strong>i</strong></sub>, a<sub><strong>j</strong></sub>, a<sub><strong>k</strong></sub>&nbsp;è¢«å®šä¹‰ä¸ºï¼šå½“ <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> æ—¶ï¼Œa<sub><strong>i</strong></sub> &lt; a<sub><strong>k</strong></sub> &lt; a<sub><strong>j</strong></sub>ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå½“ç»™å®šæœ‰&nbsp;n ä¸ªæ•°å­—çš„åºåˆ—æ—¶ï¼ŒéªŒè¯è¿™ä¸ªåºåˆ—ä¸­æ˜¯å¦å«æœ‰132æ¨¡å¼çš„å­åºåˆ—ã€‚</p>

<p><strong>æ³¨æ„ï¼š</strong>n çš„å€¼å°äº15000ã€‚</p>

<p><strong>ç¤ºä¾‹1:</strong></p>

<pre>
<strong>è¾“å…¥:</strong> [1, 2, 3, 4]

<strong>è¾“å‡º:</strong> False

<strong>è§£é‡Š:</strong> åºåˆ—ä¸­ä¸å­˜åœ¨132æ¨¡å¼çš„å­åºåˆ—ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2:</strong></p>

<pre>
<strong>è¾“å…¥:</strong> [3, 1, 4, 2]

<strong>è¾“å‡º:</strong> True

<strong>è§£é‡Š:</strong> åºåˆ—ä¸­æœ‰ 1 ä¸ª132æ¨¡å¼çš„å­åºåˆ—ï¼š [1, 4, 2].
</pre>

<p><strong>ç¤ºä¾‹ 3:</strong></p>

<pre>
<strong>è¾“å…¥:</strong> [-1, 3, 2, 0]

<strong>è¾“å‡º:</strong> True

<strong>è§£é‡Š:</strong> åºåˆ—ä¸­æœ‰ 3 ä¸ª132æ¨¡å¼çš„çš„å­åºåˆ—: [-1, 3, 2], [-1, 3, 0] å’Œ [-1, 2, 0].
</pre>
<br />#### å‰è¨€

ç”±äºæœ¬é¢˜ä¸­ $n$ çš„æœ€å¤§å€¼å¯ä»¥åˆ° $15000$ï¼Œå› æ­¤å¯¹äºä¸€ä¸ªæ»¡è¶³ $132$ æ¨¡å¼çš„ä¸‰å…ƒç»„ä¸‹æ ‡ $(i, j, k)$ï¼Œæšä¸¾å…¶ä¸­çš„ $2$ ä¸ªä¸‹æ ‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œå¾ˆå®¹æ˜“è¶…å‡ºæ—¶é—´é™åˆ¶ã€‚

å› æ­¤æˆ‘ä»¬å¯ä»¥è€ƒè™‘æšä¸¾å…¶ä¸­çš„ $1$ ä¸ªä¸‹æ ‡ï¼Œå¹¶ä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„ç»´æŠ¤å¦å¤–çš„ $2$ ä¸ªä¸‹æ ‡çš„å¯èƒ½å€¼ã€‚

#### æ–¹æ³•ä¸€ï¼šæšä¸¾ $3$

**æ€è·¯ä¸ç®—æ³•**

æšä¸¾ $3$ æ˜¯å®¹æ˜“æƒ³åˆ°å¹¶ä¸”ä¹Ÿæ˜¯æœ€å®¹æ˜“å®ç°çš„ã€‚ç”±äº $3$ æ˜¯æ¨¡å¼ä¸­çš„æœ€å¤§å€¼ï¼Œå¹¶ä¸”å…¶å‡ºç°åœ¨ $1$ å’Œ $2$ çš„ä¸­é—´ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦ä»å·¦åˆ°å³æšä¸¾ $3$ çš„ä¸‹æ ‡ $j$ï¼Œé‚£ä¹ˆï¼š

- ç”±äº $1$ æ˜¯æ¨¡å¼ä¸­çš„æœ€å°å€¼ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æšä¸¾ $j$ çš„åŒæ—¶ï¼Œç»´æŠ¤æ•°ç»„ $a$ ä¸­å·¦ä¾§å…ƒç´  $a[0..j-1]$ çš„æœ€å°å€¼ï¼Œå³ä¸º $1$ å¯¹åº”çš„å…ƒç´  $a[i]$ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåªæœ‰ $a[i] < a[j]$ æ—¶ï¼Œ$a[i]$ æ‰èƒ½ä½œä¸º $1$ å¯¹åº”çš„å…ƒç´ ï¼›

- ç”±äº $2$ æ˜¯æ¨¡å¼ä¸­çš„æ¬¡å°å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæœ‰åºé›†åˆï¼ˆä¾‹å¦‚å¹³è¡¡æ ‘ï¼‰ç»´æŠ¤æ•°ç»„ $a$ ä¸­å³ä¾§å…ƒç´  $a[j+1..n-1]$ ä¸­çš„æ‰€æœ‰å€¼ã€‚å½“æˆ‘ä»¬ç¡®å®šäº† $a[i]$ å’Œ $a[j]$ ä¹‹åï¼Œåªéœ€è¦åœ¨æœ‰åºé›†åˆä¸­æŸ¥è¯¢ä¸¥æ ¼æ¯” $a[i]$ å¤§çš„é‚£ä¸ªæœ€å°çš„å…ƒç´ ï¼Œå³ä¸º $a[k]$ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåªæœ‰ $a[k] < a[j]$ æ—¶ï¼Œ$a[k]$ æ‰èƒ½ä½œä¸º $3$ å¯¹åº”çš„å…ƒç´ ã€‚

**ä»£ç **

ä¸‹é¢çš„ $\texttt{Python}$ ä»£ç éœ€è¦æ‰‹åŠ¨å¯¼å…¥ $\texttt{sortedcontainers}$ åº“ã€‚

```C++ [sol1-C++]
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) {
            return false;
        }

        // å·¦ä¾§æœ€å°å€¼
        int left_min = nums[0];
        // å³ä¾§æ‰€æœ‰å…ƒç´ 
        multiset<int> right_all;

        for (int k = 2; k < n; ++k) {
            right_all.insert(nums[k]);
        }

        for (int j = 1; j < n - 1; ++j) {
            if (left_min < nums[j]) {
                auto it = right_all.upper_bound(left_min);
                if (it != right_all.end() && *it < nums[j]) {
                    return true;
                }
            }
            left_min = min(left_min, nums[j]);
            right_all.erase(right_all.find(nums[j + 1]));
        }

        return false;
    }
};
```

```Java [sol1-Java]
class Solution {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return false;
        }

        // å·¦ä¾§æœ€å°å€¼
        int leftMin = nums[0];
        // å³ä¾§æ‰€æœ‰å…ƒç´ 
        TreeMap<Integer, Integer> rightAll = new TreeMap<Integer, Integer>();

        for (int k = 2; k < n; ++k) {
            rightAll.put(nums[k], rightAll.getOrDefault(nums[k], 0) + 1);
        }

        for (int j = 1; j < n - 1; ++j) {
            if (leftMin < nums[j]) {
                Integer next = rightAll.ceilingKey(leftMin + 1);
                if (next != null && next < nums[j]) {
                    return true;
                }
            }
            leftMin = Math.min(leftMin, nums[j]);
            rightAll.put(nums[j + 1], rightAll.get(nums[j + 1]) - 1);
            if (rightAll.get(nums[j + 1]) == 0) {
                rightAll.remove(nums[j + 1]);
            }
        }

        return false;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        
        # å·¦ä¾§æœ€å°å€¼
        left_min = nums[0]
        # å³ä¾§æ‰€æœ‰å…ƒç´ 
        right_all = SortedList(nums[2:])
        
        for j in range(1, n - 1):
            if left_min < nums[j]:
                index = right_all.bisect_right(left_min)
                if index < len(right_all) and right_all[index] < nums[j]:
                    return True
            left_min = min(left_min, nums[j])
            right_all.remove(nums[j + 1])

        return False
```

```go [sol1-Golang]
import "math/rand"

type node struct {
    ch       [2]*node
    priority int
    val      int
    cnt      int
}

func (o *node) cmp(b int) int {
    switch {
    case b < o.val:
        return 0
    case b > o.val:
        return 1
    default:
        return -1
    }
}

func (o *node) rotate(d int) *node {
    x := o.ch[d^1]
    o.ch[d^1] = x.ch[d]
    x.ch[d] = o
    return x
}

type treap struct {
    root *node
}

func (t *treap) _put(o *node, val int) *node {
    if o == nil {
        return &node{priority: rand.Int(), val: val, cnt: 1}
    }
    if d := o.cmp(val); d >= 0 {
        o.ch[d] = t._put(o.ch[d], val)
        if o.ch[d].priority > o.priority {
            o = o.rotate(d ^ 1)
        }
    } else {
        o.cnt++
    }
    return o
}

func (t *treap) put(val int) {
    t.root = t._put(t.root, val)
}

func (t *treap) _delete(o *node, val int) *node {
    if o == nil {
        return nil
    }
    if d := o.cmp(val); d >= 0 {
        o.ch[d] = t._delete(o.ch[d], val)
        return o
    }
    if o.cnt > 1 {
        o.cnt--
        return o
    }
    if o.ch[1] == nil {
        return o.ch[0]
    }
    if o.ch[0] == nil {
        return o.ch[1]
    }
    d := 0
    if o.ch[0].priority > o.ch[1].priority {
        d = 1
    }
    o = o.rotate(d)
    o.ch[d] = t._delete(o.ch[d], val)
    return o
}

func (t *treap) delete(val int) {
    t.root = t._delete(t.root, val)
}

func (t *treap) upperBound(val int) (ub *node) {
    for o := t.root; o != nil; {
        if o.cmp(val) == 0 {
            ub = o
            o = o.ch[0]
        } else {
            o = o.ch[1]
        }
    }
    return
}

func find132pattern(nums []int) bool {
    n := len(nums)
    if n < 3 {
        return false
    }

    leftMin := nums[0]
    rights := &treap{}
    for _, v := range nums[2:] {
        rights.put(v)
    }

    for j := 1; j < n-1; j++ {
        if nums[j] > leftMin {
            ub := rights.upperBound(leftMin)
            if ub != nil && ub.val < nums[j] {
                return true
            }
        } else {
            leftMin = nums[j]
        }
        rights.delete(nums[j+1])
    }

    return false
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$ã€‚åœ¨åˆå§‹åŒ–æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ $O(n \log n)$ çš„æ—¶é—´å°†æ•°ç»„å…ƒç´  $a[2..n-1]$ åŠ å…¥æœ‰åºé›†åˆä¸­ã€‚åœ¨æšä¸¾ $j$ æ—¶ï¼Œç»´æŠ¤å·¦ä¾§å…ƒç´ æœ€å°å€¼çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ï¼Œå°† $a[j+1]$ ä»æœ‰åºé›†åˆä¸­åˆ é™¤çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ï¼Œæ€»å…±éœ€è¦æšä¸¾çš„æ¬¡æ•°ä¸º $O(n)$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºæœ‰åºé›†åˆå­˜å‚¨å³ä¾§æ‰€æœ‰å…ƒç´ éœ€è¦ä½¿ç”¨çš„ç©ºé—´ã€‚

#### æ–¹æ³•äºŒï¼šæšä¸¾ $1$

**æ€è·¯ä¸ç®—æ³•**

å¦‚æœæˆ‘ä»¬ä»å·¦åˆ°å³æšä¸¾ $1$ çš„ä¸‹æ ‡ $i$ï¼Œé‚£ä¹ˆ $j, k$ çš„ä¸‹æ ‡èŒƒå›´éƒ½æ˜¯å‡å°‘çš„ï¼Œè¿™æ ·å°±ä¸åˆ©äºå¯¹å®ƒä»¬è¿›è¡Œç»´æŠ¤ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è€ƒè™‘ä»å³åˆ°å·¦æšä¸¾ $i$ã€‚

é‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å¦‚ä½•ç»´æŠ¤ $j, k$ å‘¢ï¼Ÿåœ¨ $132$ æ¨¡å¼ä¸­ï¼Œå¦‚æœ $1<2$ å¹¶ä¸” $2<3$ï¼Œé‚£ä¹ˆæ ¹æ®ä¼ é€’æ€§ï¼Œ$1<3$ ä¹Ÿæ˜¯æˆç«‹çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹æ³•è¿›è¡Œç»´æŠ¤ï¼š

- æˆ‘ä»¬ä½¿ç”¨ä¸€ç§æ•°æ®ç»“æ„ç»´æŠ¤æ‰€æœ‰éå†è¿‡çš„å…ƒç´ ï¼Œå®ƒä»¬ä½œä¸º $2$ çš„å€™é€‰å…ƒç´ ã€‚æ¯å½“æˆ‘ä»¬éå†åˆ°ä¸€ä¸ªæ–°çš„å…ƒç´ æ—¶ï¼Œå°±å°†å…¶åŠ å…¥æ•°æ®ç»“æ„ä¸­ï¼›

- åœ¨éå†åˆ°ä¸€ä¸ªæ–°çš„å…ƒç´ çš„åŒæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘å…¶æ˜¯å¦å¯ä»¥ä½œä¸º $3$ã€‚å¦‚æœå®ƒä½œä¸º $3$ï¼Œé‚£ä¹ˆ**æ•°æ®ç»“æ„ä¸­æ‰€æœ‰ä¸¥æ ¼å°äºå®ƒçš„å…ƒç´ éƒ½å¯ä»¥ä½œä¸º $2$**ï¼Œæˆ‘ä»¬å°†è¿™äº›å…ƒç´ å…¨éƒ¨ä»æ•°æ®ç»“æ„ä¸­ç§»é™¤ï¼Œå¹¶ä¸”ä½¿ç”¨ä¸€ä¸ªå˜é‡ç»´æŠ¤**æ‰€æœ‰è¢«ç§»é™¤çš„å…ƒç´ çš„æœ€å¤§å€¼**ã€‚è¿™äº›è¢«ç§»é™¤çš„å…ƒç´ éƒ½æ˜¯å¯ä»¥çœŸæ­£ä½œä¸º $2$ çš„ï¼Œå¹¶ä¸”å…ƒç´ çš„å€¼è¶Šå¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹‹åæ‰¾åˆ° $1$ çš„æœºä¼šä¹Ÿå°±è¶Šå¤§ã€‚

é‚£ä¹ˆè¿™ä¸ªã€Œæ•°æ®ç»“æ„ã€æ˜¯ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å‘¢ï¼Ÿæˆ‘ä»¬å°è¯•æå–å‡ºå®ƒè¿›è¡Œçš„æ“ä½œï¼š

- å®ƒéœ€è¦æ”¯æŒæ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼›

- å®ƒéœ€è¦æ”¯æŒç§»é™¤æ‰€æœ‰ä¸¥æ ¼å°äºç»™å®šé˜ˆå€¼çš„æ‰€æœ‰å…ƒç´ ï¼›

- ä¸Šé¢ä¸¤æ­¥æ“ä½œæ˜¯ã€Œä¾æ¬¡è¿›è¡Œã€çš„ï¼Œå³æˆ‘ä»¬å…ˆç”¨ç»™å®šçš„é˜ˆå€¼ç§»é™¤å…ƒç´ ï¼Œå†å°†è¯¥é˜ˆå€¼åŠ å…¥æ•°æ®ç»“æ„ä¸­ã€‚

è¿™å°±æ˜¯ã€Œå•è°ƒæ ˆã€ã€‚åœ¨å•è°ƒæ ˆä¸­ï¼Œä»æ ˆåº•åˆ°æ ˆé¡¶çš„å…ƒç´ æ˜¯ä¸¥æ ¼å•è°ƒé€’å‡çš„ã€‚å½“ç»™å®šé˜ˆå€¼ $x$ æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸æ–­åœ°å¼¹å‡ºæ ˆé¡¶çš„å…ƒç´ ï¼Œç›´åˆ°æ ˆä¸ºç©ºæˆ–è€… $x$ ä¸¥æ ¼å°äºæ ˆé¡¶å…ƒç´ ã€‚æ­¤æ—¶æˆ‘ä»¬å†å°† $x$ å…¥æ ˆï¼Œè¿™æ ·å°±ç»´æŠ¤äº†æ ˆçš„å•è°ƒæ€§ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å•è°ƒæ ˆä½œä¸ºç»´æŠ¤ $2$ çš„æ•°æ®ç»“æ„ï¼Œå¹¶ç»™å‡ºä¸‹é¢çš„ç®—æ³•ï¼š

- æˆ‘ä»¬ç”¨å•è°ƒæ ˆç»´æŠ¤æ‰€æœ‰å¯ä»¥ä½œä¸º $2$ çš„å€™é€‰å…ƒç´ ã€‚åˆå§‹æ—¶ï¼Œå•è°ƒæ ˆä¸­åªæœ‰å”¯ä¸€çš„å…ƒç´  $\textit{a}[n-1]$ã€‚æˆ‘ä»¬è¿˜éœ€è¦ä½¿ç”¨ä¸€ä¸ªå˜é‡ $\textit{max\_k}$ è®°å½•æ‰€æœ‰å¯ä»¥çœŸæ­£ä½œä¸º $2$ çš„å…ƒç´ çš„æœ€å¤§å€¼ï¼›

- éšåæˆ‘ä»¬ä» $n-2$ å¼€å§‹ä»å³åˆ°å·¦æšä¸¾å…ƒç´  $a[i]$ï¼š

    - é¦–å…ˆæˆ‘ä»¬åˆ¤æ–­ $a[i]$ æ˜¯å¦å¯ä»¥ä½œä¸º $1$ã€‚å¦‚æœ $a[i] < \textit{max\_k}$ï¼Œé‚£ä¹ˆå®ƒå°±å¯ä»¥ä½œä¸º $1$ï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ç»„æ»¡è¶³ $132$ æ¨¡å¼çš„ä¸‰å…ƒç»„ï¼›

    - éšåæˆ‘ä»¬åˆ¤æ–­ $a[i]$ æ˜¯å¦å¯ä»¥ä½œä¸º $3$ï¼Œä»¥æ­¤æ‰¾å‡ºå“ªäº›å¯ä»¥çœŸæ­£ä½œä¸º $2$ çš„å…ƒç´ ã€‚æˆ‘ä»¬å°† $a[i]$ ä¸æ–­åœ°ä¸å•è°ƒæ ˆæ ˆé¡¶çš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœ $a[i]$ è¾ƒå¤§ï¼Œé‚£ä¹ˆæ ˆé¡¶å…ƒç´ å¯ä»¥çœŸæ­£ä½œä¸º $2$ï¼Œå°†å…¶å¼¹å‡ºå¹¶æ›´æ–° $\textit{max\_k}$ï¼›

    - æœ€åæˆ‘ä»¬å°† $a[i]$ ä½œä¸º $2$ çš„å€™é€‰å…ƒç´ æ”¾å…¥å•è°ƒæ ˆä¸­ã€‚è¿™é‡Œå¯ä»¥è¿›è¡Œä¸€ä¸ªä¼˜åŒ–ï¼Œå³å¦‚æœ $a[i] \leq \textit{max\_k}$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹Ÿæ²¡æœ‰å¿…è¦å°† $a[i]$ æ”¾å…¥æ ˆä¸­ï¼Œå› ä¸ºå³ä½¿å®ƒåœ¨æœªæ¥è¢«å¼¹å‡ºï¼Œä¹Ÿä¸ä¼šå°† $\textit{max\_k}$ æ›´æ–°ä¸ºæ›´å¤§çš„å€¼ã€‚

- åœ¨æšä¸¾å®Œæ‰€æœ‰çš„å…ƒç´ åï¼Œå¦‚æœä»æœªæ‰¾åˆ°æ»¡è¶³ $132$ æ¨¡å¼çš„ä¸‰å…ƒç»„ï¼Œé‚£å°±è¯´æ˜å…¶ä¸å­˜åœ¨ã€‚

**ä»£ç **

```C++ [sol2-C++]
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size();
        stack<int> candidate_k;
        candidate_k.push(nums[n - 1]);
        int max_k = INT_MIN;

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < max_k) {
                return true;
            }
            while (!candidate_k.empty() && nums[i] > candidate_k.top()) {
                max_k = candidate_k.top();
                candidate_k.pop();
            }
            if (nums[i] > max_k) {
                candidate_k.push(nums[i]);
            }
        }

        return false;
    }
};
```

```Java [sol2-Java]
class Solution {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;
        Deque<Integer> candidateK = new LinkedList<Integer>();
        candidateK.push(nums[n - 1]);
        int maxK = Integer.MIN_VALUE;

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < maxK) {
                return true;
            }
            while (!candidateK.isEmpty() && nums[i] > candidateK.peek()) {
                maxK = candidateK.pop();
            }
            if (nums[i] > maxK) {
                candidateK.push(nums[i]);
            }
        }

        return false;
    }
}
```

```Python [sol2-Python3]
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        candidate_k = [nums[n - 1]]
        max_k = float("-inf")

        for i in range(n - 2, -1, -1):
            if nums[i] < max_k:
                return True
            while candidate_k and nums[i] > candidate_k[-1]:
                max_k = candidate_k[-1]
                candidate_k.pop()
            if nums[i] > max_k:
                candidate_k.append(nums[i])

        return False
```

```JavaScript [sol2-JavaScript]
var find132pattern = function(nums) {
    const n = nums.length;
    const candidate_k = [nums[n - 1]];
    let max_k = -Number.MAX_SAFE_INTEGER;

    for (let i = n - 2; i >= 0; --i) {
        if (nums[i] < max_k) {
            return true;
        }
        while (candidate_k.length && nums[i] > candidate_k[candidate_k.length - 1]) {
            max_k = candidate_k[candidate_k.length - 1];
            candidate_k.pop();
        }
        if (nums[i] > max_k) {
            candidate_k.push(nums[i]);
        }
    }
    return false;
};
```

```go [sol2-Golang]
func find132pattern(nums []int) bool {
    n := len(nums)
    candidateK := []int{nums[n-1]}
    maxK := math.MinInt64

    for i := n - 2; i >= 0; i-- {
        if nums[i] < maxK {
            return true
        }
        for len(candidateK) > 0 && nums[i] > candidateK[len(candidateK)-1] {
            maxK = candidateK[len(candidateK)-1]
            candidateK = candidateK[:len(candidateK)-1]
        }
        if nums[i] > maxK {
            candidateK = append(candidateK, nums[i])
        }
    }

    return false
}
```

```C [sol2-C]
bool find132pattern(int* nums, int numsSize) {
    int n = numsSize;
    int candidate_k[n], top = 0;
    candidate_k[top++] = nums[n - 1];
    int max_k = INT_MIN;

    for (int i = n - 2; i >= 0; --i) {
        if (nums[i] < max_k) {
            return true;
        }
        while (top && nums[i] > candidate_k[top - 1]) {
            max_k = candidate_k[--top];
        }
        if (nums[i] > max_k) {
            candidate_k[top++] = nums[i];
        }
    }

    return false;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œæšä¸¾ $i$ çš„æ¬¡æ•°ä¸º $O(n)$ï¼Œç”±äºæ¯ä¸€ä¸ªå…ƒç´ æœ€å¤šè¢«åŠ å…¥å’Œå¼¹å‡ºå•è°ƒæ ˆå„ä¸€æ¬¡ï¼Œå› æ­¤æ“ä½œå•è°ƒæ ˆçš„æ—¶é—´å¤æ‚åº¦ä¸€å…±ä¸º $O(n)$ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºå•è°ƒæ ˆéœ€è¦ä½¿ç”¨çš„ç©ºé—´ã€‚

#### æ–¹æ³•ä¸‰ï¼šæšä¸¾ $2$

**è¯´æ˜**

æ–¹æ³•ä¸‰æ€è·¯éš¾åº¦è¾ƒå¤§ï¼Œéœ€è¦åœ¨å•è°ƒæ ˆä¸Šè¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ã€‚å»ºè®®è¯»è€…åœ¨å®Œå…¨ç†è§£æ–¹æ³•äºŒä¹‹åï¼Œå†å°è¯•é˜…è¯»è¯¥æ–¹æ³•ã€‚

**æ€è·¯ä¸ç®—æ³•**

å½“æˆ‘ä»¬æšä¸¾ $2$ çš„ä¸‹æ ‡ $k$ æ—¶ï¼Œä¸æ–¹æ³•äºŒç›¸åï¼Œä»å·¦åˆ°å³è¿›è¡Œæšä¸¾çš„æ–¹æ³•æ˜¯ååˆ†åˆç†çš„ï¼šåœ¨æšä¸¾çš„è¿‡ç¨‹ä¸­ï¼Œ$i, j$ çš„ä¸‹æ ‡èŒƒå›´éƒ½æ˜¯å¢åŠ çš„ã€‚

ç”±äºæˆ‘ä»¬éœ€è¦ä¿è¯ $1<2$ å¹¶ä¸” $2<3$ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ç»´æŠ¤ä¸€ç³»åˆ—å°½å¯èƒ½å°çš„å…ƒç´ ä½œä¸º $1$ çš„å€™é€‰å…ƒç´ ï¼Œå¹¶ä¸”ç»´æŠ¤ä¸€ç³»åˆ—å°½å¯èƒ½å¤§çš„å…ƒç´ ä½œä¸º $3$ çš„å€™é€‰å…ƒç´ ã€‚

æˆ‘ä»¬å¯ä»¥åˆ†æƒ…å†µè¿›è¡Œè®¨è®ºï¼Œå‡è®¾å½“å‰æœ‰ä¸€ä¸ªå°å…ƒç´  $x_i$ ä»¥åŠä¸€ä¸ªå¤§å…ƒç´  $x_j$ è¡¨ç¤ºä¸€ä¸ªäºŒå…ƒç»„ï¼Œè€Œæˆ‘ä»¬å½“å‰éå†åˆ°äº†ä¸€ä¸ªæ–°çš„å…ƒç´  $x=a[k]$ï¼Œé‚£ä¹ˆï¼š

- å¦‚æœ $x > x_j$ï¼Œé‚£ä¹ˆè®© $x$ ä½œä¸º $3$ æ˜¾ç„¶æ˜¯æ¯” $x_j$ ä½œä¸º $3$ æ›´ä¼˜ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨ $x$ æ›¿ä»£ $x_j$ï¼›

- å¦‚æœ $x < x_i$ï¼Œé‚£ä¹ˆè®© $x$ ä½œä¸º $1$ æ˜¾ç„¶æ˜¯æ¯” $x_i$ ä½œä¸º $3$ æ›´ä¼˜ï¼Œç„¶è€Œæˆ‘ä»¬å¿…é¡»è¦æ»¡è¶³ $132$ æ¨¡å¼ä¸­çš„é¡ºåºï¼Œå³ $1$ å‡ºç°åœ¨ $3$ ä¹‹å‰ï¼Œè¿™é‡Œå¦‚æœæˆ‘ä»¬ç®€å•åœ°ç”¨ $x$ æ›¿ä»£ $x_i$ï¼Œé‚£ä¹ˆ $x_i=x$ ä½œä¸º $1$ æ˜¯å‡ºç°åœ¨ $x_j$ ä½œä¸º $3$ ä¹‹åçš„ï¼Œè¿™å¹¶ä¸æ»¡è¶³è¦æ±‚ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦ä¸º $x$ æ‰¾ä¸€ä¸ªæ–°çš„å…ƒç´ ä½œä¸º $3$ã€‚ç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰éå†åˆ°åé¢çš„å…ƒç´ ï¼Œå› æ­¤å¯ä»¥ç®€å•åœ°å°† $x$ åŒæ—¶çœ‹ä½œä¸€ä¸ªäºŒå…ƒç»„çš„ $x_i$ å’Œ $x_j$ï¼›

- å¯¹äºå…¶å®ƒçš„æƒ…å†µï¼Œ$x_i \leq x \leq x_j$ï¼Œ$x$ æ— è®ºä½œä¸º $1$ è¿˜æ˜¯ $3$ éƒ½æ²¡æœ‰å½“å‰äºŒå…ƒç»„å¯¹åº”çš„è¦ä¼˜ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ç”¨è€ƒè™‘ $x$ ä½œä¸º $1$ æˆ–è€… $3$ çš„æƒ…å†µã€‚

è¿™æ ·ä¸€æ¥ï¼Œä¸æ–¹æ³•äºŒç±»ä¼¼ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªå•è°ƒé€’å‡çš„å•è°ƒæ ˆç»´æŠ¤ä¸€ç³»åˆ—äºŒå…ƒç»„ $(x_i, x_j)$ï¼Œè¡¨ç¤ºä¸€ä¸ªå¯ä»¥é€‰æ‹©çš„ $1-3$ åŒºé—´ï¼Œå¹¶ä¸”ä»æ ˆåº•åˆ°æ ˆé¡¶ $x_i$ å’Œ $x_j$ åˆ†åˆ«ä¸¥æ ¼å•è°ƒé€’å‡ï¼Œå› ä¸ºæ ¹æ®ä¸Šé¢çš„è®¨è®ºï¼Œæˆ‘ä»¬åªæœ‰åœ¨ $x < x_i$ æ—¶æ‰ä¼šå¢åŠ ä¸€ä¸ªæ–°çš„äºŒå…ƒç»„ã€‚

ç„¶è€Œä¸æ–¹æ³•äºŒä¸åŒçš„æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è®© $x$ ä½œä¸º $2$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¹¶ä¸çŸ¥é“åˆ°åº•åº”è¯¥é€‰æ‹©å•è°ƒæ ˆä¸­çš„å“ªä¸ª $1-3$ åŒºé—´ï¼Œå› æ­¤æˆ‘ä»¬åªèƒ½æ ¹æ®å•è°ƒæ€§è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼š

- å¯¹äºå•è°ƒæ ˆä¸­çš„ $x_i$ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾å‡ºç¬¬ä¸€ä¸ªæ»¡è¶³ $x_i < x$ çš„ä½ç½® $\textit{idx}_i$ï¼Œè¿™æ ·ä»è¯¥ä½ç½®åˆ°æ ˆé¡¶çš„æ‰€æœ‰äºŒå…ƒç»„éƒ½æ»¡è¶³ $x_i < x$ï¼›

- å¯¹äºå•è°ƒæ ˆä¸­çš„ $x_j$ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾å‡ºæœ€åä¸€ä¸ªæ»¡è¶³ $x_j > x$ çš„ä½ç½® $\textit{idx}_j$ï¼Œè¿™æ ·ä»æ ˆåº•åˆ°è¯¥ä½ç½®çš„æ‰€æœ‰äºŒå…ƒç»„éƒ½æ»¡è¶³ $x_j > x$ï¼›

- å¦‚æœ $\textit{idx}_i$ å’Œ $\textit{idx}_j$ éƒ½å­˜åœ¨ï¼Œå¹¶ä¸” $\textit{idx}_i \leq \textit{idx}_j$ï¼Œé‚£ä¹ˆå°±å­˜åœ¨è‡³å°‘ä¸€ä¸ªäºŒå…ƒç»„ $(x_i, x_j)$ æ»¡è¶³ $x_i < x < x_j$ï¼Œ$x$ å°±å¯ä»¥ä½œä¸º $2$ï¼Œæˆ‘ä»¬å°±æ‰¾åˆ°äº†ä¸€ç»„æ»¡è¶³ $132$ æ¨¡å¼çš„ä¸‰å…ƒç»„ã€‚

åœ¨æšä¸¾å®Œæ‰€æœ‰çš„å…ƒç´ åï¼Œå¦‚æœä»æœªæ‰¾åˆ°æ»¡è¶³ $132$ æ¨¡å¼çš„ä¸‰å…ƒç»„ï¼Œé‚£å°±è¯´æ˜å…¶ä¸å­˜åœ¨ã€‚

**ä»£ç **

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬æ˜¯åœ¨**å•è°ƒé€’å‡çš„æ ˆä¸Šè¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾**ï¼Œå› æ­¤å¤§éƒ¨åˆ†è¯­è¨€éƒ½éœ€è¦å®ç°ä¸€ä¸ªè‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œæˆ–è€…å°†æ ˆä¸­çš„å…ƒç´ å–ç›¸åæ•°åå†ä½¿ç”¨é»˜è®¤çš„æ¯”è¾ƒå‡½æ•°ã€‚

```C++ [sol3-C++]
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size();
        vector<int> candidate_i = {nums[0]};
        vector<int> candidate_j = {nums[0]};

        for (int k = 1; k < n; ++k) {
            auto it_i = upper_bound(candidate_i.begin(), candidate_i.end(), nums[k], greater<int>());
            auto it_j = lower_bound(candidate_j.begin(), candidate_j.end(), nums[k], greater<int>());
            if (it_i != candidate_i.end() && it_j != candidate_j.begin()) {
                int idx_i = it_i - candidate_i.begin();
                int idx_j = it_j - candidate_j.begin() - 1;
                if (idx_i <= idx_j) {
                    return true;
                }
            }
            
            if (nums[k] < candidate_i.back()) {
                candidate_i.push_back(nums[k]);
                candidate_j.push_back(nums[k]);
            }
            else if (nums[k] > candidate_j.back()) {
                int last_i = candidate_i.back();
                while (!candidate_j.empty() && nums[k] > candidate_j.back()) {
                    candidate_i.pop_back();
                    candidate_j.pop_back();
                }
                candidate_i.push_back(last_i);
                candidate_j.push_back(nums[k]);
            }
        }

        return false;
    }
};
```

```Java [sol3-Java]
class Solution {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;
        List<Integer> candidateI = new ArrayList<Integer>();
        candidateI.add(nums[0]);
        List<Integer> candidateJ = new ArrayList<Integer>();
        candidateJ.add(nums[0]);

        for (int k = 1; k < n; ++k) {
            int idxI = binarySearchFirst(candidateI, nums[k]);
            int idxJ = binarySearchLast(candidateJ, nums[k]);
            if (idxI >= 0 && idxJ >= 0) {
                if (idxI <= idxJ) {
                    return true;
                }
            }
            
            if (nums[k] < candidateI.get(candidateI.size() - 1)) {
                candidateI.add(nums[k]);
                candidateJ.add(nums[k]);
            } else if (nums[k] > candidateJ.get(candidateJ.size() - 1)) {
                int lastI = candidateI.get(candidateI.size() - 1);
                while (!candidateJ.isEmpty() && nums[k] > candidateJ.get(candidateJ.size() - 1)) {
                    candidateI.remove(candidateI.size() - 1);
                    candidateJ.remove(candidateJ.size() - 1);
                }
                candidateI.add(lastI);
                candidateJ.add(nums[k]);
            }
        }

        return false;
    }

    public int binarySearchFirst(List<Integer> candidate, int target) {
        int low = 0, high = candidate.size() - 1;
        if (candidate.get(high) >= target) {
            return -1;
        }
        while (low < high) {
            int mid = (high - low) / 2 + low;
            int num = candidate.get(mid);
            if (num >= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public int binarySearchLast(List<Integer> candidate, int target) {
        int low = 0, high = candidate.size() - 1;
        if (candidate.get(low) <= target) {
            return -1;
        }
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            int num = candidate.get(mid);
            if (num <= target) {
                high = mid - 1;
            } else {
                low = mid;
            }
        }
        return low;
    }
}
```

```Python [sol3-Python3]
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        candidate_i, candidate_j = [-nums[0]], [-nums[0]]

        for v in nums[1:]:
            idx_i = bisect.bisect_right(candidate_i, -v)
            idx_j = bisect.bisect_left(candidate_j, -v)
            if idx_i < idx_j:
                return True

            if v < -candidate_i[-1]:
                candidate_i.append(-v)
                candidate_j.append(-v)
            elif v > -candidate_j[-1]:
                last_i = -candidate_i[-1]
                while candidate_j and v > -candidate_j[-1]:
                    candidate_i.pop()
                    candidate_j.pop()
                candidate_i.append(-last_i)
                candidate_j.append(-v)

        return False
```

```JavaScript [sol3-JavaScript]
var find132pattern = function(nums) {
    const n = nums.length;
    const candidateI = [nums[0]], candidateJ = [nums[0]];

    for (let k = 1; k < n; ++k) {
        const idxI = binarySearchFirst(candidateI, nums[k]);
        const idxJ = binarySearchLast(candidateJ, nums[k]);
        if (idxI >= 0 && idxJ >= 0) {
            if (idxI <= idxJ) {
                return true;
            }
        }
        
        if (nums[k] < candidateI[candidateI.length - 1]) {
            candidateI.push(nums[k]);
            candidateJ.push(nums[k]);
        } else if (nums[k] > candidateJ[candidateJ.length - 1]) {
            const lastI = candidateI[candidateI.length - 1];
            while (candidateJ.length && nums[k] > candidateJ[candidateJ.length - 1]) {
                candidateI.pop();
                candidateJ.pop();
            }
            candidateI.push(lastI);
            candidateJ.push(nums[k]);
        }
    }

    return false;
};

const binarySearchFirst = (candidate, target) => {
    let low = 0, high = candidate.length - 1;
    if (candidate[high] >= target) {
        return -1;
    }
    while (low < high) {
        const mid = Math.floor((high - low) / 2) + low;
        const num = candidate[mid];
        if (num >= target) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

const binarySearchLast = (candidate, target) => {
    let low = 0, high = candidate.length - 1;
    if (candidate[low] <= target) {
        return -1;
    }
    while (low < high) {
        const mid = Math.floor((high - low + 1) / 2) + low;
        const num = candidate[mid];
        if (num <= target) {
            high = mid - 1;
        } else {
            low = mid;
        }
    }
    return low;
}
```

```go [sol3-Golang]
func find132pattern(nums []int) bool {
    candidateI, candidateJ := []int{-nums[0]}, []int{-nums[0]}

    for _, v := range nums[1:] {
        idxI := sort.SearchInts(candidateI, 1-v)
        idxJ := sort.SearchInts(candidateJ, -v)
        if idxI < idxJ {
            return true
        }

        if v < -candidateI[len(candidateI)-1] {
            candidateI = append(candidateI, -v)
            candidateJ = append(candidateJ, -v)
        } else if v > -candidateJ[len(candidateJ)-1] {
            lastI := -candidateI[len(candidateI)-1]
            for len(candidateJ) > 0 && v > -candidateJ[len(candidateJ)-1] {
                candidateI = candidateI[:len(candidateI)-1]
                candidateJ = candidateJ[:len(candidateJ)-1]
            }
            candidateI = append(candidateI, -lastI)
            candidateJ = append(candidateJ, -v)
        }
    }

    return false
}
```

```C [sol3-C]
int upper_bound(int* vec, int vecSize, int target) {
    int low = 0, high = vecSize - 1;
    if (vec[high] >= target) {
        return -1;
    }
    while (low < high) {
        int mid = (high - low) / 2 + low;
        int num = vec[mid];
        if (num >= target) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}

int lower_bound(int* vec, int vecSize, int target) {
    int low = 0, high = vecSize - 1;
    if (vec[low] <= target) {
        return -1;
    }
    while (low < high) {
        int mid = (high - low + 1) / 2 + low;
        int num = vec[mid];
        if (num <= target) {
            high = mid - 1;
        } else {
            low = mid;
        }
    }
    return low;
}

bool find132pattern(int* nums, int numsSize) {
    int n = numsSize;
    int candidate_i[n], top_i = 0;
    int candidate_j[n], top_j = 0;
    candidate_i[top_i++] = nums[0];
    candidate_j[top_j++] = nums[0];

    for (int k = 1; k < n; ++k) {
        int it_i = upper_bound(candidate_i, top_i, nums[k]);
        int it_j = lower_bound(candidate_j, top_j, nums[k]);
        if (it_i != -1 && it_j != -1) {
            if (it_i <= it_j) {
                return true;
            }
        }

        if (nums[k] < candidate_i[top_i - 1]) {
            candidate_i[top_i++] = nums[k];
            candidate_j[top_j++] = nums[k];
        } else if (nums[k] > candidate_j[top_j - 1]) {
            int last_i = candidate_i[top_i - 1];
            while (top_j && nums[k] > candidate_j[top_j - 1]) {
                top_j--, top_i--;
            }
            candidate_i[top_i++] = last_i;
            candidate_j[top_j++] = nums[k];
        }
    }

    return false;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$ï¼Œæšä¸¾ $i$ çš„æ¬¡æ•°ä¸º $O(n)$ï¼Œç”±äºæ¯ä¸€ä¸ªå…ƒç´ æœ€å¤šè¢«åŠ å…¥å’Œå¼¹å‡ºå•è°ƒæ ˆå„ä¸€æ¬¡ï¼Œå› æ­¤æ“ä½œå•è°ƒæ ˆçš„æ—¶é—´å¤æ‚åº¦ä¸€å…±ä¸º $O(n)$ã€‚äºŒåˆ†æŸ¥æ‰¾çš„å•æ¬¡æ—¶é—´ä¸º $O(\log n)$ï¼Œä¸€å…±ä¸º $O(n \log n)$ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºå•è°ƒæ ˆéœ€è¦ä½¿ç”¨çš„ç©ºé—´ã€‚


#### ç»“è¯­

åœ¨ä¸Šé¢çš„ä¸‰ç§æ–¹æ³•ä¸­ï¼Œæ–¹æ³•äºŒçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œæœ€ä¼˜ç§€ã€‚è€Œå‰©ä½™çš„ä¸¤ç§æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log n)$ çš„æ–¹æ³•ä¸­ï¼Œæ–¹æ³•ä¸€ç›¸è¾ƒäºæ–¹æ³•ä¸‰ï¼Œæ— è®ºä»ç†è§£è¿˜æ˜¯ä»£ç ç¼–å†™å±‚é¢æ¥è¯´éƒ½æ›´å®¹æ˜“ä¸€äº›ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆè¿˜è¦ä»‹ç»æ–¹æ³•ä¸‰å‘¢ï¼Ÿè¿™é‡Œæˆ‘ä»¬å¯ä»¥å‘ç°æ–¹æ³•ä¸€å’Œæ–¹æ³•äºŒçš„ä¸è¶³ï¼š

- æ–¹æ³•ä¸€éœ€è¦æå‰çŸ¥é“æ•´ä¸ªæ•°ç»„ï¼Œå¦åˆ™å°±æ— æ³•ä½¿ç”¨æœ‰åºé›†åˆç»´æŠ¤å³ä¾§å…ƒç´ äº†ï¼›

- æ–¹æ³•äºŒæ˜¯ä»åå‘å‰éå†çš„ï¼Œæœ¬è´¨ä¸Šä¹ŸåŒæ ·éœ€è¦æå‰çŸ¥é“æ•´ä¸ªæ•°ç»„ã€‚

è€Œæ–¹æ³•ä¸‰æ˜¯ä»å‰å‘åéå†çš„ï¼Œå¹¶ä¸”ç»´æŠ¤çš„æ•°æ®ç»“æ„ä¸ä¾èµ–äºåç»­æœªçŸ¥çš„å…ƒç´ ï¼Œå› æ­¤å¦‚æœæ•°ç»„æ˜¯ä»¥ã€Œæ•°æ®æµã€çš„å½¢å¼ç»™å‡ºçš„ï¼Œé‚£ä¹ˆæ–¹æ³•ä¸‰æ˜¯å”¯ä¸€å¯ä»¥ç»§ç»­ä½¿ç”¨çš„æ–¹æ³•ã€‚