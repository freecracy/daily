# 2021年03月17日 code
<a href="https://toutiao.io/k/5apgnxp">Java 工程师核心书单，阿里大佬看了都说好</a><br /><a href="https://toutiao.io/k/8e56qh6">职场：跳槽之后，如何平稳走过试用期</a><br /><a href="https://toutiao.io/k/yl7s9sl">算法面试套路知多少</a><br /><a href="https://toutiao.io/k/mqykus9">生活中常用的支付知识</a><br /><a href="https://toutiao.io/k/v0zfydk">被抛弃的 WebDAV，从未有过青春</a><br /><a href="https://toutiao.io/k/zqqw9qt">Go 群友提问：Goroutine 数量控制在多少合适，会影响 GC 和调度？</a><br /><a href="https://toutiao.io/k/kqc64mp">Netty 源码解析：内存池与 PoolArena</a><br /><a href="https://toutiao.io/k/kzhmmve">独立开发者如何快速从 0 到 1 设计一款 App 的 Logo：配置 Sketch 工具</a><br /><a href="https://toutiao.io/k/yrx9gx7">如何解决大分页查询问题？</a><br /><a href="https://toutiao.io/k/nas7b1m">内向不应该被误解</a><br /><a href="https://toutiao.io/k/byzy2w2">应用容灾中，MySQL 数据表是否需要跨云同步？</a><br /><a href="https://toutiao.io/k/qqqr167">电商指标详细介绍和推荐系统常用评估指标</a><br /><a href="https://toutiao.io/k/slqcflm">修改 Spring Boot 项目的 Parent</a><br /><a href="https://toutiao.io/k/6q0dh54">原理都懂，就是不会建模？来，顶尖数据模型走一波（上）</a><br /><a href="https://toutiao.io/k/gk2gu8j">Koa 核心扩展：中间件机制</a><br /><a href="https://toutiao.io/k/tsohi4b">面试官：啥？SynchronousQueue 是钟？点？房？</a><br /><a href="https://toutiao.io/k/bwryqwa">PHP 远程调试最佳实践</a><br /><a href="https://toutiao.io/k/bc4qp5g">夺取应用程序的 “制空权”：内存数据</a><br /><a href="https://toutiao.io/k/8vc4s7u">小程序 TypeScript 最佳实践</a><br /><a href="https://toutiao.io/k/v4j2rho">漫画｜程序员：大师，有些东西我放不下...</a><br /><a href="https://toutiao.io/k/nd37i31">青云科技黄允松：坚持创新，做难而正确的事</a><br /><a href="https://toutiao.io/k/txzl2gg">[推荐] 2021 阿里淘系工程师推荐书单</a><br /><a href="https://toutiao.io/k/44rsmt3">[推荐] [译] 构建微服务的十大 Go 框架/库</a><br /><a href="https://toutiao.io/k/kldrkzc">[推荐] Tomcat 性能调优应该注意什么？</a><br /><a href="https://toutiao.io/k/pmxukkm">[推荐] 面试被吊打：Redis 原理</a><br /><a href="https://toutiao.io/k/1d2mnjh">[推荐] 职场：3 天准备 5 天面试，跳槽完成</a><br /><a href="https://toutiao.io/k/0ic2o68">[推荐] 带你深入理解 Java 内存模型理论</a><br /><a href="https://toutiao.io/k/tm4wyb0">[推荐] Redis 专题：深入解读哨兵模式</a><br /><a href="https://toutiao.io/k/e3lq37o">[推荐] 2021 有哪些不容错过的后端技术趋势</a><br /><a href="https://toutiao.io/k/vmimc5g">[推荐] 聊聊 IT 技术人的知识体系</a><br /><a href="https://toutiao.io/k/ga340bq">[推荐] MySQL 读写分离，写完读不到问题如何解决</a><br /><a href="https://toutiao.io/k/av396i0">[推荐] Redis 教程：Redis 知识体系详解</a><br /><a href="https://toutiao.io/k/r5kgujp">[推荐] 从技术专家到技术管理，我对管理的思考</a><br /><a href="https://toutiao.io/k/671eano">[推荐] 快手超大规模集群调度优化实践</a><br /><a href="https://toutiao.io/k/yduqoev">[推荐] Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis</a><br /><a href="https://toutiao.io/k/r9tqaw3">[推荐] 副业刚需：在 GitHub 上也能年入百万？</a><br /><hr /><a href="https://github.com/DidierRLopes/GamestonkTerminal">The next best thing after Bloomberg Terminal</a><br /><a href="https://github.com/harskish/ganspace">Discovering Interpretable GAN Controls [NeurIPS 2020]</a><br /><a href="https://github.com/sundowndev/PhoneInfoga">Advanced information gathering & OSINT framework for phone numbers</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/flameshot-org/flameshot">Powerful yet simple to use screenshot software 🖥️ 📸</a><br /><a href="https://github.com/Ryujinx/Ryujinx">Experimental Nintendo Switch Emulator written in C#</a><br /><a href="https://github.com/google/security-research-pocs">Proof-of-concept codes created as part of security research done by Google Security Team.</a><br /><a href="https://github.com/sickcodes/osx-serial-generator">Mac Serial Generator - Generate complete sets of Serial Numbers for OSX-KVM, Docker-OSX and of course, OpenCore.</a><br /><a href="https://github.com/mentebinaria/retoolkit">Reverse Engineer's Toolkit</a><br /><a href="https://github.com/stefan-jansen/machine-learning-for-trading">Code and resources for Machine Learning for Algorithmic Trading, 2nd edition.</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/login?return_to=%2Foppia%2Foppia">A free, online learning platform to make quality education accessible for all.</a><br /><a href="https://github.com/beurtschipper/Depix">Recovers passwords from pixelized screenshots</a><br /><a href="https://github.com/bettercap/bettercap">The Swiss Army knife for 802.11, BLE and Ethernet networks reconnaissance and MITM attacks.</a><br /><a href="https://github.com/firstcontributions/first-contributions">🚀✨ Help beginners to contribute to open source projects</a><br /><a href="https://github.com/docker/awesome-compose">Awesome Docker Compose samples</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/goabstract/Awesome-Design-Tools">The best design tools and plugins for everything 👉</a><br /><a href="https://github.com/TheAlgorithms/C">Collection of various algorithms in mathematics, machine learning, computer science, physics, etc implemented in C for educational purposes.</a><br /><a href="https://github.com/lotusirous/go-concurrency-patterns">Concurrency patterns in Go</a><br /><a href="https://github.com/naman14/adb-tools-mac">Mac menu bar app for common adb tools</a><br /><a href="https://github.com/siduck76/neovim-dots">my neovim configs</a><br /><a href="https://github.com/sudheerj/reactjs-interview-questions">List of top 500 ReactJS Interview Questions & Answers....Coding exercise questions are coming soon!!</a><br /><a href="https://github.com/sickcodes/Docker-OSX">Run Mac in a Docker! Run near native OSX-KVM in Docker! X11 Forwarding! CI/CD for OS X!</a><br /><a href="https://github.com/facebook/rocksdb">A library that provides an embeddable, persistent key-value store for fast storage.</a><br /><hr />不同的子序列<br /><p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>

<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>"ACE"</code> 是 <code>"ABCDE"</code> 的一个子序列，而 <code>"AEC"</code> 不是）</p>

<p>题目数据保证答案符合 32 位带符号整数范围。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "rabbbit", t = "rabbit"<code>
<strong>输出</strong></code><strong>：</strong><code>3
</code><strong>解释：</strong>
如下图所示, 有 3 种可以从 s 中得到 <code>"rabbit" 的方案</code>。
(上箭头符号 ^ 表示选取的字母)
<code>rabbbit</code>
^^^^ ^^
<code>rabbbit</code>
^^ ^^^^
<code>rabbbit</code>
^^^ ^^^
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "babgbag", t = "bag"
<code><strong>输出</strong></code><strong>：</strong><code>5
</code><strong>解释：</strong>
如下图所示, 有 5 种可以从 s 中得到 <code>"bag" 的方案</code>。 
(上箭头符号 ^ 表示选取的字母)
<code>babgbag</code>
^^ ^
<code>babgbag</code>
^^    ^
<code>babgbag</code>
^    ^^
<code>babgbag</code>
  ^  ^^
<code>babgbag</code>
    ^^^</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 <= s.length, t.length <= 1000</code></li>
	<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<br />#### 方法一：动态规划

假设字符串 $s$ 和 $t$ 的长度分别为 $m$ 和 $n$。如果 $t$ 是 $s$ 的子序列，则 $s$ 的长度一定大于或等于 $t$ 的长度，即只有当 $m \ge n$ 时，$t$ 才可能是 $s$ 的子序列。如果 $m<n$，则 $t$ 一定不是 $s$ 的子序列，因此直接返回 $0$。

当 $m \ge n$ 时，可以通过动态规划的方法计算在 $s$ 的子序列中 $t$ 出现的个数。

创建二维数组 $\textit{dp}$，其中 $\textit{dp}[i][j]$ 表示在 $s[i:]$ 的子序列中 $t[j:]$ 出现的个数。

> 上述表示中，$s[i:]$ 表示 $s$ 从下标 $i$ 到末尾的子字符串，$t[j:]$ 表示 $t$ 从下标 $j$ 到末尾的子字符串。

考虑动态规划的边界情况：

- 当 $j=n$ 时，$t[j:]$ 为空字符串，由于空字符串是任何字符串的子序列，因此对任意 $0 \le i \le m$，有 $\textit{dp}[i][n]=1$；

- 当 $i=m$ 且 $j<n$ 时，$s[i:]$ 为空字符串，$t[j:]$ 为非空字符串，由于非空字符串不是空字符串的子序列，因此对任意 $0 \le j<n$，有 $\textit{dp}[m][j]=0$。

当 $i<m$ 且 $j<n$ 时，考虑 $\textit{dp}[i][j]$ 的计算：

- 当 $s[i]=t[j]$ 时，$\textit{dp}[i][j]$ 由两部分组成：

   - 如果 $s[i]$ 和 $t[j]$ 匹配，则考虑 $t[j+1:]$ 作为 $s[i+1:]$ 的子序列，子序列数为 $\textit{dp}[i+1][j+1]$；

   - 如果 $s[i]$ 不和 $t[j]$ 匹配，则考虑 $t[j:]$ 作为 $s[i+1:]$ 的子序列，子序列数为 $\textit{dp}[i+1][j]$。

   因此当 $s[i]=t[j]$ 时，有 $\textit{dp}[i][j]=\textit{dp}[i+1][j+1]+\textit{dp}[i+1][j]$。

- 当 $s[i] \ne t[j]$ 时，$s[i]$ 不能和 $t[j]$ 匹配，因此只考虑 $t[j:]$ 作为 $s[i+1:]$ 的子序列，子序列数为 $\textit{dp}[i+1][j]$。

   因此当 $s[i] \ne t[j]$ 时，有 $\textit{dp}[i][j]=\textit{dp}[i+1][j]$。

由此可以得到如下状态转移方程：

$$
\textit{dp}[i][j] = \begin{cases}
\textit{dp}[i+1][j+1]+\textit{dp}[i+1][j], & s[i]=t[j]\\
\textit{dp}[i+1][j], & s[i] \ne t[j]
\end{cases}
$$

最终计算得到 $\textit{dp}[0][0]$ 即为在 $s$ 的子序列中 $t$ 出现的个数。

<![ppt1](https://assets.leetcode-cn.com/solution-static/115/1.png),![ppt2](https://assets.leetcode-cn.com/solution-static/115/2.png),![ppt3](https://assets.leetcode-cn.com/solution-static/115/3.png),![ppt4](https://assets.leetcode-cn.com/solution-static/115/4.png),![ppt5](https://assets.leetcode-cn.com/solution-static/115/5.png),![ppt6](https://assets.leetcode-cn.com/solution-static/115/6.png),![ppt7](https://assets.leetcode-cn.com/solution-static/115/7.png),![ppt8](https://assets.leetcode-cn.com/solution-static/115/8.png),![ppt9](https://assets.leetcode-cn.com/solution-static/115/9.png),![ppt10](https://assets.leetcode-cn.com/solution-static/115/10.png),![ppt11](https://assets.leetcode-cn.com/solution-static/115/11.png),![ppt12](https://assets.leetcode-cn.com/solution-static/115/12.png),![ppt13](https://assets.leetcode-cn.com/solution-static/115/13.png),![ppt14](https://assets.leetcode-cn.com/solution-static/115/14.png),![ppt15](https://assets.leetcode-cn.com/solution-static/115/15.png),![ppt16](https://assets.leetcode-cn.com/solution-static/115/16.png),![ppt17](https://assets.leetcode-cn.com/solution-static/115/17.png),![ppt18](https://assets.leetcode-cn.com/solution-static/115/18.png),![ppt19](https://assets.leetcode-cn.com/solution-static/115/19.png),![ppt20](https://assets.leetcode-cn.com/solution-static/115/20.png),![ppt21](https://assets.leetcode-cn.com/solution-static/115/21.png),![ppt22](https://assets.leetcode-cn.com/solution-static/115/22.png),![ppt23](https://assets.leetcode-cn.com/solution-static/115/23.png),![ppt24](https://assets.leetcode-cn.com/solution-static/115/24.png)>

```Java [sol1-Java]
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();
        if (m < n) {
            return 0;
        }
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            dp[i][n] = 1;
        }
        for (int i = m - 1; i >= 0; i--) {
            char sChar = s.charAt(i);
            for (int j = n - 1; j >= 0; j--) {
                char tChar = t.charAt(j);
                if (sChar == tChar) {
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
                } else {
                    dp[i][j] = dp[i + 1][j];
                }
            }
        }
        return dp[0][0];
    }
}
```

```JavaScript [sol1-JavaScript]
var numDistinct = function(s, t) {
    const m = s.length, n = t.length;
    if (m < n) {
        return 0;
    }
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 0; i <= m; i++) {
        dp[i][n] = 1;
    }
    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (s[i] == t[j]) {
                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
            } else {
                dp[i][j] = dp[i + 1][j];
            }
        }
    }
    return dp[0][0];
};
```

```go [sol1-Golang]
func numDistinct(s, t string) int {
    m, n := len(s), len(t)
    if m < n {
        return 0
    }
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
        dp[i][n] = 1
    }
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            if s[i] == t[j] {
                dp[i][j] = dp[i+1][j+1] + dp[i+1][j]
            } else {
                dp[i][j] = dp[i+1][j]
            }
        }
    }
    return dp[0][0]
}
```

```Python [sol1-Python3]
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        if m < n:
            return 0
        
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][n] = 1
        
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if s[i] == t[j]:
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]
                else:
                    dp[i][j] = dp[i + 1][j]
        
        return dp[0][0]
```

```C++ [sol1-C++]
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.length(), n = t.length();
        if (m < n) {
            return 0;
        }
        vector<vector<long>> dp(m + 1, vector<long>(n + 1));
        for (int i = 0; i <= m; i++) {
            dp[i][n] = 1;
        }
        for (int i = m - 1; i >= 0; i--) {
            char sChar = s.at(i);
            for (int j = n - 1; j >= 0; j--) {
                char tChar = t.at(j);
                if (sChar == tChar) {
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
                } else {
                    dp[i][j] = dp[i + 1][j];
                }
            }
        }
        return dp[0][0];
    }
};
```

```C [sol1-C]
int numDistinct(char* s, char* t) {
    int m = strlen(s), n = strlen(t);
    if (m < n) {
        return 0;
    }
    long dp[m + 1][n + 1];
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i <= m; i++) {
        dp[i][n] = 1;
    }
    for (int i = m - 1; i >= 0; i--) {
        char sChar = s[i];
        for (int j = n - 1; j >= 0; j--) {
            char tChar = t[j];
            if (sChar == tChar) {
                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
            } else {
                dp[i][j] = dp[i + 1][j];
            }
        }
    }
    return dp[0][0];
}
```

**复杂度分析**

- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是字符串 $s$ 和 $t$ 的长度。二维数组 $\textit{dp}$ 有 $m+1$ 行和 $n+1$ 列，需要对 $\textit{dp}$ 中的每个元素进行计算。

- 空间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是字符串 $s$ 和 $t$ 的长度。创建了 $m+1$ 行 $n+1$ 列的二维数组 $\textit{dp}$。