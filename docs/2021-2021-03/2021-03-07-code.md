# 2021å¹´03æœˆ07æ—¥ code
<a href="https://toutiao.io/k/671eano">å¿«æ‰‹è¶…å¤§è§„æ¨¡é›†ç¾¤è°ƒåº¦ä¼˜åŒ–å®è·µ</a><br /><a href="https://toutiao.io/k/bat83ej">å°å¿ƒä½ çš„ä¸ªäººä¿¡æ¯ï¼šGitHub çƒ­ç‚¹é€Ÿè§ˆ v.21.09</a><br /><a href="https://toutiao.io/k/cfpu4ts">PySparkï¼šç”¨ Word2Vec è®¡ç®—æ–‡æœ¬ç›¸ä¼¼åº¦</a><br /><a href="https://toutiao.io/k/m48xs4b">Kotlin Symbol Processing (KSP) Alpha ç‰ˆç°å·²å‘å¸ƒ</a><br /><a href="https://toutiao.io/k/izh0wu8">è§£å‰– Babelï¼šå‘å‰ç«¯æ¶æ„å¸ˆè¿ˆå‡ºä¸€å°æ­¥</a><br /><a href="https://toutiao.io/k/4p14o1p">ã€Œèš‚èšå‘€å“ˆå“ˆã€è¯´ç«å°±ç«äº†ï¼Œè¯´ä¸‹æ¶å°±ä¸‹æ¶äº†</a><br /><a href="https://toutiao.io/k/ind3rp3">To B äº§å“ç»ç†éœ€è¦å“ªäº›èƒ½åŠ›å‘¢ï¼Ÿ</a><br /><a href="https://toutiao.io/k/xn7qlo5">æœ‰äº†äº§å“è´Ÿè´£äººï¼Œè¿˜éœ€è¦ä¸šåŠ¡åˆ†æå¸ˆå—ï¼Ÿ</a><br /><a href="https://toutiao.io/k/txx29jh">Testin äº‘æµ‹æ€»è£å¾ç¨ï¼šåˆ›ä¸šå¿…é¡»è¦åˆ›é€ å‡ºè‚‰çœ¼å¯è§çš„ä»·å€¼</a><br /><a href="https://toutiao.io/k/cpvgtw6">Webpack åŸºçŸ³ tapable æ­ç§˜</a><br /><a href="https://toutiao.io/k/rmckht1">[æ¨è] ç¡¬æ ¸ï¼æ¼«ç”»å›¾è§£ HTTP åŸºç¡€ + é¢è¯•é¢˜</a><br /><a href="https://toutiao.io/k/jfopywh">[æ¨è] Web å®‰å…¨å¤´å·å¤§æ•Œ XSS æ¼æ´è§£å†³æœ€ä½³å®è·µ</a><br /><a href="https://toutiao.io/k/ycdmy3y">[æ¨è] çœ‹å®Œè¿™ç¯‡ä½ ä¸€å®šèƒ½æŒæ¡ Linux</a><br /><a href="https://toutiao.io/k/xl63gz1">[æ¨è] çœ‹å®Œè¿™ç¯‡æ–‡ç« ï¼Œåˆ«å†è¯´ä¸ä¼š Redis çš„é«˜çº§ç‰¹æ€§äº†</a><br /><a href="https://toutiao.io/k/cpf8p4q">[æ¨è] æµé‡å¤åˆ¶æ–¹æ¡ˆå¯¹æ¯”ï¼šTCPCopy vs Goreplay</a><br /><a href="https://toutiao.io/k/gheevc3">[æ¨è] â€‹ç¨‹åºå‘˜åˆ’æ°´æŒ‡å—</a><br /><a href="https://toutiao.io/k/90116j8">[æ¨è] Redis ä¸ºä»€ä¹ˆå˜æ…¢äº†ï¼Ÿä¸€æ–‡è®²é€å¦‚ä½•æ’æŸ¥ Redis æ€§èƒ½é—®é¢˜</a><br /><a href="https://toutiao.io/k/r9tqaw3">[æ¨è] å‰¯ä¸šåˆšéœ€ï¼šåœ¨ GitHub ä¸Šä¹Ÿèƒ½å¹´å…¥ç™¾ä¸‡ï¼Ÿ</a><br /><a href="https://toutiao.io/k/ipuno05">[æ¨è] ç”Ÿäº§åŠ›è‡³å°‘æå‡ 5 å€ï¼Œå¤§å‚ç«æ‹¼çš„ä½ä»£ç å¹³å°ç©¶ç«Ÿè¿˜æœ‰å“ªäº›å‘ï¼Ÿ</a><br /><a href="https://toutiao.io/k/ix2e9ja">[æ¨è] ä¸­é«˜çº§å‰ç«¯é¡»æ³¨æ„çš„ 40 æ¡ç§»åŠ¨ç«¯ H5 å‘ä½æŒ‡å—ï¼ˆç½‘æ˜“ä¸‰å¹´å®è·µï¼‰</a><br /><a href="https://toutiao.io/k/ep472ts">[æ¨è] HTTP header ä¸­çš„é»‘ç§‘æŠ€</a><br /><a href="https://toutiao.io/k/6s1vey3">[æ¨è] Java é«˜å¹¶å‘ç¼–ç¨‹åŸºç¡€ä¹‹ AQS</a><br /><a href="https://toutiao.io/k/jpow46x">[æ¨è] æœ€æ–°äº’è”ç½‘å¤§å‚èŒä½è–ªèµ„ï¼Œå¿«æ¥å¯¹å·å…¥åº§å§</a><br /><a href="https://toutiao.io/k/x6ro69m">[æ¨è] é«˜å¹¶å‘ç³»ç»Ÿçš„é™æµç­–ç•¥ï¼šæ¼æ¡¶å’Œä»¤ç‰Œæ¡¶ï¼ˆé™„æºç å‰–æï¼‰</a><br /><a href="https://toutiao.io/k/95yxept">[æ¨è] æˆ‘ç”¨ Kafka ä¸¤å¹´è¸©è¿‡çš„ä¸€äº›éæ¯”å¯»å¸¸çš„å‘</a><br /><hr /><a href="https://github.com/dolthub/dolt">Dolt â€“ It's Git for Data</a><br /><a href="https://github.com/openai/CLIP">Contrastive Language-Image Pretraining</a><br /><a href="https://github.com/google/googletest">Googletest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/git/git">Git Source Code Mirror - This is a publish-only repository and all pull requests are ignored. Please follow Documentation/SubmittingPatches procedure for any of your improvements.</a><br /><a href="https://github.com/dwisiswant0/apkleaks">Scanning APK file for URIs, endpoints & secrets.</a><br /><a href="https://github.com/coolsnowwolf/lede">Lean's OpenWrt source</a><br /><a href="https://github.com/Developer-Y/cs-video-courses">List of Computer Science courses with video lectures.</a><br /><a href="https://github.com/gskinnerTeam/flutter-folio">A platform adaptive Flutter app for desktop, mobile and web.</a><br /><a href="https://github.com/connor-create/wsbtrades"></a><br /><a href="https://github.com/facebookresearch/d2go">D2Go is a toolkit for efficient deep learning</a><br /><a href="https://github.com/microsoft/CSS-Exchange">Exchange Server support tools and scripts</a><br /><a href="https://github.com/sarven/unit-testing-tips">Unit testing tips by examples in PHP</a><br /><a href="https://github.com/kilimchoi/engineering-blogs">A curated list of engineering blogs</a><br /><a href="https://github.com/MicrosoftLearning/AZ-104-MicrosoftAzureAdministrator">AZ-104 Microsoft Azure Administrator</a><br /><a href="https://github.com/florinpop17/app-ideas">A Collection of application ideas which can be used to improve your coding skills.</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">ğŸ“ Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/freefq/free">ç¿»å¢™ã€å…è´¹ç¿»å¢™ã€å…è´¹ç§‘å­¦ä¸Šç½‘ã€å…è´¹èŠ‚ç‚¹ã€å…è´¹æ¢¯å­ã€å…è´¹ss/ssr/v2ray/trojanèŠ‚ç‚¹ã€è“ç¯ã€è°·æ­Œå•†åº—ã€ç¿»å¢™æ¢¯å­</a><br /><a href="https://github.com/nushell/nushell">A new type of shell</a><br /><a href="https://github.com/Shopify/upgrow">A sustainable architecture for Ruby on Rails.</a><br /><a href="https://github.com/thunlp/GNNPapers">Must-read papers on graph neural networks (GNN)</a><br /><a href="https://github.com/getzola/zola">A fast static site generator in a single binary with everything built-in. https://www.getzola.org</a><br /><a href="https://github.com/microsoft/vscode">Visual Studio Code</a><br /><a href="https://github.com/muguruzawang/jd_maotai_seckill">ä¼˜åŒ–ç‰ˆæœ¬çš„äº¬ä¸œèŒ…å°æŠ¢è´­ç¥å™¨</a><br /><a href="https://github.com/acantril/learn-cantrill-io-labs">Standard and Advanced Demos for learn.cantrill.io courses</a><br /><hr />åˆ†å‰²å›æ–‡ä¸²<br /><p>ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² <em>s</em>ï¼Œå°†<em> s </em>åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²ã€‚</p>

<p>è¿”å› <em>s</em> æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚</p>

<p><strong>ç¤ºä¾‹:</strong></p>

<pre><strong>è¾“å…¥:</strong>&nbsp;&quot;aab&quot;
<strong>è¾“å‡º:</strong>
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]</pre>
<br />#### æ–¹æ³•ä¸€ï¼šå›æº¯ + åŠ¨æ€è§„åˆ’é¢„å¤„ç†

**æ€è·¯ä¸ç®—æ³•**

ç”±äºéœ€è¦æ±‚å‡ºå­—ç¬¦ä¸² $s$ çš„æ‰€æœ‰åˆ†å‰²æ–¹æ¡ˆï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘ä½¿ç”¨æœç´¢ + å›æº¯çš„æ–¹æ³•æšä¸¾æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ³•å¹¶è¿›è¡Œåˆ¤æ–­ã€‚

å‡è®¾æˆ‘ä»¬å½“å‰æœç´¢åˆ°å­—ç¬¦ä¸²çš„ç¬¬ $i$ ä¸ªå­—ç¬¦ï¼Œä¸” $s[0..i-1]$ ä½ç½®çš„æ‰€æœ‰å­—ç¬¦å·²ç»è¢«åˆ†å‰²æˆè‹¥å¹²ä¸ªå›æ–‡ä¸²ï¼Œå¹¶ä¸”åˆ†å‰²ç»“æœè¢«æ”¾å…¥äº†ç­”æ¡ˆæ•°ç»„ $\textit{ans}$ ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦æšä¸¾ä¸‹ä¸€ä¸ªå›æ–‡ä¸²çš„å³è¾¹ç•Œ $j$ï¼Œä½¿å¾— $s[i..j]$ æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä» $i$ å¼€å§‹ï¼Œä»å°åˆ°å¤§ä¾æ¬¡æšä¸¾ $j$ã€‚å¯¹äºå½“å‰æšä¸¾çš„ $j$ å€¼ï¼Œæˆ‘ä»¬ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•åˆ¤æ–­ $s[i..j]$ æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼šå¦‚æœ $s[i..j]$ æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆå°±å°†å…¶åŠ å…¥ç­”æ¡ˆæ•°ç»„ $\textit{ans}$ ä¸­ï¼Œå¹¶ä»¥ $j+1$ ä½œä¸ºæ–°çš„ $i$ è¿›è¡Œä¸‹ä¸€å±‚æœç´¢ï¼Œå¹¶åœ¨æœªæ¥çš„å›æº¯æ—¶å°† $s[i..j]$ ä» $\textit{ans}$ ä¸­ç§»é™¤ã€‚

å¦‚æœæˆ‘ä»¬å·²ç»æœç´¢å®Œäº†å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œé‚£ä¹ˆå°±æ‰¾åˆ°äº†ä¸€ç§æ»¡è¶³è¦æ±‚çš„åˆ†å‰²æ–¹æ³•ã€‚

**ç»†èŠ‚**

å½“æˆ‘ä»¬åœ¨åˆ¤æ–­ $s[i..j]$ æ˜¯å¦ä¸ºå›æ–‡ä¸²æ—¶ï¼Œå¸¸è§„çš„æ–¹æ³•æ˜¯ä½¿ç”¨åŒæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ $i$ å’Œ $j$ï¼Œæ¯æ¬¡åˆ¤æ–­ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦æ˜¯å¦ç›¸åŒï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ã€‚ç„¶è€Œè¿™ç§æ–¹æ³•ä¼šäº§ç”Ÿé‡å¤è®¡ç®—ï¼Œä¾‹å¦‚ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š

> å½“ $s = \texttt{aaba}$ æ—¶ï¼Œå¯¹äºå‰ $2$ ä¸ªå­—ç¬¦ $\texttt{aa}$ï¼Œæˆ‘ä»¬æœ‰ $2$ ç§åˆ†å‰²æ–¹æ³• $[\texttt{aa}]$ å’Œ $[\texttt{a}, \texttt{a}]$ï¼Œå½“æˆ‘ä»¬æ¯ä¸€æ¬¡æœç´¢åˆ°å­—ç¬¦ä¸²çš„ç¬¬ $i=2$ ä¸ªå­—ç¬¦ $\texttt{b}$ æ—¶ï¼Œéƒ½éœ€è¦å¯¹äºæ¯ä¸ª $s[i..j]$ ä½¿ç”¨åŒæŒ‡é’ˆåˆ¤æ–­å…¶æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Œè¿™å°±äº§ç”Ÿäº†é‡å¤è®¡ç®—ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†å­—ç¬¦ä¸² $s$ çš„æ¯ä¸ªå­ä¸² $s[i..j]$ æ˜¯å¦ä¸ºå›æ–‡ä¸²é¢„å¤„ç†å‡ºæ¥ï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’å³å¯ã€‚è®¾ $f(i, j)$ è¡¨ç¤º $s[i..j]$ æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Œé‚£ä¹ˆæœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

$$
f(i, j) = \begin{cases}
\texttt{True}, & \quad i \geq j \\
f(i+1,j-1) \wedge (s[i]=s[j]), & \quad \text{otherwise}
\end{cases}
$$

å…¶ä¸­ $\wedge$ è¡¨ç¤ºé€»è¾‘ä¸è¿ç®—ï¼Œå³ $s[i..j]$ ä¸ºå›æ–‡ä¸²ï¼Œå½“ä¸”ä»…å½“å…¶ä¸ºç©ºä¸²ï¼ˆ$i>j$ï¼‰ï¼Œå…¶é•¿åº¦ä¸º $1$ï¼ˆ$i=j$ï¼‰ï¼Œæˆ–è€…é¦–å°¾å­—ç¬¦ç›¸åŒä¸” $s[i+1..j-1]$ ä¸ºå›æ–‡ä¸²ã€‚

é¢„å¤„ç†å®Œæˆä¹‹åï¼Œæˆ‘ä»¬åªéœ€è¦ $O(1)$ çš„æ—¶é—´å°±å¯ä»¥åˆ¤æ–­ä»»æ„ $s[i..j]$ æ˜¯å¦ä¸ºå›æ–‡ä¸²äº†ã€‚

**ä»£ç **

```C++ [sol1-C++]
class Solution {
private:
    vector<vector<int>> f;
    vector<vector<string>> ret;
    vector<string> ans;
    int n;

public:
    void dfs(const string& s, int i) {
        if (i == n) {
            ret.push_back(ans);
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.push_back(s.substr(i, j - i + 1));
                dfs(s, j + 1);
                ans.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        n = s.size();
        f.assign(n, vector<int>(n, true));

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }
};
```

```Java [sol1-Java]
class Solution {
    boolean[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(f[i], true);
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }
}
```

```Python [sol1-Python3]
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        f = [[True] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                f[i][j] = (s[i] == s[j]) and f[i + 1][j - 1]

        ret = list()
        ans = list()

        def dfs(i: int):
            if i == n:
                ret.append(ans[:])
                return
            
            for j in range(i, n):
                if f[i][j]:
                    ans.append(s[i:j+1])
                    dfs(j + 1)
                    ans.pop()

        dfs(0)
        return ret
```

```JavaScript [sol1-JavaScript]
var partition = function(s) {
    const dfs = (i) => {
        if (i === n) {
            ret.push(ans.slice());
            return;
        }
        for (let j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.push(s.slice(i, j + 1));
                dfs(j + 1);
                ans.pop();
            }
        }
    }
    
    const n = s.length;
    const f = new Array(n).fill(0).map(() => new Array(n).fill(true));
    let ret = [], ans = [];
    
    for (let i = n - 1; i >= 0; --i) {
        for (let j = i + 1; j < n; ++j) {
            f[i][j] = (s[i] === s[j]) && f[i + 1][j - 1];
        }
    }
    dfs(0);
    return ret;
};
```

```go [sol1-Golang]
func partition(s string) (ans [][]string) {
    n := len(s)
    f := make([][]bool, n)
    for i := range f {
        f[i] = make([]bool, n)
        for j := range f[i] {
            f[i][j] = true
        }
    }
    for i := n - 1; i >= 0; i-- {
        for j := i + 1; j < n; j++ {
            f[i][j] = s[i] == s[j] && f[i+1][j-1]
        }
    }

    splits := []string{}
    var dfs func(int)
    dfs = func(i int) {
        if i == n {
            ans = append(ans, append([]string(nil), splits...))
            return
        }
        for j := i; j < n; j++ {
            if f[i][j] {
                splits = append(splits, s[i:j+1])
                dfs(j + 1)
                splits = splits[:len(splits)-1]
            }
        }
    }
    dfs(0)
    return
}
```

```C [sol1-C]
void dfs(char* s, int n, int i, int** f, char*** ret, int* retSize, int* retColSize, char** ans, int* ansSize) {
    if (i == n) {
        char** tmp = malloc(sizeof(char*) * (*ansSize));
        for (int j = 0; j < (*ansSize); j++) {
            int ansColSize = strlen(ans[j]);
            tmp[j] = malloc(sizeof(char) * (ansColSize + 1));
            strcpy(tmp[j], ans[j]);
        }
        ret[*retSize] = tmp;
        retColSize[(*retSize)++] = *ansSize;
        return;
    }
    for (int j = i; j < n; ++j) {
        if (f[i][j]) {
            char* sub = malloc(sizeof(char) * (j - i + 2));
            for (int k = i; k <= j; k++) {
                sub[k - i] = s[k];
            }
            sub[j - i + 1] = '\0';
            ans[(*ansSize)++] = sub;
            dfs(s, n, j + 1, f, ret, retSize, retColSize, ans, ansSize);
            --(*ansSize);
        }
    }
}

char*** partition(char* s, int* returnSize, int** returnColumnSizes) {
    int n = strlen(s);
    int retMaxLen = n * (1 << n);
    char*** ret = malloc(sizeof(char**) * retMaxLen);
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * retMaxLen);
    int* f[n];
    for (int i = 0; i < n; i++) {
        f[i] = malloc(sizeof(int) * n);
        for (int j = 0; j < n; j++) {
            f[i][j] = 1;
        }
    }
    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
        }
    }
    char* ans[n];
    int ansSize = 0;
    dfs(s, n, 0, f, ret, returnSize, *returnColumnSizes, ans, &ansSize);
    return ret;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \cdot 2^n)$ï¼Œå…¶ä¸­ $n$ æ˜¯å­—ç¬¦ä¸² $s$ çš„é•¿åº¦ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œ$s$ åŒ…å« $n$ ä¸ªå®Œå…¨ç›¸åŒçš„å­—ç¬¦ï¼Œå› æ­¤å®ƒçš„ä»»æ„ä¸€ç§åˆ’åˆ†æ–¹æ³•éƒ½æ»¡è¶³è¦æ±‚ã€‚è€Œé•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸²çš„åˆ’åˆ†æ–¹æ¡ˆæ•°ä¸º $2^{n-1}=O(2^n)$ï¼Œæ¯ä¸€ç§åˆ’åˆ†æ–¹æ³•éœ€è¦ $O(n)$ çš„æ—¶é—´æ±‚å‡ºå¯¹åº”çš„åˆ’åˆ†ç»“æœå¹¶æ”¾å…¥ç­”æ¡ˆï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \cdot 2^n)$ã€‚å°½ç®¡åŠ¨æ€è§„åˆ’é¢„å¤„ç†éœ€è¦ $O(n^2)$ çš„æ—¶é—´ï¼Œä½†åœ¨æ¸è¿›æ„ä¹‰ä¸‹å°äº $O(n \cdot 2^n)$ï¼Œå› æ­¤å¯ä»¥å¿½ç•¥ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n \cdot 2^n)$ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œç­”æ¡ˆä¸­åŒ…æ‹¬ $2^{n-1}$ ç§åˆ’åˆ†æ–¹æ³•ï¼Œæ¯ç§æ–¹æ³•éœ€è¦ä½¿ç”¨ $O(n)$ çš„ç©ºé—´è¿›è¡Œå­˜å‚¨ã€‚

#### æ–¹æ³•äºŒï¼šå›æº¯ + è®°å¿†åŒ–æœç´¢

**æ€è·¯ä¸ç®—æ³•**

æ–¹æ³•ä¸€ä¸­çš„åŠ¨æ€è§„åˆ’é¢„å¤„ç†è®¡ç®—å‡ºäº†ä»»æ„çš„ $s[i..j]$ æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Œä½†åœ¨å®é™…çš„æœç´¢è¿‡ç¨‹ä¸­ï¼Œå¹¶ä¸æ˜¯æ¯ä¸ª $s$ çš„å­ä¸²éƒ½æ˜¯ä¼šè¢«æœç´¢åˆ°çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸€æ­¥æ”¹ä¸ºè®°å¿†åŒ–æœç´¢ï¼Œå‡å°‘ç®—æ³•çš„å¸¸æ•°ã€‚

**ä»£ç **

```C++ [sol2-C++]
class Solution {
private:
    vector<vector<int>> f;
    vector<vector<string>> ret;
    vector<string> ans;
    int n;

public:
    void dfs(const string& s, int i) {
        if (i == n) {
            ret.push_back(ans);
            return;
        }
        for (int j = i; j < n; ++j) {
            if (isPalindrome(s, i, j) == 1) {
                ans.push_back(s.substr(i, j - i + 1));
                dfs(s, j + 1);
                ans.pop_back();
            }
        }
    }

    // è®°å¿†åŒ–æœç´¢ä¸­ï¼Œf[i][j] = 0 è¡¨ç¤ºæœªæœç´¢ï¼Œ1 è¡¨ç¤ºæ˜¯å›æ–‡ä¸²ï¼Œ-1 è¡¨ç¤ºä¸æ˜¯å›æ–‡ä¸²
    int isPalindrome(const string& s, int i, int j) {
        if (f[i][j]) {
            return f[i][j];
        }
        if (i >= j) {
            return f[i][j] = 1;
        }
        return f[i][j] = (s[i] == s[j] ? isPalindrome(s, i + 1, j - 1) : -1);
    }

    vector<vector<string>> partition(string s) {
        n = s.size();
        f.assign(n, vector<int>(n));

        dfs(s, 0);
        return ret;
    }
};
```

```Java [sol2-Java]
class Solution {
    int[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new int[n][n];

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (isPalindrome(s, i, j) == 1) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }

    // è®°å¿†åŒ–æœç´¢ä¸­ï¼Œf[i][j] = 0 è¡¨ç¤ºæœªæœç´¢ï¼Œ1 è¡¨ç¤ºæ˜¯å›æ–‡ä¸²ï¼Œ-1 è¡¨ç¤ºä¸æ˜¯å›æ–‡ä¸²
    public int isPalindrome(String s, int i, int j) {
        if (f[i][j] != 0) {
            return f[i][j];
        }
        if (i >= j) {
            f[i][j] = 1;
        } else if (s.charAt(i) == s.charAt(j)) {
            f[i][j] = isPalindrome(s, i + 1, j - 1);
        } else {
            f[i][j] = -1;
        }
        return f[i][j];
    }
}
```

```Python [sol2-Python3]
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)

        ret = list()
        ans = list()

        @cache
        def isPalindrome(i: int, j: int) -> int:
            if i >= j:
                return 1
            return isPalindrome(i + 1, j - 1) if s[i] == s[j] else -1

        def dfs(i: int):
            if i == n:
                ret.append(ans[:])
                return
            
            for j in range(i, n):
                if isPalindrome(i, j) == 1:
                    ans.append(s[i:j+1])
                    dfs(j + 1)
                    ans.pop()

        dfs(0)
        isPalindrome.cache_clear()
        return ret
```

```JavaScript [sol2-JavaScript]
var partition = function(s) {
    const dfs = (i) => {
        if (i === n) {
            ret.push(ans.slice());
            return;
        }
        for (let j = i; j < n; ++j) {
            if (isPalindrome(i, j) === 1) {
                ans.push(s.slice(i, j + 1));
                dfs(j + 1);
                ans.pop();
            }
        }
    }

    // è®°å¿†åŒ–æœç´¢ä¸­ï¼Œf[i][j] = 0 è¡¨ç¤ºæœªæœç´¢ï¼Œ1 è¡¨ç¤ºæ˜¯å›æ–‡ä¸²ï¼Œ-1 è¡¨ç¤ºä¸æ˜¯å›æ–‡ä¸²
    const isPalindrome = (i, j) => {
        if (f[i][j] !== 0) {
            return f[i][j];
        }
        if (i >= j) {
            f[i][j] = 1;
        } else if (s[i] === s[j]) {
            f[i][j] = isPalindrome(i + 1, j - 1);
        } else {
            f[i][j] = -1;
        }
        return f[i][j];
    }

    const n = s.length;
    const ret = [], ans = [];
    const f = new Array(n).fill(0).map(() => new Array(n).fill(0));

    dfs(0);
    return ret;
};
```

```go [sol2-Golang]
func partition(s string) (ans [][]string) {
    n := len(s)
    f := make([][]int8, n)
    for i := range f {
        f[i] = make([]int8, n)
    }

    // 0 è¡¨ç¤ºå°šæœªæœç´¢ï¼Œ1 è¡¨ç¤ºæ˜¯å›æ–‡ä¸²ï¼Œ-1 è¡¨ç¤ºä¸æ˜¯å›æ–‡ä¸²
    var isPalindrome func(i, j int) int8
    isPalindrome = func(i, j int) int8 {
        if i >= j {
            return 1
        }
        if f[i][j] != 0 {
            return f[i][j]
        }
        f[i][j] = -1
        if s[i] == s[j] {
            f[i][j] = isPalindrome(i+1, j-1)
        }
        return f[i][j]
    }

    splits := []string{}
    var dfs func(int)
    dfs = func(i int) {
        if i == n {
            ans = append(ans, append([]string(nil), splits...))
            return
        }
        for j := i; j < n; j++ {
            if isPalindrome(i, j) > 0 {
                splits = append(splits, s[i:j+1])
                dfs(j + 1)
                splits = splits[:len(splits)-1]
            }
        }
    }
    dfs(0)
    return
}
```

```C [sol2-C]
// è®°å¿†åŒ–æœç´¢ä¸­ï¼Œf[i][j] = 0 è¡¨ç¤ºæœªæœç´¢ï¼Œ1 è¡¨ç¤ºæ˜¯å›æ–‡ä¸²ï¼Œ-1 è¡¨ç¤ºä¸æ˜¯å›æ–‡ä¸²
int isPalindrome(char* s, int** f, int i, int j) {
    if (f[i][j]) {
        return f[i][j];
    }
    if (i >= j) {
        return f[i][j] = 1;
    }
    return f[i][j] = (s[i] == s[j] ? isPalindrome(s, f, i + 1, j - 1) : -1);
}

void dfs(char* s, int n, int i, int** f, char*** ret, int* retSize, int* retColSize, char** ans, int* ansSize) {
    if (i == n) {
        char** tmp = malloc(sizeof(char*) * (*ansSize));
        for (int j = 0; j < (*ansSize); j++) {
            int ansColSize = strlen(ans[j]);
            tmp[j] = malloc(sizeof(char) * (ansColSize + 1));
            strcpy(tmp[j], ans[j]);
        }
        ret[*retSize] = tmp;
        retColSize[(*retSize)++] = *ansSize;
        return;
    }
    for (int j = i; j < n; ++j) {
        if (isPalindrome(s, f, i, j) == 1) {
            char* sub = malloc(sizeof(char) * (j - i + 2));
            for (int k = i; k <= j; k++) {
                sub[k - i] = s[k];
            }
            sub[j - i + 1] = '\0';
            ans[(*ansSize)++] = sub;
            dfs(s, n, j + 1, f, ret, retSize, retColSize, ans, ansSize);
            --(*ansSize);
        }
    }
}

char*** partition(char* s, int* returnSize, int** returnColumnSizes) {
    int n = strlen(s);
    int retMaxLen = n * (1 << n);
    char*** ret = malloc(sizeof(char**) * retMaxLen);
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * retMaxLen);
    int* f[n];
    for (int i = 0; i < n; i++) {
        f[i] = malloc(sizeof(int) * n);
        for (int j = 0; j < n; j++) {
            f[i][j] = 1;
        }
    }
    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
        }
    }
    char* ans[n];
    int ansSize = 0;
    dfs(s, n, 0, f, ret, returnSize, *returnColumnSizes, ans, &ansSize);
    return ret;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \cdot 2^n)$ï¼Œå…¶ä¸­ $n$ æ˜¯å­—ç¬¦ä¸² $s$ çš„é•¿åº¦ã€‚åœ¨æœ€åæƒ…å†µä¸‹ä¸æ–¹æ³•ä¸€ç›¸åŒã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n \cdot 2^n)$ã€‚åœ¨æœ€åæƒ…å†µä¸‹ä¸æ–¹æ³•ä¸€ç›¸åŒã€‚