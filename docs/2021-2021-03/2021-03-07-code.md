# 2021年03月07日 code
<a href="https://toutiao.io/k/671eano">快手超大规模集群调度优化实践</a><br /><a href="https://toutiao.io/k/bat83ej">小心你的个人信息：GitHub 热点速览 v.21.09</a><br /><a href="https://toutiao.io/k/cfpu4ts">PySpark：用 Word2Vec 计算文本相似度</a><br /><a href="https://toutiao.io/k/m48xs4b">Kotlin Symbol Processing (KSP) Alpha 版现已发布</a><br /><a href="https://toutiao.io/k/izh0wu8">解剖 Babel：向前端架构师迈出一小步</a><br /><a href="https://toutiao.io/k/4p14o1p">「蚂蚁呀哈哈」说火就火了，说下架就下架了</a><br /><a href="https://toutiao.io/k/ind3rp3">To B 产品经理需要哪些能力呢？</a><br /><a href="https://toutiao.io/k/xn7qlo5">有了产品负责人，还需要业务分析师吗？</a><br /><a href="https://toutiao.io/k/txx29jh">Testin 云测总裁徐琨：创业必须要创造出肉眼可见的价值</a><br /><a href="https://toutiao.io/k/cpvgtw6">Webpack 基石 tapable 揭秘</a><br /><a href="https://toutiao.io/k/rmckht1">[推荐] 硬核！漫画图解 HTTP 基础 + 面试题</a><br /><a href="https://toutiao.io/k/jfopywh">[推荐] Web 安全头号大敌 XSS 漏洞解决最佳实践</a><br /><a href="https://toutiao.io/k/ycdmy3y">[推荐] 看完这篇你一定能掌握 Linux</a><br /><a href="https://toutiao.io/k/xl63gz1">[推荐] 看完这篇文章，别再说不会 Redis 的高级特性了</a><br /><a href="https://toutiao.io/k/cpf8p4q">[推荐] 流量复制方案对比：TCPCopy vs Goreplay</a><br /><a href="https://toutiao.io/k/gheevc3">[推荐] ​程序员划水指南</a><br /><a href="https://toutiao.io/k/90116j8">[推荐] Redis 为什么变慢了？一文讲透如何排查 Redis 性能问题</a><br /><a href="https://toutiao.io/k/r9tqaw3">[推荐] 副业刚需：在 GitHub 上也能年入百万？</a><br /><a href="https://toutiao.io/k/ipuno05">[推荐] 生产力至少提升 5 倍，大厂火拼的低代码平台究竟还有哪些坑？</a><br /><a href="https://toutiao.io/k/ix2e9ja">[推荐] 中高级前端须注意的 40 条移动端 H5 坑位指南（网易三年实践）</a><br /><a href="https://toutiao.io/k/ep472ts">[推荐] HTTP header 中的黑科技</a><br /><a href="https://toutiao.io/k/6s1vey3">[推荐] Java 高并发编程基础之 AQS</a><br /><a href="https://toutiao.io/k/jpow46x">[推荐] 最新互联网大厂职位薪资，快来对号入座吧</a><br /><a href="https://toutiao.io/k/x6ro69m">[推荐] 高并发系统的限流策略：漏桶和令牌桶（附源码剖析）</a><br /><a href="https://toutiao.io/k/95yxept">[推荐] 我用 Kafka 两年踩过的一些非比寻常的坑</a><br /><hr /><a href="https://github.com/dolthub/dolt">Dolt – It's Git for Data</a><br /><a href="https://github.com/openai/CLIP">Contrastive Language-Image Pretraining</a><br /><a href="https://github.com/google/googletest">Googletest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/git/git">Git Source Code Mirror - This is a publish-only repository and all pull requests are ignored. Please follow Documentation/SubmittingPatches procedure for any of your improvements.</a><br /><a href="https://github.com/dwisiswant0/apkleaks">Scanning APK file for URIs, endpoints & secrets.</a><br /><a href="https://github.com/coolsnowwolf/lede">Lean's OpenWrt source</a><br /><a href="https://github.com/Developer-Y/cs-video-courses">List of Computer Science courses with video lectures.</a><br /><a href="https://github.com/gskinnerTeam/flutter-folio">A platform adaptive Flutter app for desktop, mobile and web.</a><br /><a href="https://github.com/connor-create/wsbtrades"></a><br /><a href="https://github.com/facebookresearch/d2go">D2Go is a toolkit for efficient deep learning</a><br /><a href="https://github.com/microsoft/CSS-Exchange">Exchange Server support tools and scripts</a><br /><a href="https://github.com/sarven/unit-testing-tips">Unit testing tips by examples in PHP</a><br /><a href="https://github.com/kilimchoi/engineering-blogs">A curated list of engineering blogs</a><br /><a href="https://github.com/MicrosoftLearning/AZ-104-MicrosoftAzureAdministrator">AZ-104 Microsoft Azure Administrator</a><br /><a href="https://github.com/florinpop17/app-ideas">A Collection of application ideas which can be used to improve your coding skills.</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/freefq/free">翻墙、免费翻墙、免费科学上网、免费节点、免费梯子、免费ss/ssr/v2ray/trojan节点、蓝灯、谷歌商店、翻墙梯子</a><br /><a href="https://github.com/nushell/nushell">A new type of shell</a><br /><a href="https://github.com/Shopify/upgrow">A sustainable architecture for Ruby on Rails.</a><br /><a href="https://github.com/thunlp/GNNPapers">Must-read papers on graph neural networks (GNN)</a><br /><a href="https://github.com/getzola/zola">A fast static site generator in a single binary with everything built-in. https://www.getzola.org</a><br /><a href="https://github.com/microsoft/vscode">Visual Studio Code</a><br /><a href="https://github.com/muguruzawang/jd_maotai_seckill">优化版本的京东茅台抢购神器</a><br /><a href="https://github.com/acantril/learn-cantrill-io-labs">Standard and Advanced Demos for learn.cantrill.io courses</a><br /><hr />分割回文串<br /><p>给定一个字符串 <em>s</em>，将<em> s </em>分割成一些子串，使每个子串都是回文串。</p>

<p>返回 <em>s</em> 所有可能的分割方案。</p>

<p><strong>示例:</strong></p>

<pre><strong>输入:</strong>&nbsp;&quot;aab&quot;
<strong>输出:</strong>
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]</pre>
<br />#### 方法一：回溯 + 动态规划预处理

**思路与算法**

由于需要求出字符串 $s$ 的所有分割方案，因此我们考虑使用搜索 + 回溯的方法枚举所有可能的分割方法并进行判断。

假设我们当前搜索到字符串的第 $i$ 个字符，且 $s[0..i-1]$ 位置的所有字符已经被分割成若干个回文串，并且分割结果被放入了答案数组 $\textit{ans}$ 中，那么我们就需要枚举下一个回文串的右边界 $j$，使得 $s[i..j]$ 是一个回文串。

因此，我们可以从 $i$ 开始，从小到大依次枚举 $j$。对于当前枚举的 $j$ 值，我们使用双指针的方法判断 $s[i..j]$ 是否为回文串：如果 $s[i..j]$ 是回文串，那么就将其加入答案数组 $\textit{ans}$ 中，并以 $j+1$ 作为新的 $i$ 进行下一层搜索，并在未来的回溯时将 $s[i..j]$ 从 $\textit{ans}$ 中移除。

如果我们已经搜索完了字符串的最后一个字符，那么就找到了一种满足要求的分割方法。

**细节**

当我们在判断 $s[i..j]$ 是否为回文串时，常规的方法是使用双指针分别指向 $i$ 和 $j$，每次判断两个指针指向的字符是否相同，直到两个指针相遇。然而这种方法会产生重复计算，例如下面这个例子：

> 当 $s = \texttt{aaba}$ 时，对于前 $2$ 个字符 $\texttt{aa}$，我们有 $2$ 种分割方法 $[\texttt{aa}]$ 和 $[\texttt{a}, \texttt{a}]$，当我们每一次搜索到字符串的第 $i=2$ 个字符 $\texttt{b}$ 时，都需要对于每个 $s[i..j]$ 使用双指针判断其是否为回文串，这就产生了重复计算。

因此，我们可以将字符串 $s$ 的每个子串 $s[i..j]$ 是否为回文串预处理出来，使用动态规划即可。设 $f(i, j)$ 表示 $s[i..j]$ 是否为回文串，那么有状态转移方程：

$$
f(i, j) = \begin{cases}
\texttt{True}, & \quad i \geq j \\
f(i+1,j-1) \wedge (s[i]=s[j]), & \quad \text{otherwise}
\end{cases}
$$

其中 $\wedge$ 表示逻辑与运算，即 $s[i..j]$ 为回文串，当且仅当其为空串（$i>j$），其长度为 $1$（$i=j$），或者首尾字符相同且 $s[i+1..j-1]$ 为回文串。

预处理完成之后，我们只需要 $O(1)$ 的时间就可以判断任意 $s[i..j]$ 是否为回文串了。

**代码**

```C++ [sol1-C++]
class Solution {
private:
    vector<vector<int>> f;
    vector<vector<string>> ret;
    vector<string> ans;
    int n;

public:
    void dfs(const string& s, int i) {
        if (i == n) {
            ret.push_back(ans);
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.push_back(s.substr(i, j - i + 1));
                dfs(s, j + 1);
                ans.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        n = s.size();
        f.assign(n, vector<int>(n, true));

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }
};
```

```Java [sol1-Java]
class Solution {
    boolean[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(f[i], true);
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }
}
```

```Python [sol1-Python3]
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        f = [[True] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                f[i][j] = (s[i] == s[j]) and f[i + 1][j - 1]

        ret = list()
        ans = list()

        def dfs(i: int):
            if i == n:
                ret.append(ans[:])
                return
            
            for j in range(i, n):
                if f[i][j]:
                    ans.append(s[i:j+1])
                    dfs(j + 1)
                    ans.pop()

        dfs(0)
        return ret
```

```JavaScript [sol1-JavaScript]
var partition = function(s) {
    const dfs = (i) => {
        if (i === n) {
            ret.push(ans.slice());
            return;
        }
        for (let j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.push(s.slice(i, j + 1));
                dfs(j + 1);
                ans.pop();
            }
        }
    }
    
    const n = s.length;
    const f = new Array(n).fill(0).map(() => new Array(n).fill(true));
    let ret = [], ans = [];
    
    for (let i = n - 1; i >= 0; --i) {
        for (let j = i + 1; j < n; ++j) {
            f[i][j] = (s[i] === s[j]) && f[i + 1][j - 1];
        }
    }
    dfs(0);
    return ret;
};
```

```go [sol1-Golang]
func partition(s string) (ans [][]string) {
    n := len(s)
    f := make([][]bool, n)
    for i := range f {
        f[i] = make([]bool, n)
        for j := range f[i] {
            f[i][j] = true
        }
    }
    for i := n - 1; i >= 0; i-- {
        for j := i + 1; j < n; j++ {
            f[i][j] = s[i] == s[j] && f[i+1][j-1]
        }
    }

    splits := []string{}
    var dfs func(int)
    dfs = func(i int) {
        if i == n {
            ans = append(ans, append([]string(nil), splits...))
            return
        }
        for j := i; j < n; j++ {
            if f[i][j] {
                splits = append(splits, s[i:j+1])
                dfs(j + 1)
                splits = splits[:len(splits)-1]
            }
        }
    }
    dfs(0)
    return
}
```

```C [sol1-C]
void dfs(char* s, int n, int i, int** f, char*** ret, int* retSize, int* retColSize, char** ans, int* ansSize) {
    if (i == n) {
        char** tmp = malloc(sizeof(char*) * (*ansSize));
        for (int j = 0; j < (*ansSize); j++) {
            int ansColSize = strlen(ans[j]);
            tmp[j] = malloc(sizeof(char) * (ansColSize + 1));
            strcpy(tmp[j], ans[j]);
        }
        ret[*retSize] = tmp;
        retColSize[(*retSize)++] = *ansSize;
        return;
    }
    for (int j = i; j < n; ++j) {
        if (f[i][j]) {
            char* sub = malloc(sizeof(char) * (j - i + 2));
            for (int k = i; k <= j; k++) {
                sub[k - i] = s[k];
            }
            sub[j - i + 1] = '\0';
            ans[(*ansSize)++] = sub;
            dfs(s, n, j + 1, f, ret, retSize, retColSize, ans, ansSize);
            --(*ansSize);
        }
    }
}

char*** partition(char* s, int* returnSize, int** returnColumnSizes) {
    int n = strlen(s);
    int retMaxLen = n * (1 << n);
    char*** ret = malloc(sizeof(char**) * retMaxLen);
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * retMaxLen);
    int* f[n];
    for (int i = 0; i < n; i++) {
        f[i] = malloc(sizeof(int) * n);
        for (int j = 0; j < n; j++) {
            f[i][j] = 1;
        }
    }
    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
        }
    }
    char* ans[n];
    int ansSize = 0;
    dfs(s, n, 0, f, ret, returnSize, *returnColumnSizes, ans, &ansSize);
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(n \cdot 2^n)$，其中 $n$ 是字符串 $s$ 的长度。在最坏情况下，$s$ 包含 $n$ 个完全相同的字符，因此它的任意一种划分方法都满足要求。而长度为 $n$ 的字符串的划分方案数为 $2^{n-1}=O(2^n)$，每一种划分方法需要 $O(n)$ 的时间求出对应的划分结果并放入答案，因此总时间复杂度为 $O(n \cdot 2^n)$。尽管动态规划预处理需要 $O(n^2)$ 的时间，但在渐进意义下小于 $O(n \cdot 2^n)$，因此可以忽略。

- 空间复杂度：$O(n \cdot 2^n)$。在最坏情况下，答案中包括 $2^{n-1}$ 种划分方法，每种方法需要使用 $O(n)$ 的空间进行存储。

#### 方法二：回溯 + 记忆化搜索

**思路与算法**

方法一中的动态规划预处理计算出了任意的 $s[i..j]$ 是否为回文串，但在实际的搜索过程中，并不是每个 $s$ 的子串都是会被搜索到的，因此我们可以将这一步改为记忆化搜索，减少算法的常数。

**代码**

```C++ [sol2-C++]
class Solution {
private:
    vector<vector<int>> f;
    vector<vector<string>> ret;
    vector<string> ans;
    int n;

public:
    void dfs(const string& s, int i) {
        if (i == n) {
            ret.push_back(ans);
            return;
        }
        for (int j = i; j < n; ++j) {
            if (isPalindrome(s, i, j) == 1) {
                ans.push_back(s.substr(i, j - i + 1));
                dfs(s, j + 1);
                ans.pop_back();
            }
        }
    }

    // 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串
    int isPalindrome(const string& s, int i, int j) {
        if (f[i][j]) {
            return f[i][j];
        }
        if (i >= j) {
            return f[i][j] = 1;
        }
        return f[i][j] = (s[i] == s[j] ? isPalindrome(s, i + 1, j - 1) : -1);
    }

    vector<vector<string>> partition(string s) {
        n = s.size();
        f.assign(n, vector<int>(n));

        dfs(s, 0);
        return ret;
    }
};
```

```Java [sol2-Java]
class Solution {
    int[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new int[n][n];

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (isPalindrome(s, i, j) == 1) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }

    // 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串
    public int isPalindrome(String s, int i, int j) {
        if (f[i][j] != 0) {
            return f[i][j];
        }
        if (i >= j) {
            f[i][j] = 1;
        } else if (s.charAt(i) == s.charAt(j)) {
            f[i][j] = isPalindrome(s, i + 1, j - 1);
        } else {
            f[i][j] = -1;
        }
        return f[i][j];
    }
}
```

```Python [sol2-Python3]
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)

        ret = list()
        ans = list()

        @cache
        def isPalindrome(i: int, j: int) -> int:
            if i >= j:
                return 1
            return isPalindrome(i + 1, j - 1) if s[i] == s[j] else -1

        def dfs(i: int):
            if i == n:
                ret.append(ans[:])
                return
            
            for j in range(i, n):
                if isPalindrome(i, j) == 1:
                    ans.append(s[i:j+1])
                    dfs(j + 1)
                    ans.pop()

        dfs(0)
        isPalindrome.cache_clear()
        return ret
```

```JavaScript [sol2-JavaScript]
var partition = function(s) {
    const dfs = (i) => {
        if (i === n) {
            ret.push(ans.slice());
            return;
        }
        for (let j = i; j < n; ++j) {
            if (isPalindrome(i, j) === 1) {
                ans.push(s.slice(i, j + 1));
                dfs(j + 1);
                ans.pop();
            }
        }
    }

    // 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串
    const isPalindrome = (i, j) => {
        if (f[i][j] !== 0) {
            return f[i][j];
        }
        if (i >= j) {
            f[i][j] = 1;
        } else if (s[i] === s[j]) {
            f[i][j] = isPalindrome(i + 1, j - 1);
        } else {
            f[i][j] = -1;
        }
        return f[i][j];
    }

    const n = s.length;
    const ret = [], ans = [];
    const f = new Array(n).fill(0).map(() => new Array(n).fill(0));

    dfs(0);
    return ret;
};
```

```go [sol2-Golang]
func partition(s string) (ans [][]string) {
    n := len(s)
    f := make([][]int8, n)
    for i := range f {
        f[i] = make([]int8, n)
    }

    // 0 表示尚未搜索，1 表示是回文串，-1 表示不是回文串
    var isPalindrome func(i, j int) int8
    isPalindrome = func(i, j int) int8 {
        if i >= j {
            return 1
        }
        if f[i][j] != 0 {
            return f[i][j]
        }
        f[i][j] = -1
        if s[i] == s[j] {
            f[i][j] = isPalindrome(i+1, j-1)
        }
        return f[i][j]
    }

    splits := []string{}
    var dfs func(int)
    dfs = func(i int) {
        if i == n {
            ans = append(ans, append([]string(nil), splits...))
            return
        }
        for j := i; j < n; j++ {
            if isPalindrome(i, j) > 0 {
                splits = append(splits, s[i:j+1])
                dfs(j + 1)
                splits = splits[:len(splits)-1]
            }
        }
    }
    dfs(0)
    return
}
```

```C [sol2-C]
// 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串
int isPalindrome(char* s, int** f, int i, int j) {
    if (f[i][j]) {
        return f[i][j];
    }
    if (i >= j) {
        return f[i][j] = 1;
    }
    return f[i][j] = (s[i] == s[j] ? isPalindrome(s, f, i + 1, j - 1) : -1);
}

void dfs(char* s, int n, int i, int** f, char*** ret, int* retSize, int* retColSize, char** ans, int* ansSize) {
    if (i == n) {
        char** tmp = malloc(sizeof(char*) * (*ansSize));
        for (int j = 0; j < (*ansSize); j++) {
            int ansColSize = strlen(ans[j]);
            tmp[j] = malloc(sizeof(char) * (ansColSize + 1));
            strcpy(tmp[j], ans[j]);
        }
        ret[*retSize] = tmp;
        retColSize[(*retSize)++] = *ansSize;
        return;
    }
    for (int j = i; j < n; ++j) {
        if (isPalindrome(s, f, i, j) == 1) {
            char* sub = malloc(sizeof(char) * (j - i + 2));
            for (int k = i; k <= j; k++) {
                sub[k - i] = s[k];
            }
            sub[j - i + 1] = '\0';
            ans[(*ansSize)++] = sub;
            dfs(s, n, j + 1, f, ret, retSize, retColSize, ans, ansSize);
            --(*ansSize);
        }
    }
}

char*** partition(char* s, int* returnSize, int** returnColumnSizes) {
    int n = strlen(s);
    int retMaxLen = n * (1 << n);
    char*** ret = malloc(sizeof(char**) * retMaxLen);
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * retMaxLen);
    int* f[n];
    for (int i = 0; i < n; i++) {
        f[i] = malloc(sizeof(int) * n);
        for (int j = 0; j < n; j++) {
            f[i][j] = 1;
        }
    }
    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 1; j < n; ++j) {
            f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];
        }
    }
    char* ans[n];
    int ansSize = 0;
    dfs(s, n, 0, f, ret, returnSize, *returnColumnSizes, ans, &ansSize);
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(n \cdot 2^n)$，其中 $n$ 是字符串 $s$ 的长度。在最坏情况下与方法一相同。

- 空间复杂度：$O(n \cdot 2^n)$。在最坏情况下与方法一相同。