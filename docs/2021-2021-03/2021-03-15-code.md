# 2021年03月15日 code
<a href="https://toutiao.io/k/et0t2lk">Go 工程化（九）：项目重构实践</a><br /><a href="https://toutiao.io/k/soqwk0v">Java 基础：日期与时间 API 用法详解</a><br /><a href="https://toutiao.io/k/peychra">Linux 文件 I/O 进化史（三）：Direct I/O 和 Linux AIO</a><br /><a href="https://toutiao.io/k/yqyaefq">聊一聊设计模式究竟是什么</a><br /><a href="https://toutiao.io/k/6sgy0vy">CompletableFuture 让你的代码免受阻塞之苦</a><br /><a href="https://toutiao.io/k/2zp36fa">任务队列 与 Celery 概述</a><br /><a href="https://toutiao.io/k/cdxmfnt">小布助手算法系统的探索、实践与思考</a><br /><a href="https://toutiao.io/k/r8yatl9">C++ folly 库解读（二）：small_vector 之小数据集下的 std::vector 替代方案</a><br /><a href="https://toutiao.io/k/0l1fx3m">怎么推导《最大子序和》的动态规划解法</a><br /><a href="https://toutiao.io/k/55xwxun">ChirpStack 自定义 JS codec 函数</a><br /><a href="https://toutiao.io/k/g0ejizv">工具 | 阿里开源的 iOS 自动化工具</a><br /><a href="https://toutiao.io/k/tm4wyb0">[推荐] Redis 专题：深入解读哨兵模式</a><br /><a href="https://toutiao.io/k/c1uc4c2">[推荐] 万字长文聊缓存（下）：应用级缓存</a><br /><a href="https://toutiao.io/k/tgp1ua8">[推荐] 面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</a><br /><a href="https://toutiao.io/k/r9tqaw3">[推荐] 副业刚需：在 GitHub 上也能年入百万？</a><br /><a href="https://toutiao.io/k/1d2mnjh">[推荐] 职场：3 天准备 5 天面试，跳槽完成</a><br /><a href="https://toutiao.io/k/4f2u3c5">[推荐] 内存管理设计精要</a><br /><a href="https://toutiao.io/k/hueiax0">[推荐] MySQL 索引从基础到原理，看这一篇就够了</a><br /><a href="https://toutiao.io/k/r5kgujp">[推荐] 从技术专家到技术管理，我对管理的思考</a><br /><a href="https://toutiao.io/k/yduqoev">[推荐] Redis 最佳实践：7 个维度 + 43 条使用规范，带你彻底玩转 Redis</a><br /><a href="https://toutiao.io/k/j7v5pee">[推荐] 国内有哪些顶级技术团队的博客值得推荐？</a><br /><a href="https://toutiao.io/k/3loin1u">[推荐] Golang 性能诊断看这篇就够了</a><br /><a href="https://toutiao.io/k/x6ro69m">[推荐] 高并发系统的限流策略：漏桶和令牌桶（附源码剖析）</a><br /><a href="https://toutiao.io/k/rmckht1">[推荐] 硬核！漫画图解 HTTP 基础 + 面试题</a><br /><a href="https://toutiao.io/k/cpf8p4q">[推荐] 流量复制方案对比：TCPCopy vs Goreplay</a><br /><a href="https://toutiao.io/k/ix2e9ja">[推荐] 中高级前端须注意的 40 条移动端 H5 坑位指南（网易三年实践）</a><br /><hr /><a href="https://github.com/benawad/dogehouse">Taking voice conversations to the moon 🚀</a><br /><a href="https://github.com/docker/awesome-compose">Awesome Docker Compose samples</a><br /><a href="https://github.com/sveltejs/kit">A monorepo for SvelteKit and friends</a><br /><a href="https://github.com/mobilecoinfoundation/mobilecoin">Private payments for mobile devices.</a><br /><a href="https://github.com/spring-projects-experimental/spring-native">Spring Native provides beta support for compiling Spring applications to native executables using GraalVM native-image compiler.</a><br /><a href="https://github.com/PowerShell/PowerShell">PowerShell for every system!</a><br /><a href="https://github.com/login?return_to=%2Foppia%2Foppia">A free, online learning platform to make quality education accessible for all.</a><br /><a href="https://github.com/flameshot-org/flameshot">Powerful yet simple to use screenshot software 🖥️ 📸</a><br /><a href="https://github.com/GorvGoyl/Clone-Wars">70+ open-source clones of popular sites like Airbnb, Amazon, Instagram, Netflix, Tiktok, Spotify, Whatsapp, Youtube etc. See source code, demo links, tech stack, github stars.</a><br /><a href="https://github.com/Ryujinx/Ryujinx">Experimental Nintendo Switch Emulator written in C#</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/login?return_to=%2Fliamg%2Ftraitor">Automatic Linux privesc via exploitation of low-hanging fruit e.g. gtfobins ⬆️ ☠️</a><br /><a href="https://github.com/pmmp/PocketMine-MP">A server software for Minecraft: Bedrock Edition in PHP</a><br /><a href="https://github.com/login?return_to=%2Fathensresearch%2Fathens">Free self-hosted desktop app: https://github.com/athensresearch/athens/releases; Paid tiers available through https://opencollective.com/athens; Try the demo at https://athensresearch.github.io/athens</a><br /><a href="https://github.com/google/security-research-pocs">Proof-of-concept codes created as part of security research done by Google Security Team.</a><br /><a href="https://github.com/login?return_to=%2Fsickcodes%2FDocker-OSX">Run Mac in a Docker! Run near native OSX-KVM in Docker! X11 Forwarding! CI/CD for OS X!</a><br /><a href="https://github.com/LeCoupa/awesome-cheatsheets">👩‍💻👨‍💻 Awesome cheatsheets for popular programming languages, frameworks and development tools. They include everything you should know in one single file.</a><br /><a href="https://github.com/sundowndev/PhoneInfoga">Advanced information gathering & OSINT framework for phone numbers</a><br /><a href="https://github.com/login?return_to=%2Fsickcodes%2Fosx-serial-generator">Mac Serial Generator - Generate complete sets of Serial Numbers for OSX-KVM, Docker-OSX and of course, OpenCore.</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/lucidrains/deep-daze">Simple command line tool for text to image generation using OpenAI's CLIP and Siren (Implicit neural representation network)</a><br /><a href="https://github.com/firstcontributions/first-contributions">🚀✨ Help beginners to contribute to open source projects</a><br /><a href="https://github.com/login?return_to=%2FJuliaLang%2Fjulia">The Julia Programming Language</a><br /><a href="https://github.com/srcrs/UnicomTask">联通手机营业厅自动做任务、签到、领流量、领积分等。</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><hr />螺旋矩阵<br /><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" style="width: 242px; height: 242px;" />
<pre>
<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" style="width: 322px; height: 242px;" />
<pre>
<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 <= m, n <= 10</code></li>
	<li><code>-100 <= matrix[i][j] <= 100</code></li>
</ul>
<br />#### 方法一：模拟

可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。

判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 $\textit{visited}$，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 $\textit{visited}$ 中的对应位置的元素设为已访问。

如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```Java [sol1-Java]
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int row = 0, column = 0;
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order.add(matrix[row][column]);
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
}
```

```C++ [sol1-C++]
class Solution {
private:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }
        
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(columns));
        int total = rows * columns;
        vector<int> order(total);

        int row = 0, column = 0;
        int directionIndex = 0;
        for (int i = 0; i < total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
};
```

```Python [sol1-Python3]
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        visited = [[False] * columns for _ in range(rows)]
        total = rows * columns
        order = [0] * total

        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        row, column = 0, 0
        directionIndex = 0
        for i in range(total):
            order[i] = matrix[row][column]
            visited[row][column] = True
            nextRow, nextColumn = row + directions[directionIndex][0], column + directions[directionIndex][1]
            if not (0 <= nextRow < rows and 0 <= nextColumn < columns and not visited[nextRow][nextColumn]):
                directionIndex = (directionIndex + 1) % 4
            row += directions[directionIndex][0]
            column += directions[directionIndex][1]
        return order
```

```golang [sol1-Golang]
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return []int{}
    }
    rows, columns := len(matrix), len(matrix[0])
    visited := make([][]bool, rows)
    for i := 0; i < rows; i++ {
        visited[i] = make([]bool, columns)
    }

    var (
        total = rows * columns
        order = make([]int, total)
        row, column = 0, 0
        directions = [][]int{[]int{0, 1}, []int{1, 0}, []int{0, -1}, []int{-1, 0}}
        directionIndex = 0
    )

    for i := 0; i < total; i++ {
        order[i] = matrix[row][column]
        visited[row][column] = true
        nextRow, nextColumn := row + directions[directionIndex][0], column + directions[directionIndex][1]
        if nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn] {
            directionIndex = (directionIndex + 1) % 4
        }
        row += directions[directionIndex][0]
        column += directions[directionIndex][1]
    }
    return order
}
```

```JavaScript [sol1-JavaScript]
var spiralOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length) {
        return [];
    }
    const rows = matrix.length, columns = matrix[0].length;
    const visited = new Array(rows).fill(0).map(() => new Array(columns).fill(false));
    const total = rows * columns;
    const order = new Array(total).fill(0);

    let directionIndex = 0, row = 0, column = 0;
    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    for (let i = 0; i < total; i++) { 
        order[i] = matrix[row][column];
        visited[row][column] = true;
        const nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
        if (!(0 <= nextRow && nextRow < rows && 0 <= nextColumn && nextColumn < columns && !(visited[nextRow][nextColumn]))) {
            directionIndex = (directionIndex + 1) % 4;
        }
        row += directions[directionIndex][0];
        column += directions[directionIndex][1];
    }
    return order;
};
```

```C [sol1-C]
int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    if (matrixSize == 0 || matrixColSize[0] == 0) {
        *returnSize = 0;
        return NULL;
    }

    int rows = matrixSize, columns = matrixColSize[0];
    int visited[rows][columns];
    memset(visited, 0, sizeof(visited));
    int total = rows * columns;
    int* order = malloc(sizeof(int) * total);
    *returnSize = total;

    int row = 0, column = 0;
    int directionIndex = 0;
    for (int i = 0; i < total; i++) {
        order[i] = matrix[row][column];
        visited[row][column] = true;
        int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
        if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
            directionIndex = (directionIndex + 1) % 4;
        }
        row += directions[directionIndex][0];
        column += directions[directionIndex][1];
    }
    return order;
}
```

**复杂度分析**

* 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。

* 空间复杂度：$O(mn)$。需要创建一个大小为 $m \times n$ 的矩阵 $\textit{visited}$ 记录每个位置是否被访问过。

#### 方法二：按层模拟

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 $k$ 层是到最近边界距离为 $k$ 的所有顶点。例如，下图矩阵最外层元素都是第 $1$ 层，次外层元素都是第 $2$ 层，剩下的元素都是第 $3$ 层。

```
[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
```

对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 $(\textit{top}, \textit{left})$，右下角位于 $(\textit{bottom}, \textit{right})$，按照如下顺序遍历当前层的元素。

1. 从左到右遍历上侧元素，依次为 $(\textit{top}, \textit{left})$ 到 $(\textit{top}, \textit{right})$。

2. 从上到下遍历右侧元素，依次为 $(\textit{top} + 1, \textit{right})$ 到 $(\textit{bottom}, \textit{right})$。

3. 如果 $\textit{left} < \textit{right}$ 且 $\textit{top} < \textit{bottom}$，则从右到左遍历下侧元素，依次为 $(\textit{bottom}, \textit{right} - 1)$ 到 $(\textit{bottom}, \textit{left} + 1)$，以及从下到上遍历左侧元素，依次为 $(\textit{bottom}, \textit{left})$ 到 $(\textit{top} + 1, \textit{left})$。

遍历完当前层的元素之后，将 $\textit{left}$ 和 $\textit{top}$ 分别增加 $1$，将 $\textit{right}$ 和 $\textit{bottom}$ 分别减少 $1$，进入下一层继续遍历，直到遍历完所有元素为止。

![fig1](https://assets.leetcode-cn.com/solution-static/54/54_fig1.png)

```Java [sol2-Java]
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.add(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.add(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.add(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.add(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
}
```

```C++ [sol2-C++]
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }

        int rows = matrix.size(), columns = matrix[0].size();
        vector<int> order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.push_back(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.push_back(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.push_back(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.push_back(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
};
```

```Python [sol2-Python3]
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom:
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order
```

```golang [sol2-Golang]
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return []int{}
    }
    var (
        rows, columns = len(matrix), len(matrix[0])
        order = make([]int, rows * columns)
        index = 0
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
    )

    for left <= right && top <= bottom {
        for column := left; column <= right; column++ {
            order[index] = matrix[top][column]
            index++
        }
        for row := top + 1; row <= bottom; row++ {
            order[index] = matrix[row][right]
            index++
        }
        if left < right && top < bottom {
            for column := right - 1; column > left; column-- {
                order[index] = matrix[bottom][column]
                index++
            }
            for row := bottom; row > top; row-- {
                order[index] = matrix[row][left]
                index++
            }
        }
        left++
        right--
        top++
        bottom--
    }
    return order
}
```

```JavaScript [sol2-JavaScript]
var spiralOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length) {
        return [];
    }

    const rows = matrix.length, columns = matrix[0].length;
    const order = [];
    let left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left <= right && top <= bottom) {
        for (let column = left; column <= right; column++) {
            order.push(matrix[top][column]);
        }
        for (let row = top + 1; row <= bottom; row++) {
            order.push(matrix[row][right]);
        }
        if (left < right && top < bottom) {
            for (let column = right - 1; column > left; column--) {
                order.push(matrix[bottom][column]);
            }
            for (let row = bottom; row > top; row--) {
                order.push(matrix[row][left]);
            }
        }
        [left, right, top, bottom] = [left + 1, right - 1, top + 1, bottom - 1];
    }
    return order;
};
```

```C [sol2-C]
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    if (matrixSize == 0 || matrixColSize[0] == 0) {
        *returnSize = 0;
        return NULL;
    }

    int rows = matrixSize, columns = matrixColSize[0];
    int total = rows * columns;
    int* order = malloc(sizeof(int) * total);
    *returnSize = 0;

    int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left <= right && top <= bottom) {
        for (int column = left; column <= right; column++) {
            order[(*returnSize)++] = matrix[top][column];
        }
        for (int row = top + 1; row <= bottom; row++) {
            order[(*returnSize)++] = matrix[row][right];
        }
        if (left < right && top < bottom) {
            for (int column = right - 1; column > left; column--) {
                order[(*returnSize)++] = matrix[bottom][column];
            }
            for (int row = bottom; row > top; row--) {
                order[(*returnSize)++] = matrix[row][left];
            }
        }
        left++;
        right--;
        top++;
        bottom--;
    }
    return order;
}
```

**复杂度分析**

* 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。

* 空间复杂度：$O(1)$。除了输出数组以外，空间复杂度是常数。