# 2021年04月18日 code
<a href="https://toutiao.io/k/syxnrph">OpenResty 实现限流</a><br /><a href="https://toutiao.io/k/mbgrz85">CAP：分布式事务的解决方案</a><br /><a href="https://toutiao.io/k/6ld5fxn">Nginx Buffer 机制引发的下载故障</a><br /><a href="https://toutiao.io/k/5gpirgo">用 Go struct 不能犯的一个低级错误</a><br /><a href="https://toutiao.io/k/9squgg8">资料 | Go 语言实用教程</a><br /><a href="https://toutiao.io/k/yxdpzkx">使用协程和 Flow 简化 API 设计</a><br /><a href="https://toutiao.io/k/9j7191v">Android 逆向之某 App 逆向实践</a><br /><a href="https://toutiao.io/k/acoe8qh">寒门学子的奋斗史（三）：走进大城市</a><br /><a href="https://toutiao.io/k/vahzjb1">React 技术揭秘</a><br /><a href="https://toutiao.io/k/qw374hn">Kubernetes 部署 Longhorn</a><br /><a href="https://toutiao.io/k/3bv147y">[推荐] 免费正版 IntelliJ IDEA license 详细指南</a><br /><a href="https://toutiao.io/k/3etk65w">[推荐] 基于 OpenResty 长连接推送的演进</a><br /><a href="https://toutiao.io/k/68q4m1v">[推荐] 架构设计方法论</a><br /><a href="https://toutiao.io/k/82eogba">[推荐] Git 分支管理策略与工作流程</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/zdnq3fy">[推荐] 踩坑 MySQL 索引，看看你真的会用吗？</a><br /><a href="https://toutiao.io/k/we8gr61">[推荐] 从需求出发设计一条开源持续部署流水线</a><br /><a href="https://toutiao.io/k/6aau0fc">[推荐] 一文读懂，DDD 落地数据库设计实战</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/hti1ill">[推荐] 其实，每次面试的问题都逃不过这几方面</a><br /><a href="https://toutiao.io/k/pmlwnuy">[推荐] 有哪些可以提高代码质量的书籍推荐？</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/oa4amzb">[推荐] 使用 Git 丢失代码的 N 种操作，您中招了吗？</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><hr /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/calendso/calendso">The open-source Calendly alternative.</a><br /><a href="https://github.com/facebookresearch/pytorchvideo">A deep learning library for video understanding research.</a><br /><a href="https://github.com/login?return_to=%2Fsupabase%2Fsupabase">The open source Firebase alternative. Follow to stay updated about our public Beta.</a><br /><a href="https://github.com/PathOfBuildingCommunity/PathOfBuilding">Offline build planner for Path of Exile.</a><br /><a href="https://github.com/flashlight/flashlight">A C++ standalone library for machine learning</a><br /><a href="https://github.com/login?return_to=%2Fferib%2FD2R-Offline">Diablo II: Resurrected, Offline-mode patcher</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/ashishpatel26/500-AI-Machine-learning-Deep-learning-Computer-vision-NLP-Projects-with-code">500 AI Machine learning Deep learning Computer vision NLP Projects with code</a><br /><a href="https://github.com/kgrzybek/modular-monolith-with-ddd">Full Modular Monolith application with Domain-Driven Design approach.</a><br /><a href="https://github.com/openethereum/openethereum">The fast, light, and robust client for the Ethereum mainnet.</a><br /><a href="https://github.com/microsoft/Swin-Transformer">This is an official implementation for "Swin Transformer: Hierarchical Vision Transformer using Shifted Windows".</a><br /><a href="https://github.com/cli/cli">GitHub’s official command line tool</a><br /><a href="https://github.com/everestpipkin/tools-list">Open source, experimental, and tiny tools roundup</a><br /><a href="https://github.com/itdevbooks/pdf">编程电子书，电子书，编程书籍，包括C，C#，Docker，Elasticsearch，Git，Hadoop，HeadFirst，Java，Javascript，jvm，Kafka，Linux，Maven，MongoDB，MyBatis，MySQL，Netty，Nginx，Python，RabbitMQ，Redis，Scala，Solr，Spark，Spring，SpringBoot，SpringCloud，TCPIP，Tomcat，Zookeeper，人工智能，大数据类，并发编程，数据库类，数据挖掘，新面试题，架构设计，算法系列，计算机类，设计模式，软件测试，重构优化，等更多分类</a><br /><a href="https://github.com/Forescout/project-memoria-detector"></a><br /><a href="https://github.com/ChristianChiarulli/LunarVim">A Neovim config made with sane defaults</a><br /><a href="https://github.com/login?return_to=%2Fshalzuth%2FD2RModding">Modding for Diablo 2 Resurrected</a><br /><a href="https://github.com/ekzhang/graphics-workshop">Learn computer graphics by writing GPU shaders!</a><br /><a href="https://github.com/avboy1337/1195777-chrome0day"></a><br /><a href="https://github.com/terraform-providers/terraform-provider-azurerm">Terraform provider for Azure Resource Manager</a><br /><a href="https://github.com/llvm/llvm-project">The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Note: the repository does not accept github pull requests at this moment. Please submit your patches at http://reviews.llvm.org.</a><br /><a href="https://github.com/puppeteer/puppeteer">Headless Chrome Node.js API</a><br /><a href="https://github.com/hhroot/2021_Hvv">2021 hw</a><br /><a href="https://github.com/louisfb01/start-machine-learning-in-2020">A complete guide to start and improve in machine learning (ML), artificial intelligence (AI) in 2021 without ANY background in the field and stay up-to-date with the latest news and state-of-the-art techniques!</a><br /><hr />删除有序数组中的重复项<br /><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>

<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>

<p> </p>

<p><strong>说明:</strong></p>

<p>为什么返回数值是整数，但输出的答案是数组呢?</p>

<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>

<p>你可以想象内部操作如下:</p>

<pre>
// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
</pre>
 

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,2]
<strong>输出：</strong>2, nums = [1,2]
<strong>解释：</strong>函数应该返回新的长度 <strong><code>2</code></strong> ，并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2 </code></strong><code>。</code>不需要考虑数组中超出新长度后面的元素。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,0,1,1,1,2,2,3,3,4]
<strong>输出：</strong>5, nums = [0,1,2,3,4]
<strong>解释：</strong>函数应该返回新的长度 <strong><code>5</code></strong> ， 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong> 。不需要考虑数组中超出新长度后面的元素。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>0 <= nums.length <= 3 * 10<sup>4</sup></code></li>
	<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>
	<li><code>nums</code> 已按升序排列</li>
</ul>

<p> </p>
<br />#### 方法一：双指针

这道题目的要求是：对给定的有序数组 $\textit{nums}$ 删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，上述操作必须通过原地修改数组的方法，使用 $O(1)$ 的空间复杂度完成。

由于给定的数组 $\textit{nums}$ 是有序的，因此对于任意 $i<j$，如果 $\textit{nums}[i]=\textit{nums}[j]$，则对任意 $i \le k \le j$，必有 $\textit{nums}[i]=\textit{nums}[k]=\textit{nums}[j]$，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。

如果数组 $\textit{nums}$ 的长度为 $0$，则数组不包含任何元素，因此返回 $0$。

当数组 $\textit{nums}$ 的长度大于 $0$ 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 $\textit{nums}[0]$ 保持原状即可，从下标 $1$ 开始删除重复元素。

定义两个指针 $\textit{fast}$ 和 $\textit{slow}$ 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 $1$。

假设数组 $\textit{nums}$ 的长度为 $n$。将快指针 $\textit{fast}$ 依次遍历从 $1$ 到 $n-1$ 的每个位置，对于每个位置，如果 $\textit{nums}[\textit{fast}] \ne \textit{nums}[\textit{fast}-1]$，说明 $\textit{nums}[\textit{fast}]$ 和之前的元素都不同，因此将 $\textit{nums}[\textit{fast}]$ 的值复制到 $\textit{nums}[\textit{slow}]$，然后将 $\textit{slow}$ 的值加 $1$，即指向下一个位置。

遍历结束之后，从 $\textit{nums}[0]$ 到 $\textit{nums}[\textit{slow}-1]$ 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 $\textit{slow}$，返回 $\textit{slow}$ 即可。

<![fig1](https://assets.leetcode-cn.com/solution-static/26/1.png),![fig2](https://assets.leetcode-cn.com/solution-static/26/2.png),![fig3](https://assets.leetcode-cn.com/solution-static/26/3.png),![fig4](https://assets.leetcode-cn.com/solution-static/26/4.png),![fig5](https://assets.leetcode-cn.com/solution-static/26/5.png),![fig6](https://assets.leetcode-cn.com/solution-static/26/6.png),![fig7](https://assets.leetcode-cn.com/solution-static/26/7.png),![fig8](https://assets.leetcode-cn.com/solution-static/26/8.png),![fig9](https://assets.leetcode-cn.com/solution-static/26/9.png),![fig10](https://assets.leetcode-cn.com/solution-static/26/10.png),![fig11](https://assets.leetcode-cn.com/solution-static/26/11.png)>

```Java [sol1-Java]
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int fast = 1, slow = 1;
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
```

```JavaScript [sol1-JavaScript]
var removeDuplicates = function(nums) {
    const n = nums.length;
    if (n === 0) {
        return 0;
    }
    let fast = 1, slow = 1;
    while (fast < n) {
        if (nums[fast] !== nums[fast - 1]) {
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
};
```

```go [sol1-Golang]
func removeDuplicates(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    slow := 1
    for fast := 1; fast < n; fast++ {
        if nums[fast] != nums[fast-1] {
            nums[slow] = nums[fast]
            slow++
        }
    }
    return slow
}
```

```Python [sol1-Python3]
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        fast = slow = 1
        while fast < n:
            if nums[fast] != nums[fast - 1]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        
        return slow
```

```C++ [sol1-C++]
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int fast = 1, slow = 1;
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
};
```

```C [sol1-C]
int removeDuplicates(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0;
    }
    int fast = 1, slow = 1;
    while (fast < numsSize) {
        if (nums[fast] != nums[fast - 1]) {
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。快指针和慢指针最多各移动 $n$ 次。

- 空间复杂度：$O(1)$。只需要使用常数的额外空间。