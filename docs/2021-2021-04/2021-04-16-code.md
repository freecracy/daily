# 2021年04月16日 code
<a href="https://toutiao.io/k/47fg3nq">Redis 入门：Redis 概念和基础</a><br /><a href="https://toutiao.io/k/4zqz7k1">RESTful API 设计最佳实践</a><br /><a href="https://toutiao.io/k/a7u76ek">数据调度组件：基于 Azkaban 协调时序任务执行</a><br /><a href="https://toutiao.io/k/twm9mo2">详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</a><br /><a href="https://toutiao.io/k/ehhe1vm">ElasticSearch 如何使用 ik 进行中文分词？</a><br /><a href="https://toutiao.io/k/mo14ttn">软件配置管理实践：基于 Ansible 和 Nacos</a><br /><a href="https://toutiao.io/k/sr6qcwt">一款轻阅读应用 ReadIT，记录我的 RN 躺坑之旅</a><br /><a href="https://toutiao.io/k/e1gd9kq">清理 Spring Boot 应用无用的 metrics 指标</a><br /><a href="https://toutiao.io/k/id9hj5d">代码覆盖率统计在京东主 App 的接入探索</a><br /><a href="https://toutiao.io/k/iiyx0qm">漫画：为什么祖传代码被称为 “屎山”？</a><br /><a href="https://toutiao.io/k/cprz8fg">知乎的 Flink 数据集成平台建设实践</a><br /><a href="https://toutiao.io/k/w21yfcc">蚂蚁是如何改进 k8s 集群敏感信息的安全防护的？</a><br /><a href="https://toutiao.io/k/akhoseo">不会持续集成和持续部署？今天带你玩转 CI/CD</a><br /><a href="https://toutiao.io/k/klg7vm5">React 的操作系统梦，任重道远</a><br /><a href="https://toutiao.io/k/0ki4v7l">万字详文阐释程序员修炼之道</a><br /><a href="https://toutiao.io/k/75hnmuz">我为什么不选择去大厂？</a><br /><a href="https://toutiao.io/k/s0673fu">AI 入行那些事儿（九）：人工智能对人类社会的影响</a><br /><a href="https://toutiao.io/k/0msktdi">升级库文件后如何查找需要重启的服务</a><br /><a href="https://toutiao.io/k/up6v09r">不可不知的 Jupyter Notebook 使用技巧</a><br /><a href="https://toutiao.io/k/g0rfr5w">Xcode 编译疾如风系列（一）：分析编译耗时</a><br /><a href="https://toutiao.io/k/gauwubg">[推荐] 我很久没写代码了，但我是个好架构师</a><br /><a href="https://toutiao.io/k/we8gr61">[推荐] 从需求出发设计一条开源持续部署流水线</a><br /><a href="https://toutiao.io/k/iyge3cy">[推荐] 史上最全教程：idea 将 Java 项目打包 Jar 包，并生成 exe 可执行文件</a><br /><a href="https://toutiao.io/k/6aau0fc">[推荐] 一文读懂，DDD 落地数据库设计实战</a><br /><a href="https://toutiao.io/k/pmlwnuy">[推荐] 有哪些可以提高代码质量的书籍推荐？</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/hti1ill">[推荐] 其实，每次面试的问题都逃不过这几方面</a><br /><a href="https://toutiao.io/k/6jo6q1t">[推荐] Go 应用优化指北</a><br /><a href="https://toutiao.io/k/oa4amzb">[推荐] 使用 Git 丢失代码的 N 种操作，您中招了吗？</a><br /><a href="https://toutiao.io/k/68q4m1v">[推荐] 架构设计方法论</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><a href="https://toutiao.io/k/zdnq3fy">[推荐] 踩坑 MySQL 索引，看看你真的会用吗？</a><br /><a href="https://toutiao.io/k/0yy2iga">[推荐] [译] Uber：面向领域的微服务架构</a><br /><a href="https://toutiao.io/k/bi1fr9y">[推荐] 码云 Gitee：高并发大存储下的架构演进之路</a><br /><hr /><a href="https://github.com/elixir-nx/livebook">Interactive and collaborative code notebooks - made with Phoenix LiveView.</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/login?return_to=%2Fdenoland%2Fdeno">A secure JavaScript and TypeScript runtime</a><br /><a href="https://github.com/nrwl/nx">Powerful, Extensible Dev Tools</a><br /><a href="https://github.com/tauri-apps/tauri">Build smaller, faster, and more secure desktop applications with a web frontend.</a><br /><a href="https://github.com/r4j0x00/exploits"></a><br /><a href="https://github.com/GorvGoyl/Clone-Wars">100+ open-source clones of popular sites like Airbnb, Amazon, Instagram, Netflix, Tiktok, Spotify, Whatsapp, Youtube etc. See source code, demo links, tech stack, github stars.</a><br /><a href="https://github.com/EvgSkv/logica">Logica is a logic programming language that compiles to StandardSQL and runs on Google BigQuery.</a><br /><a href="https://github.com/itdevbooks/pdf">编程电子书，电子书，编程书籍，包括C，C#，Docker，Elasticsearch，Git，Hadoop，HeadFirst，Java，Javascript，jvm，Kafka，Linux，Maven，MongoDB，MyBatis，MySQL，Netty，Nginx，Python，RabbitMQ，Redis，Scala，Solr，Spark，Spring，SpringBoot，SpringCloud，TCPIP，Tomcat，Zookeeper，人工智能，大数据类，并发编程，数据库类，数据挖掘，新面试题，架构设计，算法系列，计算机类，设计模式，软件测试，重构优化，等更多分类</a><br /><a href="https://github.com/PathOfBuildingCommunity/PathOfBuilding">Offline build planner for Path of Exile.</a><br /><a href="https://github.com/easychen/one-person-businesses-methodology">一人公司方法论</a><br /><a href="https://github.com/d2l-ai/d2l-zh">《动手学深度学习》：面向中文读者、能运行、可讨论。中英文版被全球175所大学采用教学。</a><br /><a href="https://github.com/opensearch-project/OpenSearch">Open source distributed and RESTful search engine.</a><br /><a href="https://github.com/microsoft/Swin-Transformer">This is an official implementation for "Swin Transformer: Hierarchical Vision Transformer using Shifted Windows".</a><br /><a href="https://github.com/mozilla/TTS">🤖 💬 Deep learning for Text to Speech (Discussion forum: https://discourse.mozilla.org/c/tts)</a><br /><a href="https://github.com/FirebaseExtended/flutterfire">🔥 A collection of Firebase plugins for Flutter apps.</a><br /><a href="https://github.com/google/leveldb">LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</a><br /><a href="https://github.com/login?return_to=%2Ffoxlet%2FmacOS-Simple-KVM">Tools to set up a quick macOS VM in QEMU, accelerated by KVM.</a><br /><a href="https://github.com/ChartsCSS/charts.css">Open source CSS framework for data visualization.</a><br /><a href="https://github.com/login?return_to=%2Fumputun%2Freproxy">Simple edge server / reverse proxy</a><br /><a href="https://github.com/kubernetes/kubernetes">Production-Grade Container Scheduling and Management</a><br /><a href="https://github.com/bradtraversy/vanillawebprojects">Mini projects built with HTML5, CSS & JavaScript. No frameworks or libraries</a><br /><a href="https://github.com/huggingface/transformers">🤗Transformers: State-of-the-art Natural Language Processing for Pytorch and TensorFlow 2.0.</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/pixeltris/TwitchAdSolutions"></a><br /><hr />扰乱字符串<br />使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：
<ol>
	<li>如果字符串的长度为 1 ，算法停止</li>
	<li>如果字符串的长度 > 1 ，执行下述步骤：
	<ul>
		<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>
		<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>
		<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
	</ul>
	</li>
</ol>

<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code><em> </em>和 <code>s2</code>，判断 <code>s2</code><em> </em>是否是 <code>s1</code><em> </em>的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s1 = "great", s2 = "rgeat"
<strong>输出：</strong>true
<strong>解释：</strong>s1 上可能发生的一种情形是：
"great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串
"gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」
"gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
"g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
"r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"
"r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」
算法终止，结果字符串和 s2 相同，都是 "rgeat"
这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s1 = "abcde", s2 = "caebd"
<strong>输出：</strong>false
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s1 = "a", s2 = "a"
<strong>输出：</strong>true
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>s1.length == s2.length</code></li>
	<li><code>1 <= s1.length <= 30</code></li>
	<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>
</ul>
<br />#### 方法一：动态规划

**思路与算法**

显然「扰乱字符串」的关系是具有对称性的，即如果 $s_1$ 是 $s_2$ 的扰乱字符串，那么 $s_2$ 也是 $s_1$ 的扰乱字符串。为了叙述方便，我们称这种情况下，$s_1$ 和 $s_2$ 是「和谐」的。

那么如何判断 $s_1$ 和 $s_2$ 是否「和谐」呢？我们首先可以想到几个简单的判断方法：

- 如果 $s_1 = s_2$，那么它们是「和谐」的；

- 如果 $s_1$ 和 $s_2$ 的长度不同，那么它们一定不是「和谐」的；

- 如果 $s_1$ 中某个字符 $c$ 出现了 $x_1$ 次，而 $c$ 在 $s_2$ 中出现了 $x_2$ 次，且 $x_1 \neq x_2$，那么它们一定不是「和谐」的。这是因为任意操作都不会改变一个字符串中的字符种类以及数量。

那么对于剩下的情况，我们该如何判断呢？我们可以从 $s_1$ 的分割方法入手。假设 $s_1$ 作为根节点时被分割成了 $l(s_1)$ 以及 $r(s_1)$ 两个子串，那么：

- 如果 $l(s_1)$ 和 $r(s_1)$ 没有被交换，那么 $s_2$ 需要存在一种分割方法 $s_2 = l(s_2) + r(s_2)$，使得 $l(s_1)$ 和 $l(s_2)$ 是「和谐」的，并且 $r(s_1)$ 和 $r(s_2)$ 也是「和谐」的；

- 如果 $l(s_1)$ 和 $r(s_1)$ 被交换了，那么 $s_2$ 需要存在一种分割方法 $s_2 = l(s_2) + r(s_2)$，使得 $l(s_1)$ 和 $r(s_2)$ 是「和谐」的，并且 $r(s_1)$ 和 $l(s_2)$ 也是「和谐」的。

![fig1](https://assets.leetcode-cn.com/solution-static/87/1.png)

这样一来，我们就把原本需要解决的问题划分成了两个本质相同，但规模更小的子问题，因此可以考虑使用动态规划解决。

设 $f(s_1, s_2)$ 表示 $s_1$ 和 $s_2$ 是否「和谐」，那么我们可以写出状态转移方程：

$$
f(s_1, s_2) =
\begin{cases}
\text{True}, & \quad s_1=s_2 \\
\text{False}, & \quad 存在某个字符~c，它在~s_1~和~s_2~中的出现次数不同 \\
\end{cases}
$$

因为题目保证给定的原始字符串的长度相同，因此我们只需要判断上面的两种情况。如果 $s_1$ 和 $s_2$ 不符合这两种情况，那么我们需要枚举分割点。

设 $s_1$ 和 $s_2$ 的长度为 $n$，我们用 $s_1(x, y)$ 表示从 $s_1$ 从第 $x$ 个字符（从 $0$ 开始编号）开始，长度为 $y$ 的子串。由于分割出的两个字符串不能为空串，那么其中一个字符串就是 $s_1(0, i)$，另一个字符串是 $s_1(i, n-i)$。

- 对于 $l(s_1)$ 和 $r(s_1)$ 没有被交换的情况，$s_2$ 同样需要被分为 $s_2(0, i)$ 以及 $s_2(i, n-i)$，否则长度不同的字符串是不可能「和谐」的。因此我们可以写出状态转移方程：

    $$
    f(s_1, s_2) = \bigvee_{i=1}^{n-1} \big( f(s_1(0, i), s_2(0, i)) \wedge f(s_1(i, n-i), s_2(i, n-i)) \big)
    $$

    其中 $\wedge$ 表示与运算，即 $s_1$ 和 $s_2$ 分割出的两对字符串都要是「和谐」的；$\vee$ 表示或运算，即只要有一种满足要求的分割方法，$s_1$ 和 $s_2$ 就是和谐的。

- 对于 $l(s_1)$ 和 $r(s_1)$ 被交换的情况，$s_2$ 需要被分为 $s_2(0, n-i)$ 以及 $s_2(n-i, i)$，这样对应的长度才会相同。因此我们可以写出状态转移方程：

    $$
    f(s_1, s_2) = \bigvee_{i=1}^{n-1} \big( f(s_1(0, i), s_2(n-i, i)) \wedge f(s_1(i, n-i), s_2(0, n-i)) \big)
    $$

我们将上面两种状态转移方程用 $\vee$ 或运算拼在一起，即可得到最终的状态转移方程。

**细节**

细节部分比较长，希望读者仔细阅读，否则写出来的代码可能会较为复杂，或者使用较多不必要的空间。

1. 在进行状态转移时，我们需要**先计算出较短的字符串对应的 $f$ 值**，再去转移计算出较长的字符串对应的 $f$ 值，这是因为我们需要**保证在计算 $f(s_1, s_2)$ 时，所有它们的子串对应的状态都需要被计算过**。因此，如果我们使用常规的动态规划方法编写代码，可能会受到计算顺序的困扰，使得代码冗长。

    而我们可以考虑使用「记忆化搜索」自顶向下地进行动态规划，这样我们只需要用题目中给定的两个原始字符串开始，递归地计算所有的 $f$ 值，而无需考虑计算顺序。

2. 由于我们使用记忆化搜索，因此我们需要把 $s_1$ 和 $s_2$ 作为参数传入记忆化搜索使用的递归函数。这样一来，在递归传递参数的过程中，会使用到大量字符串的切片、拷贝等操作，使得时空复杂度不那么优。本题中，由于给定原始字符串的长度不超过 $30$，因此不会产生太大的影响，但我们还是要尽可能对代码进行优化。

    一种通用的优化方法是，我们将状态变更为 $f(i_1, i_2, \textit{length})$，表示第一个字符串是原始字符串从第 $i_1$ 个字符开始，长度为 $\textit{length}$ 的子串，第二个字符串是原始字符串从第 $i_2$ 个字符开始，长度为 $\textit{length}$ 的子串。可以发现，我们只是改变了表达 $s_1$ 和 $s_2$ 的方式，但此时我们只需要在递归时传递三个整数类型的变量，省去了字符串的操作；

**代码**

```C++ [sol1-C++]
class Solution {
private:
    // 记忆化搜索存储状态的数组
    // -1 表示 false，1 表示 true，0 表示未计算
    int memo[30][30][31];
    string s1, s2;

public:
    bool checkIfSimilar(int i1, int i2, int length) {
        unordered_map<int, int> freq;
        for (int i = i1; i < i1 + length; ++i) {
            ++freq[s1[i]];
        }
        for (int i = i2; i < i2 + length; ++i) {
            --freq[s2[i]];
        }
        if (any_of(freq.begin(), freq.end(), [](const auto& entry) {return entry.second != 0;})) {
            return false;
        }
        return true;
    }

    // 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐
    bool dfs(int i1, int i2, int length) {
        if (memo[i1][i2][length]) {
            return memo[i1][i2][length] == 1;
        }

        // 判断两个子串是否相等
        if (s1.substr(i1, length) == s2.substr(i2, length)) {
            memo[i1][i2][length] = 1;
            return true;
        }

        // 判断是否存在字符 c 在两个子串中出现的次数不同
        if (!checkIfSimilar(i1, i2, length)) {
            memo[i1][i2][length] = -1;
            return false;
        }
        
        // 枚举分割位置
        for (int i = 1; i < length; ++i) {
            // 不交换的情况
            if (dfs(i1, i2, i) && dfs(i1 + i, i2 + i, length - i)) {
                memo[i1][i2][length] = 1;
                return true;
            }
            // 交换的情况
            if (dfs(i1, i2 + length - i, i) && dfs(i1 + i, i2, length - i)) {
                memo[i1][i2][length] = 1;
                return true;
            }
        }

        memo[i1][i2][length] = -1;
        return false;
    }

    bool isScramble(string s1, string s2) {
        memset(memo, 0, sizeof(memo));
        this->s1 = s1;
        this->s2 = s2;
        return dfs(0, 0, s1.size());
    }
};
```

```Java [sol1-Java]
class Solution {
    // 记忆化搜索存储状态的数组
    // -1 表示 false，1 表示 true，0 表示未计算
    int[][][] memo;
    String s1, s2;

    public boolean isScramble(String s1, String s2) {
        int length = s1.length();
        this.memo = new int[length][length][length + 1];
        this.s1 = s1;
        this.s2 = s2;
        return dfs(0, 0, length);
    }

    // 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐
    public boolean dfs(int i1, int i2, int length) {
        if (memo[i1][i2][length] != 0) {
            return memo[i1][i2][length] == 1;
        }

        // 判断两个子串是否相等
        if (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) {
            memo[i1][i2][length] = 1;
            return true;
        }

        // 判断是否存在字符 c 在两个子串中出现的次数不同
        if (!checkIfSimilar(i1, i2, length)) {
            memo[i1][i2][length] = -1;
            return false;
        }
        
        // 枚举分割位置
        for (int i = 1; i < length; ++i) {
            // 不交换的情况
            if (dfs(i1, i2, i) && dfs(i1 + i, i2 + i, length - i)) {
                memo[i1][i2][length] = 1;
                return true;
            }
            // 交换的情况
            if (dfs(i1, i2 + length - i, i) && dfs(i1 + i, i2, length - i)) {
                memo[i1][i2][length] = 1;
                return true;
            }
        }

        memo[i1][i2][length] = -1;
        return false;
    }

    public boolean checkIfSimilar(int i1, int i2, int length) {
        Map<Character, Integer> freq = new HashMap<Character, Integer>();
        for (int i = i1; i < i1 + length; ++i) {
            char c = s1.charAt(i);
            freq.put(c, freq.getOrDefault(c, 0) + 1);
        }
        for (int i = i2; i < i2 + length; ++i) {
            char c = s2.charAt(i);
            freq.put(c, freq.getOrDefault(c, 0) - 1);
        }
        for (Map.Entry<Character, Integer> entry : freq.entrySet()) {
            int value = entry.getValue();
            if (value != 0) {
                return false;
            }
        }
        return true;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        @cache
        def dfs(i1: int, i2: int, length: int) -> bool:
            """
            第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐
            """

            # 判断两个子串是否相等
            if s1[i1:i1+length] == s2[i2:i2+length]:
                return True
            
            # 判断是否存在字符 c 在两个子串中出现的次数不同
            if Counter(s1[i1:i1+length]) != Counter(s2[i2:i2+length]):
                return False
            
            # 枚举分割位置
            for i in range(1, length):
                # 不交换的情况
                if dfs(i1, i2, i) and dfs(i1 + i, i2 + i, length - i):
                    return True
                # 交换的情况
                if dfs(i1, i2 + length - i, i) and dfs(i1 + i, i2, length - i):
                    return True
        
            return False

        ans = dfs(0, 0, len(s1))
        dfs.cache_clear()
        return ans
```

```go [sol1-Golang]
func isScramble(s1, s2 string) bool {
    n := len(s1)
    dp := make([][][]int8, n)
    for i := range dp {
        dp[i] = make([][]int8, n)
        for j := range dp[i] {
            dp[i][j] = make([]int8, n+1)
            for k := range dp[i][j] {
                dp[i][j][k] = -1
            }
        }
    }

    // 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length
    // 和谐返回 1，不和谐返回 0
    var dfs func(i1, i2, length int) int8
    dfs = func(i1, i2, length int) (res int8) {
        d := &dp[i1][i2][length]
        if *d != -1 {
            return *d
        }
        defer func() { *d = res }()

        // 判断两个子串是否相等
        x, y := s1[i1:i1+length], s2[i2:i2+length]
        if x == y {
            return 1
        }

        // 判断是否存在字符 c 在两个子串中出现的次数不同
        freq := [26]int{}
        for i, ch := range x {
            freq[ch-'a']++
            freq[y[i]-'a']--
        }
        for _, f := range freq[:] {
            if f != 0 {
                return 0
            }
        }

        // 枚举分割位置
        for i := 1; i < length; i++ {
            // 不交换的情况
            if dfs(i1, i2, i) == 1 && dfs(i1+i, i2+i, length-i) == 1 {
                return 1
            }
            // 交换的情况
            if dfs(i1, i2+length-i, i) == 1 && dfs(i1+i, i2, length-i) == 1 {
                return 1
            }
        }

        return 0
    }
    return dfs(0, 0, n) == 1
}
```

```C [sol1-C]
struct HashTable {
    int key;
    int val;
    UT_hash_handle hh;
};

void modifyHashTable(struct HashTable** hashTable, int x, int inc) {
    struct HashTable* tmp;
    HASH_FIND_INT(*hashTable, &x, tmp);
    if (tmp == NULL) {
        tmp = malloc(sizeof(struct HashTable));
        tmp->key = x;
        tmp->val = inc;
        HASH_ADD_INT(*hashTable, key, tmp);
    } else {
        tmp->val += inc;
    }
}

bool checkHashTable(struct HashTable** hashTable) {
    struct HashTable *iter, *tmp;
    HASH_ITER(hh, *hashTable, iter, tmp) {
        if (iter->val) {
            return false;
        }
    }
    return true;
}

void freeHashTable(struct HashTable** hashTable) {
    struct HashTable *iter, *tmp;
    HASH_ITER(hh, *hashTable, iter, tmp) {
        HASH_DEL(*hashTable, iter);
        free(iter);
    }
}

bool equals(char* s1, char* s2, int i1, int i2, int len) {
    for (int i = 0; i < len; i++) {
        if (s1[i + i1] != s2[i + i2]) {
            return false;
        }
    }
    return true;
}

// 记忆化搜索存储状态的数组
// -1 表示 false，1 表示 true，0 表示未计算
int memo[30][30][31];

// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐
bool dfs(char* s1, char* s2, int i1, int i2, int length) {
    if (memo[i1][i2][length]) {
        return memo[i1][i2][length] == 1;
    }

    // 判断两个子串是否相等
    if (equals(s1, s2, i1, i2, length)) {
        memo[i1][i2][length] = 1;
        return true;
    }

    // 判断是否存在字符 c 在两个子串中出现的次数不同
    struct HashTable* hashTable = NULL;

    for (int i = i1; i < i1 + length; ++i) {
        modifyHashTable(&hashTable, s1[i], 1);
    }
    for (int i = i2; i < i2 + length; ++i) {
        modifyHashTable(&hashTable, s2[i], -1);
    }
    if (!checkHashTable(&hashTable)) {
        memo[i1][i2][length] = -1;
        return false;
    }
    freeHashTable(&hashTable);

    // 枚举分割位置
    for (int i = 1; i < length; ++i) {
        // 不交换的情况
        if (dfs(s1, s2, i1, i2, i) && dfs(s1, s2, i1 + i, i2 + i, length - i)) {
            memo[i1][i2][length] = 1;
            return true;
        }
        // 交换的情况
        if (dfs(s1, s2, i1, i2 + length - i, i) && dfs(s1, s2, i1 + i, i2, length - i)) {
            memo[i1][i2][length] = 1;
            return true;
        }
    }

    memo[i1][i2][length] = -1;
    return false;
}

bool isScramble(char* s1, char* s2) {
    memset(memo, 0, sizeof(memo));
    return dfs(s1, s2, 0, 0, strlen(s1));
}
```

```JavaScript [sol1-JavaScript]
var isScramble = function(s1, s2) {
    const length = s1.length;
    memo = new Array(length).fill(0).map(() => new Array(length).fill(0).map(() => new Array(length + 1).fill(0)));
    return dfs(0, 0, length, s1, s2, memo);
};

const dfs = function(i1, i2, length, s1, s2, memo) {
    if (memo[i1][i2][length] !== 0) {
        return memo[i1][i2][length] === 1;
    }

    // 判断两个子串是否相等
    if (s1.slice(i1, i1 + length) === s2.slice(i2, i2 + length)) {
        memo[i1][i2][length] = 1;
        return true;
    }

    // 判断是否存在字符 c 在两个子串中出现的次数不同
    if (!checkIfSimilar(i1, i2, length, s1, s2)) {
        memo[i1][i2][length] = -1;
        return false;
    }

    // 枚举分割位置
    for (let i = 1; i < length; ++i) {
        // 不交换的情况
        if (dfs(i1, i2, i, s1, s2, memo) && dfs(i1 + i, i2 + i, length - i, s1, s2, memo)) {
            memo[i1][i2][length] = 1;
            return true;
        }
        // 交换的情况
        if (dfs(i1, i2 + length - i, i, s1, s2, memo) && dfs(i1 + i, i2, length - i, s1, s2, memo)) {
            memo[i1][i2][length] = 1;
            return true;
        }
    }

    memo[i1][i2][length] = -1;
    return false;
}

const checkIfSimilar = function(i1, i2, length, s1, s2) {
    const freq = new Map();
    for (let i = i1; i < i1 + length; ++i) {
        const c = s1[i];
        freq.set(c, (freq.get(c) || 0) + 1);
    }
    for (let i = i2; i < i2 + length; ++i) {
        const c = s2[i];
        freq.set(c, (freq.get(c) || 0) - 1);
    }
    for (const value of freq.values()) {
        if (value !== 0) {
            return false;
        }
    }
    return true;
}
```

**复杂度分析**

- 时间复杂度：$O(n^4)$，其中 $n$ 是给定的原始字符串的长度。动态规划中的状态 $f(i_1, i_2, \textit{length})$ 有 $3$ 个维度，对于每一个状态，我们需要 $O(n)$ 枚举分割位置，因此总时间复杂度为 $O(n^4)$。

- 空间复杂度：$O(n^3)$，即为存储所有动态规划状态需要的空间。