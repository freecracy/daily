# 2021年04月09日 code
<a href="https://toutiao.io/k/qkjbzpr">我放弃上海的高薪，选择回老家了</a><br /><a href="https://toutiao.io/k/pmlwnuy">有哪些可以提高代码质量的书籍推荐？</a><br /><a href="https://toutiao.io/k/11ajx2d">JVM 合集之开篇点题</a><br /><a href="https://toutiao.io/k/42qs27i">数据仓库分层存储技术揭秘</a><br /><a href="https://toutiao.io/k/0hklbup">除了甘特图，你还应该了解些什么软件项目管理知识</a><br /><a href="https://toutiao.io/k/68q4m1v">架构设计方法论</a><br /><a href="https://toutiao.io/k/w1c3b1j">数据搬运组件：基于 Sqoop 管理数据导入和导出</a><br /><a href="https://toutiao.io/k/p4def3q">架构设计笔记（十四）：关键模式_分库分表</a><br /><a href="https://toutiao.io/k/hd9hq5t">火山引擎 Redis 云原生实践</a><br /><a href="https://toutiao.io/k/q1w09nr">工具 | 一款专为甲方安全人员、甲乙代码审计工程师和 0 Day 漏洞挖掘人员量身打造的辅助工具</a><br /><a href="https://toutiao.io/k/fwm8589">Flink 集成 Iceberg 在同程艺龙的生产实践</a><br /><a href="https://toutiao.io/k/vdlcgd6">ClickHouse 性能优化？试试物化视图</a><br /><a href="https://toutiao.io/k/ox8m619">动手写一个简单的编译器：在 JavaScript 中使用 Swift 的尾闭包语法</a><br /><a href="https://toutiao.io/k/a2sle6p">[译] 深入剖析新型 Mac OS 恶意软件 XcodeSpy</a><br /><a href="https://toutiao.io/k/i08zfwv">运维小姐姐说这篇 Consul 集群和 ACL 配置超给力（保姆级）</a><br /><a href="https://toutiao.io/k/1wti2v8">漫画｜与程序员正确的沟通方式应该是怎样的？</a><br /><a href="https://toutiao.io/k/6sr93da">使用 Github Actions artifact 在 workflow job 之间共享数据</a><br /><a href="https://toutiao.io/k/9g705u5">[译] 使用 Jetpack App Startup 库减少应用启动时间</a><br /><a href="https://toutiao.io/k/aeskj2g">喜大普奔，又一国标正式进入国际标准</a><br /><a href="https://toutiao.io/k/9uox6mg">[推荐] 21 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/ny7vvdw">[推荐] 万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/2fe4jjq">[推荐] 再见 Go 面试官：GMP 模型，为什么要有 P？</a><br /><a href="https://toutiao.io/k/f0361xm">[推荐] 高并发下如何保证接口的幂等性？</a><br /><a href="https://toutiao.io/k/oa4amzb">[推荐] 使用 Git 丢失代码的 N 种操作，您中招了吗？</a><br /><a href="https://toutiao.io/k/hti1ill">[推荐] 其实，每次面试的问题都逃不过这几方面</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><a href="https://toutiao.io/k/pufqjt0">[推荐] GitHub 太慢？9 种方案可提速</a><br /><a href="https://toutiao.io/k/sso4l2l">[推荐] 我在架构设计和代码开发中的一些常用原则</a><br /><a href="https://toutiao.io/k/47wemjf">[推荐] 超实用的 IDEA 插件推荐！百万级下载量</a><br /><a href="https://toutiao.io/k/6jo6q1t">[推荐] Go 应用优化指北</a><br /><a href="https://toutiao.io/k/ygnbct1">[推荐] GitHub 加速指南进阶版</a><br /><a href="https://toutiao.io/k/iyge3cy">[推荐] 史上最全教程：idea 将 Java 项目打包 Jar 包，并生成 exe 可执行文件</a><br /><a href="https://toutiao.io/k/cifpaoe">[推荐] 如何吃透一个 Java 项目？（附学习实践）</a><br /><a href="https://toutiao.io/k/romtfff">[推荐] 图文详解 Java 对象内存布局</a><br /><hr /><a href="https://github.com/google/lyra">A Very Low-Bitrate Codec for Speech Compression</a><br /><a href="https://github.com/laravel/octane"></a><br /><a href="https://github.com/bevyengine/bevy">A refreshingly simple data-driven game engine built in Rust</a><br /><a href="https://github.com/signalapp/Signal-Server">Server supporting the Signal Private Messenger applications on Android, Desktop, and iOS</a><br /><a href="https://github.com/apple/swift-collections">A package of production grade Swift data structures</a><br /><a href="https://github.com/cypress-io/cypress">Fast, easy and reliable testing for anything that runs in a browser.</a><br /><a href="https://github.com/login?return_to=%2Foppia%2Foppia">A free, online learning platform to make quality education accessible for all.</a><br /><a href="https://github.com/binhnguyennus/awesome-scalability">The Patterns of Scalable, Reliable, and Performant Large-Scale Systems</a><br /><a href="https://github.com/ripienaar/free-for-dev">A list of SaaS, PaaS and IaaS offerings that have free tiers of interest to devops and infradev</a><br /><a href="https://github.com/awesome-selfhosted/awesome-selfhosted">A list of Free Software network services and web applications which can be hosted on your own servers</a><br /><a href="https://github.com/elastic/beats">🐠 Beats - Lightweight shippers for Elasticsearch & Logstash</a><br /><a href="https://github.com/mobilecoinfoundation/mobilecoin">Private payments for mobile devices.</a><br /><a href="https://github.com/google/wuffs">Wrangling Untrusted File Formats Safely</a><br /><a href="https://github.com/edeng23/binance-trade-bot">Automated cryptocurrency trading bot</a><br /><a href="https://github.com/textflint/textflint">Text Robustness Evaluation Platform</a><br /><a href="https://github.com/hagopj13/node-express-boilerplate">A boilerplate for building production-ready RESTful APIs using Node.js, Express, and Mongoose</a><br /><a href="https://github.com/huangrt01/CS-Notes">我的自学笔记，终身更新。</a><br /><a href="https://github.com/dypsilon/frontend-dev-bookmarks">Manually curated collection of resources for frontend web developers.</a><br /><a href="https://github.com/Open-Smartwatch/open-smartwatch-os">The Open-Smartwatch Operating System.</a><br /><a href="https://github.com/Atmosphere-NX/Atmosphere">Atmosphère is a work-in-progress customized firmware for the Nintendo Switch.</a><br /><a href="https://github.com/apache/superset">Apache Superset is a Data Visualization and Data Exploration Platform</a><br /><a href="https://github.com/Azure/azure-quickstart-templates">Azure Quickstart Templates</a><br /><a href="https://github.com/codeedu/imersao-fsfc2"></a><br /><a href="https://github.com/input-output-hk/plutus">The Plutus language implementation and tools</a><br /><a href="https://github.com/elastic/kibana">Your window into the Elastic Stack</a><br /><hr />寻找旋转排序数组中的最小值 II<br />已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：
<ul>
	<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>
	<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>
</ul>

<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>

<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,3,5]
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,2,2,0,1]
<strong>输出：</strong>0
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>n == nums.length</code></li>
	<li><code>1 <= n <= 5000</code></li>
	<li><code>-5000 <= nums[i] <= 5000</code></li>
	<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>

<p> </p>

<p><strong>进阶：</strong></p>

<ul>
	<li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。</li>
	<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
<br />### 📺 视频题解  
![...寻找旋转排序数组中的最小值 II.mp4](aaf49047-518a-481b-8422-2cd03ad4db71)

### 📖 文字题解
#### 前言

本题是「[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)」的延伸。读者可以先尝试第 153 题，体会在旋转数组中进行二分查找的思路，再来尝试解决本题。

#### 方法一：二分查找

**思路与算法**

一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：

![fig1](https://assets.leetcode-cn.com/solution-static/154/1.png)

其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。

我们考虑**数组中的最后一个元素 $x$**：在最小值右侧的元素，它们的值一定都小于等于 $x$；而在最小值左侧的元素，它们的值一定都大于等于 $x$。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。

在二分查找的每一步中，左边界为 $\it low$，右边界为 $\it high$，区间的中点为 $\it pivot$，最小值就在该区间内。我们将中轴元素 $\textit{nums}[\textit{pivot}]$ 与右边界元素 $\textit{nums}[\textit{high}]$ 进行比较，可能会有以下的三种情况：

第一种情况是 $\textit{nums}[\textit{pivot}] < \textit{nums}[\textit{high}]$。如下图所示，这说明 $\textit{nums}[\textit{pivot}]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。

![fig2](https://assets.leetcode-cn.com/solution-static/154/2.png)

第二种情况是 $\textit{nums}[\textit{pivot}] > \textit{nums}[\textit{high}]$。如下图所示，这说明 $\textit{nums}[\textit{pivot}]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。

![fig3](https://assets.leetcode-cn.com/solution-static/154/3.png)

第三种情况是 $\textit{nums}[\textit{pivot}] == \textit{nums}[\textit{high}]$。如下图所示，由于重复元素的存在，我们并不能确定 $\textit{nums}[\textit{pivot}]$ 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 $\textit{nums}[\textit{high}]$ 是不是最小值，都有一个它的「替代品」$\textit{nums}[\textit{pivot}]$，因此我们可以忽略二分查找区间的右端点。

![fig4](https://assets.leetcode-cn.com/solution-static/154/4.png)

当二分查找结束时，我们就得到了最小值所在的位置。

```C++ [sol1-C++]
class Solution {
public:
    int findMin(vector<int>& nums) {
        int low = 0;
        int high = nums.size() - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (nums[pivot] < nums[high]) {
                high = pivot;
            }
            else if (nums[pivot] > nums[high]) {
                low = pivot + 1;
            }
            else {
                high -= 1;
            }
        }
        return nums[low];
    }
};
```

```Java [sol1-Java]
class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (nums[pivot] < nums[high]) {
                high = pivot;
            } else if (nums[pivot] > nums[high]) {
                low = pivot + 1;
            } else {
                high -= 1;
            }
        }
        return nums[low];
    }
}
```

```Python [sol1-Python3]
class Solution:
    def findMin(self, nums: List[int]) -> int:    
        low, high = 0, len(nums) - 1
        while low < high:
            pivot = low + (high - low) // 2
            if nums[pivot] < nums[high]:
                high = pivot 
            elif nums[pivot] > nums[high]:
                low = pivot + 1
            else:
                high -= 1
        return nums[low]
```

```C [sol1-C]
int findMin(int* nums, int numsSize) {
    int low = 0;
    int high = numsSize - 1;
    while (low < high) {
        int pivot = low + (high - low) / 2;
        if (nums[pivot] < nums[high]) {
            high = pivot;
        } else if (nums[pivot] > nums[high]) {
            low = pivot + 1;
        } else {
            high -= 1;
        }
    }
    return nums[low];
}
```

```golang [sol1-Golang]
func findMin(nums []int) int {
    low, high := 0, len(nums) - 1
    for low < high {
        pivot := low + (high - low) / 2
        if nums[pivot] < nums[high] {
            high = pivot
        } else if nums[pivot] > nums[high] {
            low = pivot + 1
        } else {
            high--
        }
    }
    return nums[low]
}
```

```JavaScript [sol1-JavaScript]
var findMin = function(nums) {
    let low = 0;
    let high = nums.length - 1;
    while (low < high) {
        const pivot = low + Math.floor((high - low) / 2);
        if (nums[pivot] < nums[high]) {
            high = pivot;
        } else if (nums[pivot] > nums[high]) {
            low = pivot + 1;
        } else {
            high -= 1;
        }
    }
    return nums[low];
};
```

**复杂度分析**

* 时间复杂度：平均时间复杂度为 $O(\log n)$，其中 $n$ 是数组 $\it nums$ 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 $\texttt{while}$ 循环就需要执行 $n$ 次，每次忽略区间的右端点，时间复杂度为 $O(n)$。

* 空间复杂度：$O(1)$。