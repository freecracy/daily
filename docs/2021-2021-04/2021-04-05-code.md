# 2021年04月05日 code
<a href="https://toutiao.io/k/hti1ill">其实，每次面试的问题都逃不过这几方面</a><br /><a href="https://toutiao.io/k/4gftmjt">Kafka 生产端实际项目中的使用分析</a><br /><a href="https://toutiao.io/k/sl5q6fu">技巧：根据主题模式 (dark/light) 切换 favicon</a><br /><a href="https://toutiao.io/k/83akfq5">数仓规范篇（一）：命名规范</a><br /><a href="https://toutiao.io/k/b2n5cvi">阿里最强 Python 自动化工具开源了</a><br /><a href="https://toutiao.io/k/urs7p59">ABTest 流量分发和业界的一些做法经验</a><br /><a href="https://toutiao.io/k/fi1bz28">关于写文章的一点经验</a><br /><a href="https://toutiao.io/k/y9hd6ye">对伪装 docx 文件病毒的逆向分析</a><br /><a href="https://toutiao.io/k/iz2m0c3">手把手教你玩转 Kubeflow on EKS（一）</a><br /><a href="https://toutiao.io/k/vbtqxi7">慌了，老大让我将线上的服务器升配，咋搞？</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><a href="https://toutiao.io/k/v9aar7o">[推荐] 这 30 个我精选的含答案的面试题，硬不硬你说吧</a><br /><a href="https://toutiao.io/k/ygnbct1">[推荐] GitHub 加速指南进阶版</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/cifpaoe">[推荐] 如何吃透一个 Java 项目？（附学习实践）</a><br /><a href="https://toutiao.io/k/ny7vvdw">[推荐] 万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/adg4qv6">[推荐] Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/9uox6mg">[推荐] 21 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/47wemjf">[推荐] 超实用的 IDEA 插件推荐！百万级下载量</a><br /><a href="https://toutiao.io/k/pufqjt0">[推荐] GitHub 太慢？9 种方案可提速</a><br /><a href="https://toutiao.io/k/sso4l2l">[推荐] 我在架构设计和代码开发中的一些常用原则</a><br /><a href="https://toutiao.io/k/f0361xm">[推荐] 高并发下如何保证接口的幂等性？</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><hr /><a href="https://github.com/johnBuffer/AntSimulator">Simple Ants simulator</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/bitcoin/bitcoin">Bitcoin Core integration/staging tree</a><br /><a href="https://github.com/climech/grit">A multitree-based personal task manager</a><br /><a href="https://github.com/iptv-org/iptv">Collection of 5000+ publicly available IPTV channels from all over the world</a><br /><a href="https://github.com/acidanthera/OpenCorePkg">OpenCore bootloader</a><br /><a href="https://github.com/login?return_to=%2Fwillmcgugan%2Frich">Rich is a Python library for rich text and beautiful formatting in the terminal.</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/appsmithorg/appsmith">Build beautiful admin panels, dashboards, and CRUD apps. One-click docker installation. Try it at: https://app.appsmith.com</a><br /><a href="https://github.com/orpatashnik/StyleCLIP"></a><br /><a href="https://github.com/kuchin/awesome-cto">A curated and opinionated list of resources for Chief Technology Officers, with the emphasis on startups</a><br /><a href="https://github.com/BetterDiscord/Installer">Installer for BetterDiscord</a><br /><a href="https://github.com/john-smilga/node-express-course"></a><br /><a href="https://github.com/nicehash/NiceHashQuickMiner">Super simple & easy Windows 10 cryptocurrency miner made by NiceHash.</a><br /><a href="https://github.com/catchorg/Catch2">A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or C++03 on the Catch1.x branch)</a><br /><a href="https://github.com/btcpayserver/btcpayserver">Accept Bitcoin payments. Free, open-source & self-hosted, Bitcoin payment processor.</a><br /><a href="https://github.com/Lolliedieb/lolMiner-releases"></a><br /><a href="https://github.com/mytechnotalent/Reverse-Engineering">A FREE comprehensive reverse engineering course covering x86, x64, 32-bit ARM & 64-bit ARM architectures.</a><br /><a href="https://github.com/ValveSoftware/Proton">Compatibility tool for Steam Play based on Wine and additional components</a><br /><a href="https://github.com/KevinOConnor/klipper">Klipper is a 3d-printer firmware</a><br /><a href="https://github.com/chartjs/Chart.js">Simple HTML5 Charts using the <canvas> tag</a><br /><a href="https://github.com/coolsnowwolf/lede">Lean's OpenWrt source</a><br /><a href="https://github.com/esp8266/Arduino">ESP8266 core for Arduino</a><br /><a href="https://github.com/jvns/dnspeep">spy on the DNS queries your computer is making</a><br /><hr />合并两个有序数组<br /><p>给你两个有序整数数组 <code>nums1</code><em> </em>和 <code>nums2</code>，请你将 <code>nums2</code><em> </em>合并到 <code>nums1</code><em> </em>中<em>，</em>使 <code>nums1</code><em> </em>成为一个有序数组。</p>

<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code><em> </em>。你可以假设 <code>nums1</code><em> </em>的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
<strong>输出：</strong>[1,2,2,3,5,6]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0
<strong>输出：</strong>[1]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>nums1.length == m + n</code></li>
	<li><code>nums2.length == n</code></li>
	<li><code>0 <= m, n <= 200</code></li>
	<li><code>1 <= m + n <= 200</code></li>
	<li><code>-10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup></code></li>
</ul>
<br />
### 📺 视频题解  
![88. 合并两个有序数组.mp4](c4e23dee-0349-4f11-83d0-d476c2567f90)

### 📖 文字题解
#### 方法一：直接合并后排序

**算法**

最直观的方法是先将数组 $\textit{nums}_2$ 放进数组 $\textit{nums}_1$ 的尾部，然后直接对整个数组进行排序。

```C++ [sol1-C++]
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        sort(nums1.begin(), nums1.end());
    }
};
```

```Java [sol1-Java]
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        Arrays.sort(nums1);
    }
}
```

```Python [sol1-Python3]
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
```

```go [sol1-Golang]
func merge(nums1 []int, m int, nums2 []int, _ int) {
    copy(nums1[m:], nums2)
    sort.Ints(nums1)
}
```

```JavaScript [sol1-JavaScript]
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m, ...nums2);
    nums1.sort((a, b) => a - b);
};
```

```C [sol1-C]
int cmp(int* a, int* b) {
    return *a - *b;
}

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    for (int i = 0; i != n; ++i) {
        nums1[m + i] = nums2[i];
    }
    qsort(nums1, nums1Size, sizeof(int), cmp);
}
```

**复杂度分析**

  * 时间复杂度：$O((m+n)\log(m+n))$。
    排序序列长度为 $m+n$，套用快速排序的时间复杂度即可，平均情况为 $O((m+n)\log(m+n))$。

  * 空间复杂度：$O(\log(m+n))$。
    排序序列长度为 $m+n$，套用快速排序的空间复杂度即可，平均情况为 $O(\log(m+n))$。

#### 方法二：双指针

**算法**

方法一没有利用数组 $\textit{nums}_1$ 与 $\textit{nums}_2$ 已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。如下面的动画所示：

![gif1](https://assets.leetcode-cn.com/solution-static/88/1.gif){:width=540}

我们为两个数组分别设置一个指针 $p_1$ 与 $p_2$ 来作为队列的头部指针。代码实现如下：

```C++ [sol2-C++]
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = 0, p2 = 0;
        int sorted[m + n];
        int cur;
        while (p1 < m || p2 < n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] < nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
};
```

```Java [sol2-Java]
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = 0, p2 = 0;
        int[] sorted = new int[m + n];
        int cur;
        while (p1 < m || p2 < n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] < nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
}
```

```Python [sol2-Python3]
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        sorted = []
        p1, p2 = 0, 0
        while p1 < m or p2 < n:
            if p1 == m:
                sorted.append(nums2[p2])
                p2 += 1
            elif p2 == n:
                sorted.append(nums1[p1])
                p1 += 1
            elif nums1[p1] < nums2[p2]:
                sorted.append(nums1[p1])
                p1 += 1
            else:
                sorted.append(nums2[p2])
                p2 += 1
        nums1[:] = sorted
```

```go [sol2-Golang]
func merge(nums1 []int, m int, nums2 []int, n int) {
    sorted := make([]int, 0, m+n)
    p1, p2 := 0, 0
    for {
        if p1 == m {
            sorted = append(sorted, nums2[p2:]...)
            break
        }
        if p2 == n {
            sorted = append(sorted, nums1[p1:]...)
            break
        }
        if nums1[p1] < nums2[p2] {
            sorted = append(sorted, nums1[p1])
            p1++
        } else {
            sorted = append(sorted, nums2[p2])
            p2++
        }
    }
    copy(nums1, sorted)
}
```

```JavaScript [sol2-JavaScript]
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    const sorted = new Array(m + n).fill(0);
    var cur;
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            cur = nums2[p2++];
        } else if (p2 === n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (let i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
};
```

```C [sol2-C]
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int p1 = 0, p2 = 0;
    int sorted[m + n];
    int cur;
    while (p1 < m || p2 < n) {
        if (p1 == m) {
            cur = nums2[p2++];
        } else if (p2 == n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (int i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
}
```

**复杂度分析**

  * 时间复杂度：$O(m+n)$。
    指针移动单调递增，最多移动 $m+n$ 次，因此时间复杂度为 $O(m+n)$。

  * 空间复杂度：$O(m+n)$。
    需要建立长度为 $m+n$ 的中间数组 $\textit{sorted}$。

#### 方法三：逆向双指针

**算法**

方法二中，之所以要使用临时变量，是因为如果直接合并到数组 $\textit{nums}_1$ 中，$\textit{nums}_1$ 中的元素可能会在取出之前被覆盖。那么如何直接避免覆盖 $\textit{nums}_1$ 中的元素呢？观察可知，$\textit{nums}_1$ 的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进 $\textit{nums}_1$ 的最后面。

严格来说，在此遍历过程中的任意一个时刻，$\textit{nums}_1$ 数组中有 $m-p_1-1$ 个元素被放入 $\textit{nums}_1$ 的后半部，$\textit{nums}_2$ 数组中有 $n-p_2-1$ 个元素被放入 $\textit{nums}_1$ 的后半部，而在指针 $p_1$ 的后面，$\textit{nums}_1$ 数组有 $m+n-p_1-1$ 个位置。由于

$$m+n-p_1-1\geq m-p_1-1+n-p_2-1$$

等价于

$$p_2\geq -1$$

永远成立，因此 $p_1$ 后面的位置永远足够容纳被插入的元素，不会产生 $p_1$ 的元素被覆盖的情况。

实现代码如下：

```C++ [sol3-C++]
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
};
```

```Java [sol3-Java]
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
}
```

```Python [sol3-Python3]
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        p1, p2 = m - 1, n - 1
        tail = m + n - 1
        while p1 >= 0 or p2 >= 0:
            if p1 == -1:
                nums1[tail] = nums2[p2]
                p2 -= 1
            elif p2 == -1:
                nums1[tail] = nums1[p1]
                p1 -= 1
            elif nums1[p1] > nums2[p2]:
                nums1[tail] = nums1[p1]
                p1 -= 1
            else:
                nums1[tail] = nums2[p2]
                p2 -= 1
            tail -= 1
```

```go [sol3-Golang]
func merge(nums1 []int, m int, nums2 []int, n int) {
    for p1, p2, tail := m-1, n-1, m+n-1; p1 >= 0 || p2 >= 0; tail-- {
        var cur int
        if p1 == -1 {
            cur = nums2[p2]
            p2--
        } else if p2 == -1 {
            cur = nums1[p1]
            p1--
        } else if nums1[p1] > nums2[p2] {
            cur = nums1[p1]
            p1--
        } else {
            cur = nums2[p2]
            p2--
        }
        nums1[tail] = cur
    }
}
```

```JavaScript [sol3-JavaScript]
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    var cur;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 === -1) {
            cur = nums2[p2--];
        } else if (p2 === -1) {
            cur = nums1[p1--];
        } else if (nums1[p1] > nums2[p2]) {
            cur = nums1[p1--];
        } else {
            cur = nums2[p2--];
        }
        nums1[tail--] = cur;
    }
};
```

```C [sol3-C]
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int p1 = m - 1, p2 = n - 1;
    int tail = m + n - 1;
    int cur;
    while (p1 >= 0 || p2 >= 0) {
        if (p1 == -1) {
            cur = nums2[p2--];
        } else if (p2 == -1) {
            cur = nums1[p1--];
        } else if (nums1[p1] > nums2[p2]) {
            cur = nums1[p1--];
        } else {
            cur = nums2[p2--];
        }
        nums1[tail--] = cur;
    }
}
```

**复杂度分析**

  * 时间复杂度：$O(m+n)$。
    指针移动单调递减，最多移动 $m+n$ 次，因此时间复杂度为 $O(m+n)$。
  
  * 空间复杂度：$O(1)$。
    直接对数组 $\textit{nums}_1$ 原地修改，不需要额外空间。