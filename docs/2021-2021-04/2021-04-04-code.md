# 2021年04月04日 code
<a href="https://toutiao.io/k/bh32yol">58 同城 App 性能治理实践：iOS 启动时间优化</a><br /><a href="https://toutiao.io/k/s8q5qn3">Etcd 分布式锁内存泄露</a><br /><a href="https://toutiao.io/k/k23mell">基于 Redis 的偏业务应用的分布式限流组件</a><br /><a href="https://toutiao.io/k/1ufc5cn">搞懂 ThreadLocal</a><br /><a href="https://toutiao.io/k/v0y3otx">使用火焰图定位 OLAP 引擎瓶颈</a><br /><a href="https://toutiao.io/k/jtz7p3i">如何购买一本书？</a><br /><a href="https://toutiao.io/k/tt8a7m6">[译] 何时使用 Rust？何时使用 Go？</a><br /><a href="https://toutiao.io/k/eihymr1">Dokka 设置包描述，让你的 Kotlin 库文档更详实</a><br /><a href="https://toutiao.io/k/pqyobsu">Kubernetes Deployment 滚动更新原理解析</a><br /><a href="https://toutiao.io/k/5eks2bi">对话 Tetrate.io 创始工程师吴晟：开源领域需要 40+ 的开发者，也需要更张扬的年轻人</a><br /><a href="https://toutiao.io/k/sso4l2l">[推荐] 我在架构设计和代码开发中的一些常用原则</a><br /><a href="https://toutiao.io/k/f0361xm">[推荐] 高并发下如何保证接口的幂等性？</a><br /><a href="https://toutiao.io/k/ny7vvdw">[推荐] 万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/pufqjt0">[推荐] GitHub 太慢？9 种方案可提速</a><br /><a href="https://toutiao.io/k/47wemjf">[推荐] 超实用的 IDEA 插件推荐！百万级下载量</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/cifpaoe">[推荐] 如何吃透一个 Java 项目？（附学习实践）</a><br /><a href="https://toutiao.io/k/v9aar7o">[推荐] 这 30 个我精选的含答案的面试题，硬不硬你说吧</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/adg4qv6">[推荐] Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><hr /><a href="https://github.com/johnBuffer/AntSimulator">Simple Ants simulator</a><br /><a href="https://github.com/catchorg/Catch2">A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or C++03 on the Catch1.x branch)</a><br /><a href="https://github.com/KevinOConnor/klipper">Klipper is a 3d-printer firmware</a><br /><a href="https://github.com/pinterest/querybook">Querybook is a Big Data Querying UI, combining collocated table metadata and a simple notebook interface.</a><br /><a href="https://github.com/chartjs/Chart.js">Simple HTML5 Charts using the <canvas> tag</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/AcalaNetwork/Acala">Acala - cross-chain DeFi hub and stablecoin based on Substrate for Polkadot and Kusama.</a><br /><a href="https://github.com/nicehash/NiceHashQuickMiner">Super simple & easy Windows 10 cryptocurrency miner made by NiceHash.</a><br /><a href="https://github.com/btcpayserver/btcpayserver">Accept Bitcoin payments. Free, open-source & self-hosted, Bitcoin payment processor.</a><br /><a href="https://github.com/appsmithorg/appsmith">Use Appsmith to build and self-host your internal apps. Create UI that connects to any database or API.</a><br /><a href="https://github.com/orpatashnik/StyleCLIP"></a><br /><a href="https://github.com/john-smilga/node-express-course"></a><br /><a href="https://github.com/RiotVanguard/Vanguard">Official Vanguard Anti-Cheat source code.</a><br /><a href="https://github.com/archlinux/archinstall">Arch Linux installer - guided, templates etc.</a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/dotnet/runtime">.NET is a cross-platform runtime for cloud, mobile, desktop, and IoT apps.</a><br /><a href="https://github.com/protocolbuffers/protobuf">Protocol Buffers - Google's data interchange format</a><br /><a href="https://github.com/mytechnotalent/Reverse-Engineering">A FREE comprehensive reverse engineering course covering x86, x64, 32-bit ARM & 64-bit ARM architectures.</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/jvns/dnspeep">spy on the DNS queries your computer is making</a><br /><a href="https://github.com/ytdl-org/youtube-dl">Command-line program to download videos from YouTube.com and other video sites</a><br /><a href="https://github.com/facebookresearch/madgrad">MADGRAD Optimization Method</a><br /><a href="https://github.com/GUI/covid-vaccine-spotter"></a><br /><a href="https://github.com/itdevbooks/pdf">编程电子书，电子书，编程书籍，包括C，C#，Docker，Elasticsearch，Git，Hadoop，HeadFirst，Java，Javascript，jvm，Kafka，Linux，Maven，MongoDB，MyBatis，MySQL，Netty，Nginx，Python，RabbitMQ，Redis，Scala，Solr，Spark，Spring，SpringBoot，SpringCloud，TCPIP，Tomcat，Zookeeper，人工智能，大数据类，并发编程，数据库类，数据挖掘，新面试题，架构设计，算法系列，计算机类，设计模式，软件测试，重构优化，等更多分类</a><br /><hr />森林中的兔子<br /><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在&nbsp;<code>answers</code>&nbsp;数组里。</p>

<p>返回森林中兔子的最少数量。</p>

<pre>
<strong>示例:</strong>
<strong>输入:</strong> answers = [1, 1, 2]
<strong>输出:</strong> 5
<strong>解释:</strong>
两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。
之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 &quot;2&quot; 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

<strong>输入:</strong> answers = [10, 10, 10]
<strong>输出:</strong> 11

<strong>输入:</strong> answers = []
<strong>输出:</strong> 0
</pre>

<p><strong>说明:</strong></p>

<ol>
	<li><code>answers</code>&nbsp;的长度最大为<code>1000</code>。</li>
	<li><code>answers[i]</code>&nbsp;是在&nbsp;<code>[0, 999]</code>&nbsp;范围内的整数。</li>
</ol>
<br />#### 方法一：贪心

**思路**

两只相同颜色的兔子看到的其他同色兔子数必然是相同的。反之，若两只兔子看到的其他同色兔子数不同，那么这两只兔子颜色也不同。

因此，将 $\textit{answers}$ 中值相同的元素分为一组，对于每一组，计算出兔子的最少数量，然后将所有组的计算结果累加，就是最终的答案。

例如，现在有 $13$ 只兔子回答 $5$。假设其中有一只红色的兔子，那么森林中必然有 $6$ 只红兔子。再假设其中还有一只蓝色的兔子，同样的道理森林中必然有 $6$ 只蓝兔子。为了最小化可能的兔子数量，我们假设这 $12$ 只兔子都在这 $13$ 只兔子中。那么还有一只额外的兔子回答 $5$，这只兔子只能是其他的颜色，这一颜色的兔子也有 $6$ 只。因此这种情况下最少会有 $18$ 只兔子。

一般地，如果有 $x$ 只兔子都回答 $y$，则至少有 $\lceil\dfrac{x}{y+1}\rceil$ 种不同的颜色，且每种颜色有 $y+1$ 只兔子，因此兔子数至少为 

$$\lceil\dfrac{x}{y+1}\rceil\cdot(y+1)$$

我们可以用哈希表统计 $\textit{answers}$ 中各个元素的出现次数，对每个元素套用上述公式计算，并将计算结果累加，即为最终答案。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int numRabbits(vector<int> &answers) {
        unordered_map<int, int> count;
        for (int y : answers) {
            ++count[y];
        }
        int ans = 0;
        for (auto &[y, x] : count) {
            ans += (x + y) / (y + 1) * (y + 1);
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int numRabbits(int[] answers) {
        Map<Integer, Integer> count = new HashMap<Integer, Integer>();
        for (int y : answers) {
            count.put(y, count.getOrDefault(y, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            int y = entry.getKey(), x = entry.getValue();
            ans += (x + y) / (y + 1) * (y + 1);
        }
        return ans;
    }
}
```

```go [sol1-Golang]
func numRabbits(answers []int) (ans int) {
    count := map[int]int{}
    for _, y := range answers {
        count[y]++
    }
    for y, x := range count {
        ans += (x + y) / (y + 1) * (y + 1)
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var numRabbits = function(answers) {
    const count = new Map();
    for (const y of answers) {
        count.set(y, (count.get(y) || 0) + 1);
    }
    let ans = 0;
    for (const [y, x] of count.entries()) {
        ans += Math.floor((x + y) / (y + 1)) * (y + 1);
    }
    return ans;
};
```

```Python [sol1-Python3]
class Solution:
    def numRabbits(self, answers: List[int]) -> int:
        count = Counter(answers)
        ans = sum((x + y) // (y + 1) * (y + 1) for y, x in count.items())
        return ans
```

```C [sol1-C]
struct HashTable {
    int key;
    int val;
    UT_hash_handle hh;
};

int numRabbits(int* answers, int answersSize) {
    struct HashTable* hashTable = NULL;
    for (int i = 0; i < answersSize; i++) {
        struct HashTable* tmp;
        HASH_FIND_INT(hashTable, &answers[i], tmp);
        if (tmp == NULL) {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = answers[i];
            tmp->val = 1;
            HASH_ADD_INT(hashTable, key, tmp);
        } else {
            tmp->val++;
        }
    }
    int ans = 0;
    struct HashTable *iter, *tmp;
    HASH_ITER(hh, hashTable, iter, tmp) {
        int x = iter->val, y = iter->key;
        ans += (x + y) / (y + 1) * (y + 1);
    }
    return ans;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{answers}$ 的长度。

- 空间复杂度：$O(n)$。最坏情况下，哈希表中含有 $n$ 个元素。