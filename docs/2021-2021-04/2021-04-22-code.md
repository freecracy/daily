# 2021年04月22日 code
<a href="https://toutiao.io/k/wxrneux">为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/xkhaihd">协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/fwtxydd">架构模式之分层架构总结</a><br /><a href="https://toutiao.io/k/i8pbfyr">JavaScript 垃圾回收策略</a><br /><a href="https://toutiao.io/k/zahd9yv">Java 8 中的 Lambda 表达式</a><br /><a href="https://toutiao.io/k/ykfvids">从 Serverless 看软件效能提升</a><br /><a href="https://toutiao.io/k/izj0r49">厉害了，A4 纸上竟然能清晰看动漫</a><br /><a href="https://toutiao.io/k/g2vk4k1">i/o timeout ， 希望你不要踩到这个 net/http 包的坑</a><br /><a href="https://toutiao.io/k/tb0ianx">嗯，你觉得 Go 在什么时候会抢占 P？</a><br /><a href="https://toutiao.io/k/i2l6mm0">贝壳 OLAP 平台架构演进</a><br /><a href="https://toutiao.io/k/dmssgmt">ETL 和 ELT 到底有啥区别？？？</a><br /><a href="https://toutiao.io/k/iaed1zu">LeetCode (844) ：比较含退格的字符串</a><br /><a href="https://toutiao.io/k/5jrgtv8">AMS 系列之生命周期管理</a><br /><a href="https://toutiao.io/k/uo5a4h8">Arthas 的表达式太难了？在线调试 Ognl 表达式</a><br /><a href="https://toutiao.io/k/1it9jop">扩展 Spark SQL 解析</a><br /><a href="https://toutiao.io/k/bwb59wj">最新 Hive 的高频面试题新鲜出炉了</a><br /><a href="https://toutiao.io/k/z3dscov">漫画｜工作这几年，同事对我的称呼肉眼可见的在变化着</a><br /><a href="https://toutiao.io/k/8sv2059">在不同 webpack 版本的 Vue 项目中配置 Storybook</a><br /><a href="https://toutiao.io/k/00kj7m4">从零带你看 Struts 2 中 OGNL 命令执行漏洞</a><br /><a href="https://toutiao.io/k/5rzhtid">2021 Cocoapods 新手入门指南</a><br /><a href="https://toutiao.io/k/82eogba">[推荐] Git 分支管理策略与工作流程</a><br /><a href="https://toutiao.io/k/3bv147y">[推荐] 免费正版 IntelliJ IDEA license 详细指南</a><br /><a href="https://toutiao.io/k/811or1j">[推荐] 学会这 10 种定时任务，我有点飘了</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/68q4m1v">[推荐] 架构设计方法论</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/4zqz7k1">[推荐] RESTful API 设计最佳实践</a><br /><a href="https://toutiao.io/k/6aau0fc">[推荐] 一文读懂，DDD 落地数据库设计实战</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/7uw9l2r">[推荐] JVM 进阶之路（九）：性能监控工具（可视化工具篇）</a><br /><a href="https://toutiao.io/k/pmlwnuy">[推荐] 有哪些可以提高代码质量的书籍推荐？</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><a href="https://toutiao.io/k/gauwubg">[推荐] 我很久没写代码了，但我是个好架构师</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><hr /><a href="https://github.com/nasa/fprime">F' - A flight software and embedded systems framework</a><br /><a href="https://github.com/flaneur2020/pua-lang"></a><br /><a href="https://github.com/login?return_to=%2Fwbkd%2Freact-flow">Highly customizable library for building interactive node-based UIs, editors, flow charts and diagrams</a><br /><a href="https://github.com/login?return_to=%2Fsupabase%2Fsupabase">The open source Firebase alternative. Follow to stay updated about our public Beta.</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/chefyuan/algorithm-base">专门为刚开始刷题的同学准备的算法基地，没有最细只有更细，立志用动画将晦涩难懂的算法说的通俗易懂！</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/github/docs">The open-source repo for docs.github.com</a><br /><a href="https://github.com/labuladong/fucking-algorithm">刷算法全靠套路，认准 labuladong 就够了！English version supported! Crack LeetCode, not only how, but also why.</a><br /><a href="https://github.com/storj/storj">Ongoing Storj v3 development. Decentralized cloud object storage that is affordable, easy to use, private, and secure.</a><br /><a href="https://github.com/ossrs/srs">SRS is a simple, high efficiency and realtime video server, supports RTMP/WebRTC/HLS/HTTP-FLV/SRT/GB28181/RTSP.</a><br /><a href="https://github.com/jdah/tetris-os">An operating system, but it only plays Tetris.</a><br /><a href="https://github.com/safemoonprotocol/Safemoon.sol">safemoon contract</a><br /><a href="https://github.com/microsoft/cascadia-code">This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal.</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/981011512/--">停车场系统源码，停车场小程序【功能介绍】：①兼容市面上主流的多家相机，理论上兼容所有硬件，可灵活扩展，②相机识别后数据自动上传到云端并记录，校验相机唯一id和硬件序列号，防止非法数据录入，③用户手机查询停车记录详情可自主缴费(支持微信，支付宝，银行接口支付，支持每个停车场指定不同的商户进行收款)，支付后出场在免费时间内会自动抬杆。④支持app上查询附近停车场(导航，可用车位数，停车场费用，优惠券，评分，评论等)，可预约车位。⑤断电断网支持岗亭人员使用app可接管硬件进行停车记录的录入。 【技术架构】：后端开发语言java，框架oauth2+springboot2+dubble，数据库mysql/mongodb/redis，即时通讯底层框架netty4，安卓和ios均为原生开发，后台管理…</a><br /><a href="https://github.com/tevador/RandomX">Proof of work algorithm based on random code execution</a><br /><a href="https://github.com/amate/UmaUmaCruise">このソフトは、自動でDMM版ウマ娘のウィンドウから、イベント選択肢の効果を知るために作られました</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/git-tips/tips">Most commonly used git tips and tricks.</a><br /><a href="https://github.com/karlhadwen/instagram">Subscribe to my YouTube channel: https://bit.ly/CognitiveSurge - Building Instagram Using React</a><br /><a href="https://github.com/ascoders/weekly">前端精读周刊。帮你理解最前沿、实用的技术。</a><br /><a href="https://github.com/torvalds/linux">Linux kernel source tree</a><br /><a href="https://github.com/argoproj/argo-workflows">Workflow engine for Kubernetes</a><br /><a href="https://github.com/login?return_to=%2Filuwatar%2Fjava-design-patterns">Design patterns implemented in Java</a><br /><hr />矩形区域不超过 K 的最大数值和<br /><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，找出并返回矩阵内部矩形区域的不超过 <code>k</code> 的最大数值和。</p>

<p>题目数据保证总会存在一个数值和不超过 <code>k</code> 的矩形区域。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" style="width: 255px; height: 176px;" />
<pre>
<strong>输入：</strong>matrix = [[1,0,1],[0,-2,3]], k = 2
<strong>输出：</strong>2
<strong>解释：</strong>蓝色边框圈出来的矩形区域 <code>[[0, 1], [-2, 3]]</code> 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>matrix = [[2,2,-1]], k = 3
<strong>输出：</strong>3
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>m == matrix.length</code></li>
	<li><code>n == matrix[i].length</code></li>
	<li><code>1 <= m, n <= 100</code></li>
	<li><code>-100 <= matrix[i][j] <= 100</code></li>
	<li><code>-10<sup>5</sup> <= k <= 10<sup>5</sup></code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>如果行数远大于列数，该如何设计解决方案？</p>
<br />#### 方法一：有序集合

**思路**

我们枚举矩形的上下边界，并计算出该边界内每列的元素和，则原问题转换成了如下一维问题：

> 给定一个整数数组和一个整数 $k$，计算该数组的最大区间和，要求区间和不超过 $k$。

定义长度为 $n$ 的数组 $a$ 的前缀和

$$
S_i =
\begin{cases} 
0&i=0\\
a_0+a_1+\cdots+a_{i-1}&1\le i\le n
\end{cases}
$$

则区间 $[l,r)$ 的区间和 $a_l+a_{l+1}+\cdots+a_{r-1}$ 可以表示为 $S_r-S_l$。

枚举 $r$，上述问题的约束 $S_r-S_l\le k$ 可以转换为 $S_l\ge S_r-k$。要使 $S_r-S_l$ 尽可能大，则需要寻找最小的满足 $S_l\ge S_r-k$ 的 $S_l$。我们可以在枚举 $r$ 的同时维护一个存储 $S_i\ (i<r)$ 的有序集合，则可以在 $O(\log n)$ 的时间内二分找到符合要求的 $S_l$。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int maxSumSubmatrix(vector<vector<int>> &matrix, int k) {
        int ans = INT_MIN;
        int m = matrix.size(), n = matrix[0].size();
        for (int i = 0; i < m; ++i) { // 枚举上边界
            vector<int> sum(n);
            for (int j = i; j < m; ++j) { // 枚举下边界
                for (int c = 0; c < n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                set<int> sumSet{0};
                int s = 0;
                for (int v : sum) {
                    s += v;
                    auto lb = sumSet.lower_bound(s - k);
                    if (lb != sumSet.end()) {
                        ans = max(ans, s - *lb);
                    }
                    sumSet.insert(s);
                }
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int k) {
        int ans = Integer.MIN_VALUE;
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i < m; ++i) { // 枚举上边界
            int[] sum = new int[n];
            for (int j = i; j < m; ++j) { // 枚举下边界
                for (int c = 0; c < n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                TreeSet<Integer> sumSet = new TreeSet<Integer>();
                sumSet.add(0);
                int s = 0;
                for (int v : sum) {
                    s += v;
                    Integer ceil = sumSet.ceiling(s - k);
                    if (ceil != null) {
                        ans = Math.max(ans, s - ceil);
                    }
                    sumSet.add(s);
                }
            }
        }
        return ans;
    }
}
```

```go [sol1-Golang]
import "math/rand"

type node struct {
    ch       [2]*node
    priority int
    val      int
}

func (o *node) cmp(b int) int {
    switch {
    case b < o.val:
        return 0
    case b > o.val:
        return 1
    default:
        return -1
    }
}

func (o *node) rotate(d int) *node {
    x := o.ch[d^1]
    o.ch[d^1] = x.ch[d]
    x.ch[d] = o
    return x
}

type treap struct {
    root *node
}

func (t *treap) _put(o *node, val int) *node {
    if o == nil {
        return &node{priority: rand.Int(), val: val}
    }
    if d := o.cmp(val); d >= 0 {
        o.ch[d] = t._put(o.ch[d], val)
        if o.ch[d].priority > o.priority {
            o = o.rotate(d ^ 1)
        }
    }
    return o
}

func (t *treap) put(val int) {
    t.root = t._put(t.root, val)
}

func (t *treap) lowerBound(val int) (lb *node) {
    for o := t.root; o != nil; {
        switch c := o.cmp(val); {
        case c == 0:
            lb = o
            o = o.ch[0]
        case c > 0:
            o = o.ch[1]
        default:
            return o
        }
    }
    return
}

func maxSumSubmatrix(matrix [][]int, k int) int {
    ans := math.MinInt64
    for i := range matrix { // 枚举上边界
        sum := make([]int, len(matrix[0]))
        for _, row := range matrix[i:] { // 枚举下边界
            for c, v := range row {
                sum[c] += v // 更新每列的元素和
            }
            t := &treap{}
            t.put(0)
            s := 0
            for _, v := range sum {
                s += v
                if lb := t.lowerBound(s - k); lb != nil {
                    ans = max(ans, s-lb.val)
                }
                t.put(s)
            }
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```Python [sol1-Python3]
from sortedcontainers import SortedList

class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        ans = float("-inf")
        m, n = len(matrix), len(matrix[0])

        for i in range(m):   # 枚举上边界
            total = [0] * n
            for j in range(i, m):   # 枚举下边界
                for c in range(n):
                    total[c] += matrix[j][c]   # 更新每列的元素和
                
                totalSet = SortedList([0])
                s = 0
                for v in total:
                    s += v
                    lb = totalSet.bisect_left(s - k)
                    if lb != len(totalSet):
                        ans = max(ans, s - totalSet[lb])
                    totalSet.add(s)

        return ans
```

**复杂度分析**

- 时间复杂度：$O(m^2n\log n)$。其中 $m$ 和 $n$ 分别是矩阵 $\textit{matrix}$ 的行数和列数。

- 空间复杂度：$O(n)$。

#### 进阶问题

对于行数远大于列数的情况，枚举矩形的左右边界更优，对应的时间复杂度为 $O(n^2m\log m)$。

总之，根据 $m$ 和 $n$ 的大小来细化枚举策略，我们可以做到 $O(\min(m,n)^2\max(m,n)\log\max(m,n))$ 的时间复杂度。