# 2021年04月26日 code
<a href="https://toutiao.io/k/tsqw03z">工作中沟通的 4 点感悟</a><br /><a href="https://toutiao.io/k/2do7cy9">分布式配置中心选型，为什么选择 Apollo？</a><br /><a href="https://toutiao.io/k/wlggoto">VSCode 插件推荐</a><br /><a href="https://toutiao.io/k/vwhpln3">写给开发人员的实用密码学：CA</a><br /><a href="https://toutiao.io/k/2hs8quz">重构项目</a><br /><a href="https://toutiao.io/k/sp2k2z9">Java 提取 EXIF 信息批量重命名</a><br /><a href="https://toutiao.io/k/7jqkxt9">JVM 进阶之路（十一）：Class 文件结构</a><br /><a href="https://toutiao.io/k/1tfa2fk">做架构的四个思路</a><br /><a href="https://toutiao.io/k/43racxs">Go：一个对新手很友好的项目（带界面）</a><br /><a href="https://toutiao.io/k/696uwce">美团 Serverless 平台 Nest 的探索与实践</a><br /><a href="https://toutiao.io/k/rvxn1my">掌门持续交付流水线大规模实践</a><br /><a href="https://toutiao.io/k/0etokja">Kafka：这次分享我只想把原理讲清楚</a><br /><a href="https://toutiao.io/k/csbyj0t">基于二叉树实现 Map</a><br /><a href="https://toutiao.io/k/ea96cgw">当我们设置 IP 地址为 0.0.0.0 时，是在表达什么</a><br /><a href="https://toutiao.io/k/9xv7yg8">前端架构演进：从单体到微前端（理论篇）</a><br /><a href="https://toutiao.io/k/y6s9qco">fscan：一键自动化、全方位漏洞扫描的开源工具</a><br /><a href="https://toutiao.io/k/jlak2h1">iOS 内存管理相关</a><br /><a href="https://toutiao.io/k/j3z60pw">弱监督条件下基于相似性条件学习的服饰搭配生成</a><br /><a href="https://toutiao.io/k/oo0bm33">KnS 系列：K0s 是个什么鬼</a><br /><a href="https://toutiao.io/k/jxo7pwy">谁说 Java 不能用来跑 Serverless？</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><a href="https://toutiao.io/k/6aau0fc">[推荐] 一文读懂，DDD 落地数据库设计实战</a><br /><a href="https://toutiao.io/k/4zqz7k1">[推荐] RESTful API 设计最佳实践</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/syxnrph">[推荐] OpenResty 实现限流</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/3bv147y">[推荐] 免费正版 IntelliJ IDEA license 详细指南</a><br /><a href="https://toutiao.io/k/zxa65u1">[推荐] 超级详细的 Spring Boot 注解总结</a><br /><a href="https://toutiao.io/k/7uw9l2r">[推荐] JVM 进阶之路（九）：性能监控工具（可视化工具篇）</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><hr /><a href="https://github.com/microsoft/wslg">Enabling the Windows Subsystem for Linux to include support for Wayland and X server related scenarios</a><br /><a href="https://github.com/chrisleekr/binance-trading-bot">Automated Binance trading bot - Buy low/Sell high with stop loss limit/Trade multiple cryptocurrencies</a><br /><a href="https://github.com/login?return_to=%2Fphotoprism%2Fphotoprism">Personal Photo Management powered by Go and Google TensorFlow</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/jackfrued/Python-100-Days">Python - 100天从新手到大师</a><br /><a href="https://github.com/chefyuan/algorithm-base">专门为刚开始刷题的同学准备的算法基地，没有最细只有更细，立志用动画将晦涩难懂的算法说的通俗易懂！</a><br /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/ornicar/lila">♞ lichess.org: the forever free, adless and open source chess server ♞</a><br /><a href="https://github.com/login?return_to=%2Fkamranahmedse%2Fdeveloper-roadmap">Roadmap to becoming a web developer in 2021</a><br /><a href="https://github.com/v2fly/v2ray-core">A platform for building proxies to bypass network restrictions.</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/danistefanovic/build-your-own-x">🤓 Build your own (insert technology here)</a><br /><a href="https://github.com/josepholiveira/podcastr">A platform built for podcast broadcasting. Developed during @Rocketseat NLW#05 free training.</a><br /><a href="https://github.com/ml-tooling/opyrator">🪄 Turns your machine learning code into microservices with web API, interactive GUI, and more.</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/bmorelli25/Become-A-Full-Stack-Web-Developer">Free resources for learning Full Stack Web Development</a><br /><a href="https://github.com/mahmoud-eskandari/vuemastery-dl">vuemastery video downloader</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/Emadabdelhamied/Eng-Mohamed-Hammad-Posts"></a><br /><a href="https://github.com/bradtraversy/design-resources-for-developers">Curated list of design and UI resources from stock photos, web templates, CSS frameworks, UI libraries, tools and much more</a><br /><a href="https://github.com/DidierRLopes/GamestonkTerminal">The next best thing after Bloomberg Terminal</a><br /><a href="https://github.com/RH12503/triangula">Generate high-quality triangulated art from images.</a><br /><a href="https://github.com/you-dont-need/You-Dont-Need-JavaScript">CSS is powerful, you can do a lot of things without JS.</a><br /><a href="https://github.com/aladinyo/WhatsappyApp">A whatsapp clone progressive web application built with react nodejs and firebase</a><br /><hr />在 D 天内送达包裹的能力<br /><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>

<p>传送带上的第 <code>i</code>&nbsp;个包裹的重量为&nbsp;<code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>

<p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>weights = [1,2,3,4,5,6,7,8,9,10], D = 5
<strong>输出：</strong>15
<strong>解释：</strong>
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>weights = [3,2,2,4,1,4], D = 3
<strong>输出：</strong>6
<strong>解释：</strong>
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>weights = [1,2,3,1,1], D = 4
<strong>输出：</strong>3
<strong>解释：</strong>
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li><code>1 &lt;= D &lt;= weights.length &lt;= 50000</code></li>
	<li><code>1 &lt;= weights[i] &lt;= 500</code></li>
</ol>
<br />#### 方法一：二分查找转化为判定问题

**思路与算法**

假设当船的运载能力为 $x$ 时，我们可以在 $D$ 天内运送完所有包裹，那么只要运载能力大于 $x$，我们同样可以在 $D$ 天内运送完所有包裹：我们只需要使用运载能力为 $x$ 时的运送方法即可。

这样一来，我们就得到了一个非常重要的结论：

> 存在一个运载能力的「下限」$x_\textit{ans}$，使得当 $x \geq x_\textit{ans}$ 时，我们可以在 $D$ 天内运送完所有包裹；当 $x < x_\textit{ans}$ 时，我们无法在 $D$ 天内运送完所有包裹。

同时，$x_\textit{ans}$ 即为我们需要求出的答案。因此，我们就可以使用二分查找的方法找出 $x_\textit{ans}$ 的值。

在二分查找的每一步中，我们实际上需要解决一个**判定问题**：给定船的运载能力 $x$，我们是否可以在 $D$ 天内运送完所有包裹呢？这个判定问题可以通过贪心的方法来解决：

> 由于我们必须按照数组 $\textit{weights}$ 中包裹的顺序进行运送，因此我们从数组 $\textit{weights}$ 的首元素开始遍历，将连续的包裹都安排在同一天进行运送。当这批包裹的重量大于运载能力 $x$ 时，我们就需要将最后一个包裹拿出来，安排在新的一天，并继续往下遍历。当我们遍历完整个数组后，就得到了最少需要运送的天数。

我们将「最少需要运送的天数」与 $D$ 进行比较，就可以解决这个判定问题。当其小于等于 $D$ 时，我们就忽略二分的右半部分区间；当其大于 $D$ 时，我们就忽略二分的左半部分区间。

**细节**

二分查找的初始左右边界应当如何计算呢？

对于左边界而言，由于我们不能「拆分」一个包裹，因此船的运载能力不能小于所有包裹中最重的那个的重量，即左边界为数组 $\textit{weights}$ 中元素的最大值。

对于右边界而言，船的运载能力也不会大于所有包裹的重量之和，即右边界为数组 $\textit{weights}$ 中元素的和。

我们从上述左右边界开始进行二分查找，就可以保证找到最终的答案。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int D) {
        // 确定二分查找左右边界
        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right) {
            int mid = (left + right) / 2;
            // need 为需要运送的天数
            // cur 为当前这一天已经运送的包裹重量之和
            int need = 1, cur = 0;
            for (int weight: weights) {
                if (cur + weight > mid) {
                    ++need;
                    cur = 0;
                }
                cur += weight;
            }
            if (need <= D) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int shipWithinDays(int[] weights, int D) {
        // 确定二分查找左右边界
        int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();
        while (left < right) {
            int mid = (left + right) / 2;
            // need 为需要运送的天数
            // cur 为当前这一天已经运送的包裹重量之和
            int need = 1, cur = 0;
            for (int weight : weights) {
                if (cur + weight > mid) {
                    ++need;
                    cur = 0;
                }
                cur += weight;
            }
            if (need <= D) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        # 确定二分查找左右边界
        left, right = max(weights), sum(weights)
        while left < right:
            mid = (left + right) // 2
            # need 为需要运送的天数
            # cur 为当前这一天已经运送的包裹重量之和
            need, cur = 1, 0
            for weight in weights:
                if cur + weight > mid:
                    need += 1
                    cur = 0
                cur += weight
            
            if need <= D:
                right = mid
            else:
                left = mid + 1
        
        return left
```

```JavaScript [sol1-JavaScript]
var shipWithinDays = function(weights, D) {
    // 确定二分查找左右边界
    let left = Math.max(...weights), right = weights.reduce((a, b) => a + b);
    while (left < right) {
        const mid = Math.floor((left + right) / 2);
        //  need 为需要运送的天数
        // cur 为当前这一天已经运送的包裹重量之和
        let need = 1, cur = 0;
        for (const weight of weights) {
            if (cur + weight > mid) {
                need++;
                cur = 0;
            } 
            cur += weight;
        }

        if (need <= D) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
};
```

```go [sol1-Golang]
func shipWithinDays(weights []int, D int) int {
    // 确定二分查找左右边界
    left, right := 0, 0
    for _, w := range weights {
        if w > left {
            left = w
        }
        right += w
    }
    return left + sort.Search(right-left, func(x int) bool {
        x += left
        day := 1 // 需要运送的天数
        sum := 0 // 当前这一天已经运送的包裹重量之和
        for _, w := range weights {
            if sum+w > x {
                day++
                sum = 0
            }
            sum += w
        }
        return day <= D
    })
}
```

```C [sol1-C]
int shipWithinDays(int* weights, int weightsSize, int D) {
    // 确定二分查找左右边界
    int left = 0, right = 0;
    for (int i = 0; i < weightsSize; i++) {
        left = fmax(left, weights[i]);
        right += weights[i];
    }
    while (left < right) {
        int mid = (left + right) / 2;
        // need 为需要运送的天数
        // cur 为当前这一天已经运送的包裹重量之和
        int need = 1, cur = 0;
        for (int i = 0; i < weightsSize; i++) {
            if (cur + weights[i] > mid) {
                ++need;
                cur = 0;
            }
            cur += weights[i];
        }
        if (need <= D) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

**复杂度分析**

- 时间复杂度：$O\big(n\log(\Sigma w)\big)$，其中 $n$ 是数组 $\textit{weights}$ 的长度，$\Sigma w$ 是数组 $\textit{weights}$ 中元素的和。二分查找需要执行的次数为 $O(\log(\Sigma w))$，每一步中需要对数组 $\textit{weights}$ 进行依次遍历，时间为 $O(n)$，相乘即可得到总时间复杂度。

- 空间复杂度：$O(1)$。