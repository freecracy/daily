# 2021年04月23日 code
<a href="https://toutiao.io/k/ti0gb8i">Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/hk3xm6e">互联网：逻辑上的黑话才是真正的花里胡哨</a><br /><a href="https://toutiao.io/k/0t3be9z">谈谈 Kubernetes 的问题和局限性</a><br /><a href="https://toutiao.io/k/lyccgvn">面试必备常见存储引擎与锁的分类，请查收</a><br /><a href="https://toutiao.io/k/0iqkotc">Nginx：不管正向还是反向我通通代理</a><br /><a href="https://toutiao.io/k/n0npgg0">Seata 搭建与分布式事务入门</a><br /><a href="https://toutiao.io/k/6mr06fm">测试平台的发展与未来趋势</a><br /><a href="https://toutiao.io/k/s1yoo7q">Flink 在唯品会的实践</a><br /><a href="https://toutiao.io/k/b5awuuy">Homebrew 图形化管理软件 Cakebrew，我再也不用记命令了</a><br /><a href="https://toutiao.io/k/qfzkjty">太强大了，Feign 对接 YAPI 实现自动 Mock</a><br /><a href="https://toutiao.io/k/n8y1wql">ShutdownHook 原理</a><br /><a href="https://toutiao.io/k/qcp2ayr">面试官：你知道 Dubbo 怎么做优雅上下线的吗？你：优雅上下线是啥？</a><br /><a href="https://toutiao.io/k/29pxjdo">聊聊 Code Review</a><br /><a href="https://toutiao.io/k/4f1i9kn">Python 数据可视化：DataFrame.plot() 函数绘制数据图</a><br /><a href="https://toutiao.io/k/6b507a7">工具 | 一款上手简单，功能强大的 Python 爬虫框架</a><br /><a href="https://toutiao.io/k/gs9x659">细数分布式 ID 生成策略</a><br /><a href="https://toutiao.io/k/e8tthtb">[译] 纯 CSS 图片碎裂动画教程</a><br /><a href="https://toutiao.io/k/scjloxy">LeetCode 1006：笨阶乘</a><br /><a href="https://toutiao.io/k/flemmhy">服务网格平稳落地：Istio 中精准控制 Sidecar 的注入</a><br /><a href="https://toutiao.io/k/5gb5ik0">[译] 代码会死循环吗？Go 异步抢占</a><br /><a href="https://toutiao.io/k/gauwubg">[推荐] 我很久没写代码了，但我是个好架构师</a><br /><a href="https://toutiao.io/k/zxa65u1">[推荐] 超级详细的 Spring Boot 注解总结</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/3bv147y">[推荐] 免费正版 IntelliJ IDEA license 详细指南</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/82eogba">[推荐] Git 分支管理策略与工作流程</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/7uw9l2r">[推荐] JVM 进阶之路（九）：性能监控工具（可视化工具篇）</a><br /><a href="https://toutiao.io/k/6aau0fc">[推荐] 一文读懂，DDD 落地数据库设计实战</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><a href="https://toutiao.io/k/811or1j">[推荐] 学会这 10 种定时任务，我有点飘了</a><br /><a href="https://toutiao.io/k/syxnrph">[推荐] OpenResty 实现限流</a><br /><a href="https://toutiao.io/k/4zqz7k1">[推荐] RESTful API 设计最佳实践</a><br /><hr /><a href="https://github.com/jdah/tetris-os">An operating system, but it only plays Tetris.</a><br /><a href="https://github.com/taichi-dev/taichi">Productive & portable programming language for high-performance, sparse & differentiable computing on CPUs & GPUs</a><br /><a href="https://github.com/netdata/netdata">Real-time performance monitoring, done right! https://www.netdata.cloud</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/login?return_to=%2Fvitling%2Facid-banger">The Endless Acid Banger</a><br /><a href="https://github.com/CyberPunkMetalHead/Binance-News-Sentiment-Bot">This is a fully functioning Binance trading bot that takes into account the news sentiment for the top 100 crypto feeds.</a><br /><a href="https://github.com/zhangdaiscott/jeecg-boot">「企业级低代码平台」前后端分离架构SpringBoot 2.x，SpringCloud，Ant Design&Vue，Mybatis-plus，Shiro，JWT。强大的代码生成器让前后端代码一键生成，无需写任何代码! 引领新的开发模式OnlineCoding->代码生成->手工MERGE，帮助Java项目解决70%重复工作，让开发更关注业务，既能快速提高效率，帮助公司节省成本，同时又不失灵活性。</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/chefyuan/algorithm-base">专门为刚开始刷题的同学准备的算法基地，没有最细只有更细，立志用动画将晦涩难懂的算法说的通俗易懂！</a><br /><a href="https://github.com/ascoders/weekly">前端精读周刊。帮你理解最前沿、实用的技术。</a><br /><a href="https://github.com/zellij-org/zellij">A terminal workspace with batteries included</a><br /><a href="https://github.com/nasa/fprime">F' - A flight software and embedded systems framework</a><br /><a href="https://github.com/safemoonprotocol/Safemoon.sol">safemoon contract</a><br /><a href="https://github.com/luong-komorebi/Awesome-Linux-Software">A list of awesome applications, software, tools and other materials for Linux distros.</a><br /><a href="https://github.com/gh0stkey/Binary-Learning">滴水逆向初、中级学习笔记，不定时更新，自用仓库，不喜勿喷；感谢滴水，有如此完整体系的学习视频，白嫖党嫖了一波...感谢海东老师，听课受益匪浅。</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：配思维导图，将近200道经典算法题目刷题顺序、经典算法模板、共60w字的详细图解，以及难点视频题解。按照刷题攻略上的顺序来刷题，让你在算法学习上不再迷茫！🔥🔥给个star支持一下吧！🚀</a><br /><a href="https://github.com/CleverProgrammers/cp-disney-plus-clone">Here's the DEMO Disney+ Clone App</a><br /><a href="https://github.com/corona-warn-app/cwa-app-android">Native Android app using the Apple/Google exposure notification API.</a><br /><a href="https://github.com/AvaloniaUI/Avalonia">A cross platform XAML framework for .NET</a><br /><a href="https://github.com/981011512/--">停车场系统源码，停车场小程序【功能介绍】：①兼容市面上主流的多家相机，理论上兼容所有硬件，可灵活扩展，②相机识别后数据自动上传到云端并记录，校验相机唯一id和硬件序列号，防止非法数据录入，③用户手机查询停车记录详情可自主缴费(支持微信，支付宝，银行接口支付，支持每个停车场指定不同的商户进行收款)，支付后出场在免费时间内会自动抬杆。④支持app上查询附近停车场(导航，可用车位数，停车场费用，优惠券，评分，评论等)，可预约车位。⑤断电断网支持岗亭人员使用app可接管硬件进行停车记录的录入。 【技术架构】：后端开发语言java，框架oauth2+springboot2+dubble，数据库mysql/mongodb/redis，即时通讯底层框架netty4，安卓和ios均为原生开发，后台管理…</a><br /><a href="https://github.com/RaminNietzsche/jobguy">اطلاعات مربوط به مصاحبه ها و تجربیات کاری در جاب گای</a><br /><a href="https://github.com/NeuromatchAcademy/course-content-dl"></a><br /><a href="https://github.com/torvalds/linux">Linux kernel source tree</a><br /><a href="https://github.com/storj/storj">Ongoing Storj v3 development. Decentralized cloud object storage that is affordable, easy to use, private, and secure.</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><hr />最大整除子集<br />给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：
<ul>
	<li><code>answer[i] % answer[j] == 0</code> ，或</li>
	<li><code>answer[j] % answer[i] == 0</code></li>
</ul>

<p>如果存在多个有效解子集，返回其中任何一个均可。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[1,2]
<strong>解释：</strong>[1,3] 也会被视为正确答案。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,4,8]
<strong>输出：</strong>[1,2,4,8]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 1000</code></li>
	<li><code>1 <= nums[i] <= 2 * 10<sup>9</sup></code></li>
	<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<br />#### 前言

首先需要理解什么叫「整除子集」。根据题目的描述，如果一个所有元素**互不相同**的集合中的**任意**元素存在整除关系，就称为整除子集。为了得到「最大整除子集」，我们需要考虑**如何从一个小的整除子集扩充成为更大的整除子集**。

根据整除关系具有传递性，即如果 $a\big|b$，并且 $b\big|c$，那么 $a\big|c$，可知：

- 如果整数 $a$ 是整除子集 $S_1$ 的最小整数 $b$ 的约数（即 $a\big|b$），那么可以将 $a$ 添加到 $S_1$ 中得到一个更大的整除子集；

- 如果整数 $c$ 是整除子集 $S_2$ 的最大整数 $d$ 的倍数（即 $d\big|c$），那么可以将 $c$ 添加到 $S_2$ 中得到一个更大的整除子集。

这两点揭示了当前问题状态转移的特点，因此可以使用动态规划的方法求解。题目只要求我们得到多个目标子集的其中一个，根据求解动态规划问题的经验，我们需要将子集的大小定义为状态，然后根据结果**倒推**得到一个目标子集。事实上，当前问题和使用动态规划解决的经典问题「[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)」有相似之处。

#### 方法一：动态规划

根据前言的分析，我们需要将输入数组 $\textit{nums}$ 按照升序排序，以便获得一个子集的最小整数或者最大整数。又根据动态规划的「无后效性」状态设计准则，我们需要将状态定义成「某个元素必须选择」。

**状态定义**：$\textit{dp}[i]$ 表示在输入数组 $\textit{nums}$ 升序排列的前提下，以 $\textit{nums}[i]$ 为最大整数的「整除子集」的大小（在这种定义下 $\textit{nums}[i]$ 必须被选择）。

**状态转移方程**：枚举 $j = 0 \ldots i-1$ 的所有整数 $\textit{nums}[j]$，如果 $\textit{nums}[j]$ 能整除 $\textit{nums}[i]$，说明 $\textit{nums}[i]$ 可以扩充在以 $\textit{nums}[j]$ 为最大整数的整除子集里成为一个更大的整除子集。

**初始化**：由于 $\textit{nums}[i]$ 必须被选择，因此对于任意 $i = 0 \ldots n-1$，初始的时候 $\textit{dp}[i] = 1$，这里 $n$ 是输入数组的长度。

**输出**：由于最大整除子集不一定包含 $\textit{nums}$ 中最大的整数，所以我们需要枚举所有的 $\textit{dp}[i]$，选出最大整除子集的大小 $\textit{maxSize}$，以及该最大子集中的最大整数 $\textit{maxVal}$。按照如下方式倒推获得一个目标子集：

1. **倒序遍历**数组 $\textit{dp}$，直到找到 $\textit{dp}[i] = \textit{maxSize}$ 为止，把此时对应的 $\textit{nums}[i]$ 加入结果集，此时 $\textit{maxVal} = \textit{nums}[i]$；

2. 然后将 $\textit{maxSize}$ 的值减 $1$，继续倒序遍历找到 $\textit{dp}[i] = \textit{maxSize}$，且 $\textit{nums}[i]$ 能整除 $\textit{maxVal}$ 的 $i$ 为止，将此时的 $\textit{nums}[i]$ 加入结果集，$\textit{maxVal}$ 更新为此时的 $num[i]$；

3. 重复上述操作，直到 $\textit{maxSize}$ 的值变成 $0$，此时的结果集即为一个目标子集。

下面用一个例子说明如何得到最大整除子集。假设输入数组为 $[2,4,7,8,9,12,16,18]$（已经有序），得到的动态规划表格如下：

| $\textit{nums}$ | $2$ | $4$ | $7$ | $8$ | $9$ | $12$ | $16$ | $20$ |
| --------------- | --- | --- | --- | --- | --- | ---- | ---- | ---- |
| $\textit{dp}$   | $1$ | $2$ | $1$ | $3$ | $1$ | $3$  | $4$  | $3$  |

得到最大整除子集的做法如下：

1. 根据 $\textit{dp}$ 的计算结果，$\textit{maxSize}=4$，$\textit{maxVal}=16$，因此大小为 $4$ 的最大整除子集包含的最大整数为 $16$；

2. 然后查找大小为 $3$ 的最大整除子集，我们看到 $8$ 和 $12$ 对应的状态值都是 $3$，最大整除子集一定包含 $8$，这是因为 $8 \big| 16$；

3. 然后查找大小为 $2$ 的最大整除子集，我们看到 $4$ 对应的状态值是 $2$，最大整除子集一定包含 $4$；

4. 然后查找大小为 $1$ 的最大整除子集，我们看到 $2$ 对应的状态值是 $1$，最大整除子集一定包含 $2$。

通过这样的方式，我们就找到了满足条件的某个最大整除子集 $[16,8,4,2]$。

**代码**

```Java [sol1-Java]
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        int len = nums.length;
        Arrays.sort(nums);

        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        int maxSize = 1;
        int maxVal = dp[0];
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                // 题目中说「没有重复元素」很重要
                if (nums[i] % nums[j] == 0) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            if (dp[i] > maxSize) {
                maxSize = dp[i];
                maxVal = nums[i];
            }
        }

        // 第 2 步：倒推获得最大子集
        List<Integer> res = new ArrayList<Integer>();
        if (maxSize == 1) {
            res.add(nums[0]);
            return res;
        }
        
        for (int i = len - 1; i >= 0 && maxSize > 0; i--) {
            if (dp[i] == maxSize && maxVal % nums[i] == 0) {
                res.add(nums[i]);
                maxVal = nums[i];
                maxSize--;
            }
        }
        return res;
    }
}
```

```JavaScript [sol1-JavaScript]
var largestDivisibleSubset = function(nums) {
    const len = nums.length;
    nums.sort((a, b) => a - b);

    // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
    const dp = new Array(len).fill(1);
    let maxSize = 1;
    let maxVal = dp[0];
    for (let i = 1; i < len; i++) {
        for (let j = 0; j < i; j++) {
            // 题目中说「没有重复元素」很重要
            if (nums[i] % nums[j] === 0) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        if (dp[i] > maxSize) {
            maxSize = dp[i];
            maxVal = nums[i];
        }
    }

    // 第 2 步：倒推获得最大子集
    const res = [];
    if (maxSize === 1) {
        res.push(nums[0]);
        return res;
    }
    
    for (let i = len - 1; i >= 0 && maxSize > 0; i--) {
        if (dp[i] === maxSize && maxVal % nums[i] === 0) {
            res.push(nums[i]);
            maxVal = nums[i];
            maxSize--;
        }
    }
    return res;
};
```

```go [sol1-Golang]
func largestDivisibleSubset(nums []int) (res []int) {
    sort.Ints(nums)

    // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
    n := len(nums)
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }
    maxSize, maxVal := 1, 1
    for i := 1; i < n; i++ {
        for j, v := range nums[:i] {
            if nums[i]%v == 0 && dp[j]+1 > dp[i] {
                dp[i] = dp[j] + 1
            }
        }
        if dp[i] > maxSize {
            maxSize, maxVal = dp[i], nums[i]
        }
    }

    if maxSize == 1 {
        return []int{nums[0]}
    }

    // 第 2 步：倒推获得最大子集
    for i := n - 1; i >= 0 && maxSize > 0; i-- {
        if dp[i] == maxSize && maxVal%nums[i] == 0 {
            res = append(res, nums[i])
            maxVal = nums[i]
            maxSize--
        }
    }
    return
}
```

```C++ [sol1-C++]
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int len = nums.size();
        sort(nums.begin(), nums.end());

        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
        vector<int> dp(len, 1);
        int maxSize = 1;
        int maxVal = dp[0];
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                // 题目中说「没有重复元素」很重要
                if (nums[i] % nums[j] == 0) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }

            if (dp[i] > maxSize) {
                maxSize = dp[i];
                maxVal = nums[i];
            }
        }

        // 第 2 步：倒推获得最大子集
        vector<int> res;
        if (maxSize == 1) {
            res.push_back(nums[0]);
            return res;
        }

        for (int i = len - 1; i >= 0 && maxSize > 0; i--) {
            if (dp[i] == maxSize && maxVal % nums[i] == 0) {
                res.push_back(nums[i]);
                maxVal = nums[i];
                maxSize--;
            }
        }
        return res;
    }
};
```

```C [sol1-C]
int cmp(int* a, int* b) {
    return *a - *b;
}

int* largestDivisibleSubset(int* nums, int numsSize, int* returnSize) {
    int len = numsSize;
    qsort(nums, numsSize, sizeof(int), cmp);

    // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
    int dp[len];
    for (int i = 0; i < len; i++) {
        dp[i] = 1;
    }
    int maxSize = 1;
    int maxVal = dp[0];
    for (int i = 1; i < len; i++) {
        for (int j = 0; j < i; j++) {
            // 题目中说「没有重复元素」很重要
            if (nums[i] % nums[j] == 0) {
                dp[i] = fmax(dp[i], dp[j] + 1);
            }
        }

        if (dp[i] > maxSize) {
            maxSize = dp[i];
            maxVal = nums[i];
        }
    }

    // 第 2 步：倒推获得最大子集
    int* res = malloc(sizeof(int) * len);
    *returnSize = 0;
    if (maxSize == 1) {
        res[(*returnSize)++] = nums[0];
        return res;
    }

    for (int i = len - 1; i >= 0 && maxSize > 0; i--) {
        if (dp[i] == maxSize && maxVal % nums[i] == 0) {
            res[(*returnSize)++] = nums[i];
            maxVal = nums[i];
            maxSize--;
        }
    }
    return res;
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$，其中 $n$ 为输入数组的长度。对数组 $\textit{nums}$ 排序的时间复杂度为 $O(n \log n)$，计算数组 $\textit{dp}$ 元素的时间复杂度为 $O(n^2)$，倒序遍历得到一个目标子集，时间复杂度为 $O(n)$。

- 空间复杂度：$O(n)$，其中 $n$ 为输入数组的长度。需要创建长度为 $n$ 的数组 $\textit{dp}$。