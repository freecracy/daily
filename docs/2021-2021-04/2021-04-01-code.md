# 2021年04月01日 code
<a href="https://toutiao.io/k/6hopkg8">工具 | 滴滴开源的一套 Android 路由框架</a><br /><a href="https://toutiao.io/k/pufqjt0">GitHub 太慢？9 种方案可提速</a><br /><a href="https://toutiao.io/k/5w4puff">敏捷管理系列：基于 Jira 的 Scrum 敏捷管理实战</a><br /><a href="https://toutiao.io/k/6egc5rh">一文详解 SQL 关联子查询</a><br /><a href="https://toutiao.io/k/de9dz5x">ConcurrentBag 听过没？好家伙高并发知识点十分密集</a><br /><a href="https://toutiao.io/k/nheehuc">一文搞懂如何实现 Go 超时控制</a><br /><a href="https://toutiao.io/k/acuexuw">字节跳动混沌工程实践之场景化主动实验</a><br /><a href="https://toutiao.io/k/brm7upm">Notion 编辑器原理分析</a><br /><a href="https://toutiao.io/k/1nfpmir">关于数据仓库架构及组件方案选型</a><br /><a href="https://toutiao.io/k/cp43ztk">认识爬虫：怎样管理爬虫过程中已使用和未使用的 URL 地址？</a><br /><a href="https://toutiao.io/k/sr6tm75">Clickhouse 在唯品会的实践</a><br /><a href="https://toutiao.io/k/1oqs1jl">漫画｜程序员：我真不是修电脑的啊</a><br /><a href="https://toutiao.io/k/bwc0qk6">posenet 怎么玩？真人录制火柴人，骚气起来</a><br /><a href="https://toutiao.io/k/k8abz8k">Caffeine Cache：高性能 Java 本地缓存组件</a><br /><a href="https://toutiao.io/k/6t85xxu">聊聊集群、分布式和微服务之间的联系和异同点</a><br /><a href="https://toutiao.io/k/hno0zrv">MAD Skills：使用深层链接导航</a><br /><a href="https://toutiao.io/k/bdainqq">比特位计数</a><br /><a href="https://toutiao.io/k/5skorni">强化学习入门：说到底研究的是如何学习</a><br /><a href="https://toutiao.io/k/8trfjb6">JavaScript 控制手段之 break/continue</a><br /><a href="https://toutiao.io/k/tfw2zvr">NoSQL 也搞 ACID：DynamoDB Transaction</a><br /><a href="https://toutiao.io/k/lq6l2fa">[推荐] 加密技术的未来：从服务端密码存储到用户数据加密方案</a><br /><a href="https://toutiao.io/k/adg4qv6">[推荐] Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/nvr0l12">[推荐] 权限体系设计：网易有数 BI 功能品鉴</a><br /><a href="https://toutiao.io/k/47wemjf">[推荐] 超实用的 IDEA 插件推荐！百万级下载量</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/le19zdx">[推荐] 万字长文：彻底搞懂容器镜像构建</a><br /><a href="https://toutiao.io/k/7aczn5o">[推荐] 面试官常问的垃圾回收器，这次全搞懂</a><br /><a href="https://toutiao.io/k/ozl31qb">[推荐] 如何写出高质量的技术文章？</a><br /><a href="https://toutiao.io/k/cifpaoe">[推荐] 如何吃透一个 Java 项目？（附学习实践）</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><a href="https://toutiao.io/k/ny7vvdw">[推荐] 万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/uhmrz9z">[推荐] 为什么 Kubernetes 要替换 Docker</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><hr /><a href="https://github.com/NAalytics/Assemblies-of-putative-SARS-CoV2-spike-encoding-mRNA-sequences-for-vaccines-BNT-162b2-and-mRNA-1273">RNA vaccines have become a key tool in moving forward through the challenges raised both in the current pandemic and in numerous other public health and medical challenges. With the rollout of vaccines for COVID-19, these synthetic mRNAs have become broadly distributed RNA species in numerous human populations. Despite their ubiquity, sequences …</a><br /><a href="https://github.com/Datalux/Osintgram">Osintgram is a OSINT tool on Instagram. It offers an interactive shell to perform analysis on Instagram account of any users by its nickname</a><br /><a href="https://github.com/login?return_to=%2Ftrungk18%2Fangular-spotify">Spotify client built with Angular 11, Nx Workspace, ngrx, TailwindCSS and ng-zorro</a><br /><a href="https://github.com/birchb1024/frangipanni">Program to convert lines of text into a tree structure.</a><br /><a href="https://github.com/protocolbuffers/protobuf">Protocol Buffers - Google's data interchange format</a><br /><a href="https://github.com/spring-projects-experimental/spring-authorization-server">A community-driven project led by the Spring Security team and is focused on delivering Authorization Server support to the Spring community</a><br /><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">The repository for high quality TypeScript type definitions.</a><br /><a href="https://github.com/dromara/sa-token">这可能是史上功能最全的Java权限认证框架！目前已集成——登录验证、权限验证、Session会话、踢人下线、分布式会话、单点登录、OAuth2.0、记住我模式、模拟他人账号、临时身份切换、集成Redis、多账号认证体系、前后台分离模式、注解式鉴权、路由拦截式鉴权、花式token生成、自动续签、同端互斥登录、会话治理、密码加密、jwt集成、Spring集成...</a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/login?return_to=%2Fnuxt%2Fnuxt.js">The Intuitive Vue Framework</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/nvm-sh/nvm">Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</a><br /><a href="https://github.com/gto76/python-cheatsheet">Comprehensive Python Cheatsheet</a><br /><a href="https://github.com/Asabeneh/30-Days-Of-React">30 Days of React challenge is a step by step guide to learn React in 30 days. It requires HTML, CSS, and JavaScript knowledge. You should be comfortable with JavaScript before you start to React. If you are not comfortable with JavaScript check out 30DaysOfJavaScript. This is a continuation of 30 Days Of JS. This challenge may take up to 100 day…</a><br /><a href="https://github.com/login?return_to=%2Fmrdoob%2Fthree.js">JavaScript 3D library.</a><br /><a href="https://github.com/donnemartin/data-science-ipython-notebooks">Data science Python notebooks: Deep learning (TensorFlow, Theano, Caffe, Keras), scikit-learn, Kaggle, big data (Spark, Hadoop MapReduce, HDFS), matplotlib, pandas, NumPy, SciPy, Python essentials, AWS, and various command lines.</a><br /><a href="https://github.com/microsoft/Swin-Transformer">a general-purpose Transformer based vision backbone</a><br /><a href="https://github.com/randallkanna/awesome-job-list"></a><br /><a href="https://github.com/harryheman/React-Total">Ресурс для изучения React.js и связанных с ним технологий на русском языке</a><br /><a href="https://github.com/catchorg/Catch2">A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or C++03 on the Catch1.x branch)</a><br /><a href="https://github.com/jychp/cloudflare-bypass">Bypass Coudflare bot protection using Cloudflare Workers</a><br /><a href="https://github.com/php/php-src">The PHP Interpreter</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/Dairongpeng/algorithm-note">该系列包括数组，链表，树，图，递归，DP，有序表等相关数据结构与算法的讲解及代码实现。</a><br /><a href="https://github.com/olmps/memo">Memo is an Anki mobile app written in Flutter</a><br /><hr />笨阶乘<br /><p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p>

<p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p>

<p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>

<p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以&nbsp;<code>10 * 9 / 8</code>&nbsp;等于&nbsp;<code>11</code>。这保证结果是一个整数。</p>

<p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>4
<strong>输出：</strong>7
<strong>解释：</strong>7 = 4 * 3 / 2 + 1
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>10
<strong>输出：</strong>12
<strong>解释：</strong>12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li><code>1 &lt;= N &lt;= 10000</code></li>
	<li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code>&nbsp; （答案保证符合 32 位整数。）</li>
</ol>
<br />#### 方法一：使用栈模拟

**思路**

根据求解问题「[150. 逆波兰表达式求值](/problems/evaluate-reverse-polish-notation)」、「[224. 基本计算器](/problems/basic-calculator)」、「[227. 基本计算器 II](/problems/basic-calculator-ii)」的经验，表达式的计算一般可以借助数据结构「栈」完成，特别是带有括号的表达式。我们将暂时还不能确定的数据存入栈，确定了优先级最高以后，一旦可以计算出结果，我们就把数据从栈里取出，**整个过程恰好符合了「后进先出」的规律**。本题也不例外。

根据题意，「笨阶乘」没有显式括号，运算优先级是先「乘除」后「加减」。我们可以从 $N$ 开始，枚举 $N - 1$、$N-2$ 直到 $1$ ，枚举这些数的时候，认为它们之前的操作符按照「乘」「除」「加」「减」交替进行。

- 出现乘法、除法的时候可以把栈顶元素取出，与当前的 $N$ 进行乘法运算、除法运算（除法运算需要注意先后顺序），并将运算结果重新压入栈中；

- 出现加法、减法的时候，把减法视为加上一个数的相反数，然后压入栈，等待以后遇见「乘」「除」法的时候取出。

最后将栈中元素累加即为答案。由于加法运算交换律成立，可以将栈里的元素依次出栈相加。

**代码**

```Java [sol1-Java]
class Solution {
    public int clumsy(int N) {
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(N);
        N--;

        int index = 0; // 用于控制乘、除、加、减
        while (N > 0) {
            if (index % 4 == 0) {
                stack.push(stack.pop() * N);
            } else if (index % 4 == 1) {
                stack.push(stack.pop() / N);
            } else if (index % 4 == 2) {
                stack.push(N);
            } else {
                stack.push(-N);
            }
            index++;
            N--;
        }

        // 把栈中所有的数字依次弹出求和
        int sum = 0;
        while (!stack.isEmpty()) {
            sum += stack.pop();
        }
        return sum;
    }
}
```

```C++ [sol1-C++]
class Solution {
public:
    int clumsy(int N) {
        stack<int> stk;
        stk.push(N);
        N--;

        int index = 0; // 用于控制乘、除、加、减
        while (N > 0) {
            if (index % 4 == 0) {
                stk.top() *= N;
            } else if (index % 4 == 1) {
                stk.top() /= N;
            } else if (index % 4 == 2) {
                stk.push(N);
            } else {
                stk.push(-N);
            }
            index++;
            N--;
        }

        // 把栈中所有的数字依次弹出求和
        int sum = 0;
        while (!stk.empty()) {
            sum += stk.top();
            stk.pop();
        }
        return sum;
    }
};
```

```go [sol1-Go]
func clumsy(N int) (ans int) {
    stk := []int{N}
    N--

    index := 0 // 用于控制乘、除、加、减
    for N > 0 {
        switch index % 4 {
        case 0:
            stk[len(stk)-1] *= N
        case 1:
            stk[len(stk)-1] /= N
        case 2:
            stk = append(stk, N)
        default:
            stk = append(stk, -N)
        }
        N--
        index++
    }

    // 累加栈中数字
    for _, v := range stk {
        ans += v
    }
    return
}
```

```C [sol1-C]
int clumsy(int N) {
    int stk[N], top = 0;
    stk[top++] = N;
    N--;

    int index = 0; // 用于控制乘、除、加、减
    while (N > 0) {
        if (index % 4 == 0) {
            stk[top - 1] *= N;
        } else if (index % 4 == 1) {
            stk[top - 1] /= N;
        } else if (index % 4 == 2) {
            stk[top++] = N;
        } else {
            stk[top++] = -N;
        }
        index++;
        N--;
    }

    // 把栈中所有的数字依次弹出求和
    int sum = 0;
    while (top) {
        sum += stk[--top];
    }
    return sum;
}
```

```JavaScript [sol1-JavaScript]
var clumsy = function(N) {
    const stack = [N--];

    let index = 0; // 用于控制乘、除、加、减
    while (N > 0) {
        if (index % 4 == 0) {
            stack.push(stack.pop() * N);
        } else if (index % 4 == 1) {
            const cur = stack.pop();
            stack.push(cur > 0 ? Math.floor(cur / N) : Math.ceil(cur / N));
        } else if (index % 4 == 2) {
            stack.push(N);
        } else {
            stack.push(-N);
        }
        index++;
        N--;
    }

    // 把栈中所有的数字依次弹出求和
    let sum = 0;
    stack.forEach((element) => {
        sum += element;
    })
    return sum;
};
```

**复杂度分析**

- 时间复杂度：$O(N)$。从 $N$ 到 $1$ 每一个元素进栈一次，出栈一次。

- 空间复杂度：$O(1)$。由于「乘」「除」「加」「减」按照顺序出现，栈中保存的元素个数为常数，并不与 $N$ 线性相关。

#### 方法二：数学

**思路**

让我们来尝试化简「笨阶乘」的式子。

观察「笨阶乘」的前三项，有

$$
\begin{aligned}
&5\cdot4/3=6\\
&6\cdot5/4=7\\
&7\cdot6/5=8\\
&\dots
\end{aligned}
$$

一般地，有

$$
\begin{aligned}
&\quad~ N \cdot (N - 1) / (N - 2) \\ &= \cfrac{N^2 - N}{N-2} \\ 
&= \cfrac{N^2 - 2N + N}{N-2}  \\ &= \cfrac{N(N - 2) + N}{N-2} \\
&= N + \cfrac{N}{N-2} \\
&= N + \cfrac{N - 2 + 2}{N-2} \\
&= N + 1 + \cfrac{2}{N - 2}
\end{aligned}
$$

上式最后一项 $\cfrac{2}{N - 2}$，当分子严格小于分母（$2 < N - 2$，即 $N > 4$）的时候，在地板除法的定义下等于 $0$。
即当 $N > 4$ 时，有 

$$
N \cdot (N - 1) / (N - 2) = N + 1
$$

我们把「笨阶乘」的计算式多写几项：
$$
\texttt{clumsy}(N) = N \cdot (N - 1) / (N - 2) + (N - 3) - (N - 4) \cdot (N - 5) / (N - 6) + (N - 7) - \cdots
$$

就会发现其中有可以「消去」的部分，根据以上分析，当 $N > 8$ 时，有

$$
(N - 4) \cdot (N - 5) / (N - 6) = N - 3
$$

此时 $\texttt{clumsy}(N)$ 除了 $N \cdot (N - 1) / (N - 2) = N + 1$ 以外，后面每 $4$ 项的计算结果均为 $0$。即当 $N > 8$ 时，有

$$
(N - 3) - (N - 4) \cdot (N - 5) / (N - 6) = 0
$$

剩下不能够成 $4$ 个一组成对「消去」的情况需要分类讨论。由于「笨阶乘」按照「乘」「除」「加」「减」循环的顺序定义运算，我们可以将 $N$ 按照对 $4$ 取模的余数分类讨论。

下面我们分类讨论：$N$ 对 $4$ 取模的余数分别是 $0$、$1$、$2$、$3$ 时，最后一项 $1$ 的符号是什么。

**情况一**：当 $N$ 对 $4$ 取模的余数等于 $0$ 时，有

$$
\begin{aligned}
\texttt{clumsy}(N) &= \underline{N \cdot (N - 1) / (N - 2) } + \cdots 8 \times 7 / 6 + \underline{ 5 - 4 \times 3 / 2 + 1 } \\ &= N + 1 + 5 - 6 + 1 \\
&= N + 1
\end{aligned}
$$

观察到：上式中**除了有下划线的部分，其余项的和为 $0$**。注意我们观察到数字 $8$ 后面恰好是「笨阶乘」定义的第一种运算「乘」，由它可以观察出此时 $N$ 的一般规律，即当 $N \bmod 4 = 0$ 时，最后一项 $1$ 前面是「加」。

后面的情况可以类似地进行分析。

**情况二**：当 $N$ 对 $4$ 取模的余数等于 $1$ 时，有

$$
\begin{aligned}
\texttt{clumsy}(N) &= \underline{N \cdot (N - 1) / (N - 2) } + \cdots 9 \times 8 / 7 + \underline{ 6 - 5 \times 4 / 3 + 2 - 1 } \\ 
&= N + 1 + 6 - 6 + 2 - 1 \\
&= N + 2
\end{aligned}
$$

此时最后一项 $1$ 前面是「减」。

**情况三**：当 $N$ 对 $4$ 取模的余数等于 $2$ 时，有

$$
\begin{aligned}
\texttt{clumsy}(N) &= \underline{N \cdot (N - 1) / (N - 2) } + \cdots 10 \times 9 / 8 + \underline{ 7 - 6 \times 5 / 4 + 3 - 2 \times 1 } \\
&= N + 1 + 7 - 7 + 3 - 2 \\
&= N + 2
\end{aligned}
$$

此时最后一项 $1$ 前面是「乘」。

**情况四**：当 $N$ 对 $4$ 取模的余数等于 $3$ 时，有

$$
\begin{aligned}
\texttt{clumsy}(N) &= \underline{N \cdot (N - 1) / (N - 2) } + \cdots 11 \times 10 / 9 + \underline{ 8 - 7 \times 6 / 5 + 4 - 3 \times 2 / 1 } \\
&= N + 1 + 8 - 8 + 4 - 6 \\
&= N - 1
\end{aligned}
$$
此时最后一项 $1$ 前面是「除」。

综上所述：

+ 当 $N \le 4$ 时，可以分别单独计算「笨阶乘」；

+ 当 $N > 4$ 时，可以根据 $N$ 对 $4$ 取模的余数进行分类讨论。

**代码**

```Java [sol2-Java]
class Solution {
    public int clumsy(int N) {
        if (N == 1) {
            return 1;
        } else if (N == 2) {
            return 2;
        } else if (N == 3) {
            return 6;
        } else if (N == 4) {
            return 7;
        }

        if (N % 4 == 0) {
            return N + 1;
        } else if (N % 4 <= 2) {
            return N + 2;
        } else {
            return N - 1;
        }
    }
}
```

```C++ [sol2-C++]
class Solution {
public:
    int clumsy(int N) {
        if (N == 1) {
            return 1;
        } else if (N == 2) {
            return 2;
        } else if (N == 3) {
            return 6;
        } else if (N == 4) {
            return 7;
        }

        if (N % 4 == 0) {
            return N + 1;
        } else if (N % 4 <= 2) {
            return N + 2;
        } else {
            return N - 1;
        }
    }
};
```

```go [sol2-Go]
func clumsy(N int) (ans int) {
    switch {
    case N == 1:
        return 1
    case N == 2:
        return 2
    case N == 3:
        return 6
    case N == 4:
        return 7

    case N%4 == 0:
        return N + 1
    case N%4 <= 2:
        return N + 2
    default:
        return N - 1
    }
}
```

```C [sol2-C]
int clumsy(int N) {
    if (N == 1) {
        return 1;
    } else if (N == 2) {
        return 2;
    } else if (N == 3) {
        return 6;
    } else if (N == 4) {
        return 7;
    }

    if (N % 4 == 0) {
        return N + 1;
    } else if (N % 4 <= 2) {
        return N + 2;
    } else {
        return N - 1;
    }
}
```

```JavaScript [sol2-JavaScript]
var clumsy = function(N) {
    if (N === 1) {
        return 1;
    } else if (N === 2) {
        return 2;
    } else if (N === 3) {
        return 6;
    } else if (N === 4) {
        return 7;
    }

    if (N % 4 === 0) {
        return N + 1;
    } else if (N % 4 <= 2) {
        return N + 2;
    } else {
        return N - 1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(1)$。对于任意的 $N$，计算时间都为常数。

- 空间复杂度：$O(1)$。