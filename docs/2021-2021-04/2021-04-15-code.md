# 2021年04月15日 code
<a href="https://toutiao.io/k/omkb9gy">InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><a href="https://toutiao.io/k/811or1j">学会这 10 种定时任务，我有点飘了</a><br /><a href="https://toutiao.io/k/rz5gehp">接口测试结果字段太多，断言烦不胜烦，DeepDiff 帮你一键搞定</a><br /><a href="https://toutiao.io/k/o4pjxdm">实操：如何将 Containerd 用作 Kubernetes runtime</a><br /><a href="https://toutiao.io/k/6a0hddg">Conda 简明使用指南</a><br /><a href="https://toutiao.io/k/i52m574">你知道威胁手游安全的对象有哪些吗？</a><br /><a href="https://toutiao.io/k/jen5rcs">Kafka 消息存储机制</a><br /><a href="https://toutiao.io/k/vcpcgop">使用 npm 命令行更新版本号</a><br /><a href="https://toutiao.io/k/k5cbxm5">编码编成翔的十八般兵器</a><br /><a href="https://toutiao.io/k/p3nl5uo">两万字总结《C++ Primer》要点</a><br /><a href="https://toutiao.io/k/3io59y9">Dubbo 编解码那些事</a><br /><a href="https://toutiao.io/k/f2sy94i">我叫小 M，立志建立 MySQL 帝国</a><br /><a href="https://toutiao.io/k/py1bkby">抖音 iOS 工程架构演进</a><br /><a href="https://toutiao.io/k/3e97p0w">浅谈云原生系统日志收集在数栈的实践 </a><br /><a href="https://toutiao.io/k/k6fc46h">基于 CNN + 双向 LSTM 的搭配生成算法</a><br /><a href="https://toutiao.io/k/mwpeytt">x64 平台下 inline hook 的原理、实现与防御</a><br /><a href="https://toutiao.io/k/zvtbrf9">如何通过 aop + spel 表达式玩转出不一样的切面实现</a><br /><a href="https://toutiao.io/k/s0m1xsa">美国，为中国 “送” 来光刻机</a><br /><a href="https://toutiao.io/k/t9n0w18">实时 OLAP， 从 0 到 1</a><br /><a href="https://toutiao.io/k/xj1zsqh">架构设计笔记（十五）：关键模式_微服务</a><br /><a href="https://toutiao.io/k/we8gr61">[推荐] 从需求出发设计一条开源持续部署流水线</a><br /><a href="https://toutiao.io/k/pmlwnuy">[推荐] 有哪些可以提高代码质量的书籍推荐？</a><br /><a href="https://toutiao.io/k/0yy2iga">[推荐] [译] Uber：面向领域的微服务架构</a><br /><a href="https://toutiao.io/k/gauwubg">[推荐] 我很久没写代码了，但我是个好架构师</a><br /><a href="https://toutiao.io/k/bi1fr9y">[推荐] 码云 Gitee：高并发大存储下的架构演进之路</a><br /><a href="https://toutiao.io/k/6jo6q1t">[推荐] Go 应用优化指北</a><br /><a href="https://toutiao.io/k/oa4amzb">[推荐] 使用 Git 丢失代码的 N 种操作，您中招了吗？</a><br /><a href="https://toutiao.io/k/hti1ill">[推荐] 其实，每次面试的问题都逃不过这几方面</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/9uox6mg">[推荐] 21 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/ygnbct1">[推荐] GitHub 加速指南进阶版</a><br /><a href="https://toutiao.io/k/zdnq3fy">[推荐] 踩坑 MySQL 索引，看看你真的会用吗？</a><br /><a href="https://toutiao.io/k/romtfff">[推荐] 图文详解 Java 对象内存布局</a><br /><a href="https://toutiao.io/k/iyge3cy">[推荐] 史上最全教程：idea 将 Java 项目打包 Jar 包，并生成 exe 可执行文件</a><br /><hr /><a href="https://github.com/r4j0x00/exploits"></a><br /><a href="https://github.com/microsoft/Swin-Transformer">This is an official implementation for "Swin Transformer: Hierarchical Vision Transformer using Shifted Windows".</a><br /><a href="https://github.com/Light-City/CPlusPlusThings">C++那些事</a><br /><a href="https://github.com/opensearch-project/OpenSearch">Open source distributed and RESTful search engine.</a><br /><a href="https://github.com/tailwindlabs/headlessui">Completely unstyled, fully accessible UI components, designed to integrate beautifully with Tailwind CSS.</a><br /><a href="https://github.com/d2l-ai/d2l-zh">《动手学深度学习》：面向中文读者、能运行、可讨论。中英文版被全球175所大学采用教学。</a><br /><a href="https://github.com/bradtraversy/vanillawebprojects">Mini projects built with HTML5, CSS & JavaScript. No frameworks or libraries</a><br /><a href="https://github.com/tauri-apps/tauri">Build smaller, faster, and more secure desktop applications with a web frontend.</a><br /><a href="https://github.com/opensearch-project/OpenSearch-Dashboards">Open source visualization dashboards for OpenSearch.</a><br /><a href="https://github.com/DidierRLopes/GamestonkTerminal">The next best thing after Bloomberg Terminal</a><br /><a href="https://github.com/PaddlePaddle/PaddleOCR">Awesome multilingual OCR toolkits based on PaddlePaddle （practical ultra lightweight OCR system, provide data annotation and synthesis tools, support training and deployment among server, mobile, embedded and IoT devices）</a><br /><a href="https://github.com/pamoroso/free-python-books">Python books free to read online or download</a><br /><a href="https://github.com/thedevdojo/wave">Wave - The Software as a Service Starter Kit, designed to help you build the SAAS of your dreams 🚀 💰</a><br /><a href="https://github.com/easychen/one-person-businesses-methodology">一人公司方法论</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/nordicgiant2/awesome-landing-page">A series of beautiful and practical landing page templates</a><br /><a href="https://github.com/mikepound/enigma">A java implementation of Enigma, and a modern attack to decrypt it.</a><br /><a href="https://github.com/academind/react-complete-guide-code">Code snapshots and materials for our "React - The Complete Guide" course (https://acad.link/reactjs)</a><br /><a href="https://github.com/lindelof/awesome-web-effect">A series of exquisite and compact web page cool effects</a><br /><a href="https://github.com/semi-technologies/weaviate">Weaviate is a cloud-native, modular, real-time vector search engine</a><br /><a href="https://github.com/qiurunze123/miaosha">⭐⭐⭐⭐秒杀系统设计与实现.互联网工程师进阶与分析🙋🐓</a><br /><a href="https://github.com/Serial-Studio/Serial-Studio">Multi-purpose serial data visualization & processing program</a><br /><a href="https://github.com/huggingface/transformers">🤗Transformers: State-of-the-art Natural Language Processing for Pytorch and TensorFlow 2.0.</a><br /><a href="https://github.com/login?return_to=%2Fnlohmann%2Fjson">JSON for Modern C++</a><br /><a href="https://github.com/login?return_to=%2Ffoxlet%2FmacOS-Simple-KVM">Tools to set up a quick macOS VM in QEMU, accelerated by KVM.</a><br /><hr />打家劫舍 II<br /><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>

<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,3,2]
<strong>输出：</strong>3
<strong>解释：</strong>你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3,1]
<strong>输出：</strong>4
<strong>解释：</strong>你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>0
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 100</code></li>
	<li><code>0 <= nums[i] <= 1000</code></li>
</ul>
<br />#### 前言

这道题是「[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber)」的进阶，和第 198 题的不同之处是，这道题中的房屋是首尾相连的，第一间房屋和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。

和第 198 题相似，这道题也可以使用动态规划解决。建议读者首先阅读「[198. 打家劫舍的官方题解](https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution)」，了解动态规划的思想。

#### 方法一：动态规划

首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。

注意到当房屋数量不超过两间时，最多只能偷窃一间房屋，因此不需要考虑首尾相连的问题。如果房屋数量大于两间，就必须考虑首尾相连的问题，第一间房屋和最后一间房屋不能同时偷窃。

如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。

假设数组 $\textit{nums}$ 的长度为 $n$。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 $[0, n-2]$；如果不偷窃第一间房屋，则偷窃房屋的下标范围是 $[1, n-1]$。在确定偷窃房屋的下标范围之后，即可用第 198 题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在 $n$ 间房屋中可以偷窃到的最高总金额。

假设偷窃房屋的下标范围是 $[\textit{start},\textit{end}]$，用 $\textit{dp}[i]$ 表示在下标范围 $[\textit{start},i]$ 内可以偷窃到的最高总金额，那么就有如下的状态转移方程：

$$
\textit{dp}[i] = \max(\textit{dp}[i-2]+\textit{nums}[i], \textit{dp}[i-1])
$$

边界条件为：

$$
\begin{cases}
\textit{dp}[\textit{start}] = \textit{nums}[\textit{start}] & 只有一间房屋，则偷窃该房屋 \\
\textit{dp}[\textit{start}+1] = \max(\textit{nums}[\textit{start}], \textit{nums}[\textit{start}+1]) & 只有两间房屋，偷窃其中金额较高的房屋
\end{cases}
$$

计算得到 $\textit{dp}[\textit{end}]$ 即为下标范围 $[\textit{start},\textit{end}]$ 内可以偷窃到的最高总金额。

分别取 $(\textit{start},\textit{end})=(0,n-2)$ 和 $(\textit{start},\textit{end})=(1,n-1)$ 进行计算，取两个 $\textit{dp}[\textit{end}]$ 中的最大值，即可得到最终结果。

根据上述思路，可以得到时间复杂度 $O(n)$ 和空间复杂度 $O(n)$ 的实现。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额，将空间复杂度降到 $O(1)$。

<![fig1](https://assets.leetcode-cn.com/solution-static/213/1.PNG),![fig2](https://assets.leetcode-cn.com/solution-static/213/2.PNG),![fig3](https://assets.leetcode-cn.com/solution-static/213/3.PNG),![fig4](https://assets.leetcode-cn.com/solution-static/213/4.PNG),![fig5](https://assets.leetcode-cn.com/solution-static/213/5.PNG),![fig6](https://assets.leetcode-cn.com/solution-static/213/6.PNG),![fig7](https://assets.leetcode-cn.com/solution-static/213/7.PNG),![fig8](https://assets.leetcode-cn.com/solution-static/213/8.PNG),![fig9](https://assets.leetcode-cn.com/solution-static/213/9.PNG)>

```Java [sol1-Java]
class Solution {
    public int rob(int[] nums) {
        int length = nums.length;
        if (length == 1) {
            return nums[0];
        } else if (length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
    }

    public int robRange(int[] nums, int start, int end) {
        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

```JavaScript [sol1-JavaScript]
var rob = function(nums) {
    const length = nums.length;
    if (length === 1) {
        return nums[0];
    } else if (length === 2) {
        return Math.max(nums[0], nums[1]);
    }
    return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
};

const robRange = (nums, start, end) => {
    let first = nums[start], second = Math.max(nums[start], nums[start + 1]);
    for (let i = start + 2; i <= end; i++) {
        const temp = second;
        second = Math.max(first + nums[i], second);
        first = temp;
    }
    return second;
}
```

```go [sol1-Golang]
func _rob(nums []int) int {
    first, second := nums[0], max(nums[0], nums[1])
    for _, v := range nums[2:] {
        first, second = second, max(first+v, second)
    }
    return second
}

func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }
    if n == 2 {
        return max(nums[0], nums[1])
    }
    return max(_rob(nums[:n-1]), _rob(nums[1:]))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```Python [sol1-Python3]
class Solution:
    def rob(self, nums: List[int]) -> int:
        def robRange(start: int, end: int) -> int:
            first = nums[start]
            second = max(nums[start], nums[start + 1])
            for i in range(start + 2, end + 1):
                first, second = second, max(first + nums[i], second)
            return second
        
        length = len(nums)
        if length == 1:
            return nums[0]
        elif length == 2:
            return max(nums[0], nums[1])
        else:
            return max(robRange(0, length - 2), robRange(1, length - 1))
```

```C++ [sol1-C++]
class Solution {
public:
    int robRange(vector<int>& nums, int start, int end) {
        int first = nums[start], second = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            int temp = second;
            second = max(first + nums[i], second);
            first = temp;
        }
        return second;
    }

    int rob(vector<int>& nums) {
        int length = nums.size();
        if (length == 1) {
            return nums[0];
        } else if (length == 2) {
            return max(nums[0], nums[1]);
        }
        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
    }
};
```

```C [sol1-C]
int robRange(int* nums, int start, int end) {
    int first = nums[start], second = fmax(nums[start], nums[start + 1]);
    for (int i = start + 2; i <= end; i++) {
        int temp = second;
        second = fmax(first + nums[i], second);
        first = temp;
    }
    return second;
}

int rob(int* nums, int numsSize) {
    if (numsSize == 1) {
        return nums[0];
    } else if (numsSize == 2) {
        return fmax(nums[0], nums[1]);
    }
    return fmax(robRange(nums, 0, numsSize - 2), robRange(nums, 1, numsSize - 1));
}
```

**复杂度分析**

* 时间复杂度：$O(n)$，其中 $n$ 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。

* 空间复杂度：$O(1)$。