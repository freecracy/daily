# 2021年04月25日 code
<a href="https://toutiao.io/k/08uadl6">书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/13htx1u">如何正确新增字段</a><br /><a href="https://toutiao.io/k/us38se6">实时数仓中的消息队列技术深度对比</a><br /><a href="https://toutiao.io/k/yk8may5">CPU 和 GPU：异构计算的演进与发展</a><br /><a href="https://toutiao.io/k/ye0n3l3">一文带你更方便的控制 goroutine</a><br /><a href="https://toutiao.io/k/m00a5i0">代码评审中的代码协同</a><br /><a href="https://toutiao.io/k/xs1ylcq">Android 嵌套 Intent</a><br /><a href="https://toutiao.io/k/p2tmwwq">什么是蠢问题？</a><br /><a href="https://toutiao.io/k/o33m49w">工具 | 阿里巴巴开源的，基于 Flutter 的 Web 渲染引擎</a><br /><a href="https://toutiao.io/k/q4va51n">加密原理详解：对称式加密 VS 非对称式加密</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/82eogba">[推荐] Git 分支管理策略与工作流程</a><br /><a href="https://toutiao.io/k/syxnrph">[推荐] OpenResty 实现限流</a><br /><a href="https://toutiao.io/k/3bv147y">[推荐] 免费正版 IntelliJ IDEA license 详细指南</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><a href="https://toutiao.io/k/zxa65u1">[推荐] 超级详细的 Spring Boot 注解总结</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/4zqz7k1">[推荐] RESTful API 设计最佳实践</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/7uw9l2r">[推荐] JVM 进阶之路（九）：性能监控工具（可视化工具篇）</a><br /><a href="https://toutiao.io/k/811or1j">[推荐] 学会这 10 种定时任务，我有点飘了</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><hr /><a href="https://github.com/eva-engine/eva.js">Eva.js is a front-end game engine specifically for creating interactive game projects.</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/981011512/--">停车场系统源码，停车场小程序【功能介绍】：①兼容市面上主流的多家相机，理论上兼容所有硬件，可灵活扩展，②相机识别后数据自动上传到云端并记录，校验相机唯一id和硬件序列号，防止非法数据录入，③用户手机查询停车记录详情可自主缴费(支持微信，支付宝，银行接口支付，支持每个停车场指定不同的商户进行收款)，支付后出场在免费时间内会自动抬杆。④支持app上查询附近停车场(导航，可用车位数，停车场费用，优惠券，评分，评论等)，可预约车位。⑤断电断网支持岗亭人员使用app可接管硬件进行停车记录的录入。 【技术架构】：后端开发语言java，框架oauth2+springboot2+dubble，数据库mysql/mongodb/redis，即时通讯底层框架netty4，安卓和ios均为原生开发，后台管理…</a><br /><a href="https://github.com/login?return_to=%2Fueberdosis%2Ftiptap">The headless editor framework for web artisans.</a><br /><a href="https://github.com/google/googletest">Googletest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/microsoft/wslg">Enabling the Windows Subsystem for Linux to include support for Wayland and X server related scenarios</a><br /><a href="https://github.com/facebook/react-native">A framework for building native apps with React.</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/login?return_to=%2Fphotoprism%2Fphotoprism">Personal Photo Management powered by Go and Google TensorFlow</a><br /><a href="https://github.com/TixiaoShan/LVI-SAM">LVI-SAM: Tightly-coupled Lidar-Visual-Inertial Odometry via Smoothing and Mapping</a><br /><a href="https://github.com/jdah/tetris-os">An operating system, but it only plays Tetris.</a><br /><a href="https://github.com/openkraken/kraken">A high-performance, web standards-compliant rendering engine based on Flutter.</a><br /><a href="https://github.com/luong-komorebi/Awesome-Linux-Software">A list of awesome applications, software, tools and other materials for Linux distros.</a><br /><a href="https://github.com/gh0stkey/Binary-Learning">滴水逆向初、中级学习笔记，不定时更新，自用仓库，不喜勿喷；感谢滴水，有如此完整体系的学习视频，白嫖党嫖了一波...感谢海东老师，听课受益匪浅。</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/taichi-dev/taichi">Productive & portable programming language for high-performance, sparse & differentiable computing on CPUs & GPUs</a><br /><a href="https://github.com/jackfrued/Python-100-Days">Python - 100天从新手到大师</a><br /><a href="https://github.com/openvinotoolkit/openvino_notebooks">📚 A collection of Python notebooks for learning and experimenting with OpenVINO 👓</a><br /><a href="https://github.com/rrweb-io/rrweb">record and replay the web</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/chefyuan/algorithm-base">专门为刚开始刷题的同学准备的算法基地，没有最细只有更细，立志用动画将晦涩难懂的算法说的通俗易懂！</a><br /><a href="https://github.com/RH12503/triangula">Generate high-quality triangulated art from images.</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：配思维导图，将近200道经典算法题目刷题顺序、经典算法模板、共60w字的详细图解，以及难点视频题解。按照刷题攻略上的顺序来刷题，让你在算法学习上不再迷茫！🔥🔥给个star支持一下吧！🚀</a><br /><a href="https://github.com/PrestaShop/PrestaShop">PrestaShop is a fully scalable open source e-commerce solution.</a><br /><a href="https://github.com/josepholiveira/podcastr">A platform built for podcast broadcasting. Developed during @Rocketseat NLW#05 free training.</a><br /><hr />递增顺序搜索树<br /><p>给你一棵二叉搜索树，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" style="width: 600px; height: 350px;" />
<pre>
<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" style="width: 300px; height: 114px;" />
<pre>
<strong>输入：</strong>root = [5,1,7]
<strong>输出：</strong>[1,null,5,null,7]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点数的取值范围是 <code>[1, 100]</code></li>
	<li><code>0 <= Node.val <= 1000</code></li>
</ul>
<br />#### 方法一：中序遍历之后生成新的树

**算法**

题目要求我们返回按照中序遍历的结果改造而成的、只有右节点的**等价**二叉搜索树。我们可以进行如下操作：

- 先对输入的二叉搜索树执行中序遍历，将结果保存到一个列表中；

- 然后根据列表中的节点值，创建等价的只含有右节点的二叉搜索树，其过程等价于根据节点值创建一个链表。

**代码**

```Java [sol1-Java]
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);

        TreeNode dummyNode = new TreeNode(-1);
        TreeNode currNode = dummyNode;
        for (int value : res) {
            currNode.right = new TreeNode(value);
            currNode = currNode.right;
        }
        return dummyNode.right;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if (node == null) {
            return;
        }
        inorder(node.left, res);
        res.add(node.val);
        inorder(node.right, res);
    }
}
```

```JavaScript [sol1-JavaScript]
var increasingBST = function(root) {
    const res = [];
    inorder(root, res);

    const dummyNode = new TreeNode(-1);
    let currNode = dummyNode;
    for (const value of res) {
        currNode.right = new TreeNode(value);
        currNode = currNode.right;
    }
    return dummyNode.right;
};

const inorder = (node, res) => {
    if (!node) {
        return;
    }
    inorder(node.left, res);
    res.push(node.val);
    inorder(node.right, res);
}
```

```go [sol1-Golang]
func increasingBST(root *TreeNode) *TreeNode {
    vals := []int{}
    var inorder func(*TreeNode)
    inorder = func(node *TreeNode) {
        if node != nil {
            inorder(node.Left)
            vals = append(vals, node.Val)
            inorder(node.Right)
        }
    }
    inorder(root)

    dummyNode := &TreeNode{}
    curNode := dummyNode
    for _, val := range vals {
        curNode.Right = &TreeNode{Val: val}
        curNode = curNode.Right
    }
    return dummyNode.Right
}
```

```C++ [sol1-C++]
class Solution {
public:
    void inorder(TreeNode *node, vector<int> &res) {
        if (node == nullptr) {
            return;
        }
        inorder(node->left, res);
        res.push_back(node->val);
        inorder(node->right, res);
    }

    TreeNode *increasingBST(TreeNode *root) {
        vector<int> res;
        inorder(root, res);

        TreeNode *dummyNode = new TreeNode(-1);
        TreeNode *currNode = dummyNode;
        for (int value : res) {
            currNode->right = new TreeNode(value);
            currNode = currNode->right;
        }
        return dummyNode->right;
    }
};
```

```C [sol1-C]
struct TreeNode* createTreeNode(int val) {
    struct TreeNode* ret = malloc(sizeof(struct TreeNode));
    ret->val = val, ret->left = ret->right = NULL;
    return ret;
}

void inorder(struct TreeNode* node, int* res, int* resSize) {
    if (node == NULL) {
        return;
    }
    inorder(node->left, res, resSize);
    res[(*resSize)++] = node->val;
    inorder(node->right, res, resSize);
}

struct TreeNode* increasingBST(struct TreeNode* root) {
    int res[100], resSize = 0;
    inorder(root, res, &resSize);

    struct TreeNode* dummyNode = createTreeNode(-1);
    struct TreeNode* currNode = dummyNode;
    for (int i = 0; i < resSize; i++) {
        currNode->right = createTreeNode(res[i]);
        currNode = currNode->right;
    }
    return dummyNode->right;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点总数。

- 空间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点总数。需要长度为 $n$ 的列表保存二叉搜索树的所有节点的值。

#### 方法二：在中序遍历的过程中改变节点指向

**算法**

方法一需要遍历一次二叉搜索树以后，然后再创建新的等价的二叉搜索树。事实上，还可以遍历一次输入二叉搜索树，在遍历的过程中改变节点指向以满足题目的要求。

在中序遍历的时候，修改节点指向就可以实现。具体地，当我们遍历到一个节点时，把它的左孩子设为空，并将其本身作为上一个遍历到的节点的右孩子。这里需要有一些想象能力。递归遍历的过程中，由于递归函数的调用栈保存了节点的引用，因此上述操作可以实现。下面的幻灯片展示了这样的过程。

<![1.png](https://pic.leetcode-cn.com/1617605893-CYccaw-1.png),![2.png](https://pic.leetcode-cn.com/1617605893-wVIkEe-2.png),![3.png](https://pic.leetcode-cn.com/1617605893-wVNSxo-3.png),![4.png](https://pic.leetcode-cn.com/1617605893-MRrcNu-4.png),![5.png](https://pic.leetcode-cn.com/1617605893-ZaLISJ-5.png),![6.png](https://pic.leetcode-cn.com/1617605893-tdVhEG-6.png),![7.png](https://pic.leetcode-cn.com/1617605893-ljGMbE-7.png),![8.png](https://pic.leetcode-cn.com/1617605893-ObVBhn-8.png),![9.png](https://pic.leetcode-cn.com/1617605893-alyIKA-9.png),![10.png](https://pic.leetcode-cn.com/1617605893-hRHcnK-10.png),![11.png](https://pic.leetcode-cn.com/1617605893-AZbrbl-11.png),![12.png](https://pic.leetcode-cn.com/1617605893-aAIrLT-12.png),![13.png](https://pic.leetcode-cn.com/1617605893-IrZyWz-13.png),![14.png](https://pic.leetcode-cn.com/1617605893-EzRWkT-14.png),![15.png](https://pic.leetcode-cn.com/1617605893-INQjIh-15.png),![16.png](https://pic.leetcode-cn.com/1617605893-XUkntJ-16.png),![17.png](https://pic.leetcode-cn.com/1617605893-SNRECU-17.png),![18.png](https://pic.leetcode-cn.com/1617605893-MJNEuw-18.png),![19.png](https://pic.leetcode-cn.com/1617605893-APxVgX-19.png),![20.png](https://pic.leetcode-cn.com/1617605893-kncxnf-20.png),![21.png](https://pic.leetcode-cn.com/1617605893-AfojZp-21.png),![22.png](https://pic.leetcode-cn.com/1617605893-arlRwv-22.png),![23.png](https://pic.leetcode-cn.com/1617605893-dRsEXD-23.png),![24.png](https://pic.leetcode-cn.com/1617605893-mmcVcf-24.png),![25.png](https://pic.leetcode-cn.com/1617605893-PlYUtg-25.png),![26.png](https://pic.leetcode-cn.com/1617605893-oowOmh-26.png),![27.png](https://pic.leetcode-cn.com/1617605893-uzfpip-27.png)>

**代码**

```Java [sol2-Java]
class Solution {
    private TreeNode resNode;

    public TreeNode increasingBST(TreeNode root) {
        TreeNode dummyNode = new TreeNode(-1);
        resNode = dummyNode;
        inorder(root);
        return dummyNode.right;
    }

    public void inorder(TreeNode node) {
        if (node == null) {
            return;
        }
        inorder(node.left);

        // 在中序遍历的过程中修改节点指向
        resNode.right = node;
        node.left = null;
        resNode = node;

        inorder(node.right);
    }
}
```

```JavaScript [sol2-JavaScript]
var increasingBST = function(root) {
    const dummyNode = new TreeNode(-1);
    let resNode = dummyNode;
    const inorder = (node) => {
        if (!node) {
            return;
        }
        inorder(node.left);

        // 在中序遍历的过程中修改节点指向
        resNode.right = node;
        node.left = null;
        resNode = node;

        inorder(node.right);
    }
    inorder(root);
    return dummyNode.right;
};
```

```go [sol2-Golang]
func increasingBST(root *TreeNode) *TreeNode {
    dummyNode := &TreeNode{}
    resNode := dummyNode

    var inorder func(*TreeNode)
    inorder = func(node *TreeNode) {
        if node == nil {
            return
        }
        inorder(node.Left)

        // 在中序遍历的过程中修改节点指向
        resNode.Right = node
        node.Left = nil
        resNode = node

        inorder(node.Right)
    }
    inorder(root)

    return dummyNode.Right
}
```

```C++ [sol1-C++]
class Solution {
private:
    TreeNode *resNode;

public:
    void inorder(TreeNode *node) {
        if (node == nullptr) {
            return;
        }
        inorder(node->left);

        // 在中序遍历的过程中修改节点指向
        resNode->right = node;
        node->left = nullptr;
        resNode = node;

        inorder(node->right);
    }

    TreeNode *increasingBST(TreeNode *root) {
        TreeNode *dummyNode = new TreeNode(-1);
        resNode = dummyNode;
        inorder(root);
        return dummyNode->right;
    }
};
```

```C [sol1-C]
struct TreeNode* createTreeNode(int val) {
    struct TreeNode* ret = malloc(sizeof(struct TreeNode));
    ret->val = val, ret->left = ret->right = NULL;
    return ret;
}

struct TreeNode* resNode;

void inorder(struct TreeNode* node) {
    if (node == NULL) {
        return;
    }
    inorder(node->left);

    // 在中序遍历的过程中修改节点指向
    resNode->right = node;
    node->left = NULL;
    resNode = node;

    inorder(node->right);
}
struct TreeNode* increasingBST(struct TreeNode* root) {
    struct TreeNode* dummyNode = createTreeNode(-1);
    resNode = dummyNode;
    inorder(root);
    return dummyNode->right;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点总数。

- 空间复杂度：$O(n)$。递归过程中的栈空间开销为 $O(n)$。