# 2021年04月21日 code
<a href="https://toutiao.io/k/j7fdh6h">一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/w7xb2nj">Java 8 中的 Stream 流式操作：入门篇</a><br /><a href="https://toutiao.io/k/k81cs3j">MyBatis 优秀的设计总结</a><br /><a href="https://toutiao.io/k/xqvnsdu">代码审查 (Code Review) 的本质</a><br /><a href="https://toutiao.io/k/0f8qtmv">跟我一起学 Go 系列：从写测试用例开始仗剑走天涯</a><br /><a href="https://toutiao.io/k/bbqdske">测试应用启动性能</a><br /><a href="https://toutiao.io/k/htbqof4">演习与混沌工程</a><br /><a href="https://toutiao.io/k/cjkpkjl">“改造” VS Code 编辑器，一起写个插件吧</a><br /><a href="https://toutiao.io/k/fofjm8d">[译] 用 Golang 实现 RSA 加密和签名（有示例）</a><br /><a href="https://toutiao.io/k/3qw931q">OLAP 分析引擎，基于 Druid 组件数据统计分析</a><br /><a href="https://toutiao.io/k/rl2pa2q">最清晰易懂的 Go sync.WaitGroup 剖析</a><br /><a href="https://toutiao.io/k/n0kbg7d">[译] 每个 Apache Kafka 开发者都应该知道的 5 件事</a><br /><a href="https://toutiao.io/k/2se9osh">深入 AQS 源码，搞懂核心思想</a><br /><a href="https://toutiao.io/k/d4tpbr8">“一学就会” 微服务的架构模式：一个服务一个数据库模式（上）</a><br /><a href="https://toutiao.io/k/125ec1c">深入剖析共识性算法 Raft</a><br /><a href="https://toutiao.io/k/96r3jin">微信小程序接口自动化的实现方案</a><br /><a href="https://toutiao.io/k/uoj7sne">工具 | 百度开源的函数计算服务引擎</a><br /><a href="https://toutiao.io/k/91729fo">应 "云" 而生的 Java 框架 Quarkus：构建本机可执行文件</a><br /><a href="https://toutiao.io/k/00svame">ElasticSearch 如何使用 TDigest 算法计算亿级数据的百分位数？</a><br /><a href="https://toutiao.io/k/5qw1645">AI 入行那些事儿（十）：人工智能的应用领域</a><br /><a href="https://toutiao.io/k/ai4cybd">面试官：说说什么是 Java 内存模型？</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/7uw9l2r">[推荐] JVM 进阶之路（九）：性能监控工具（可视化工具篇）</a><br /><a href="https://toutiao.io/k/zdnq3fy">[推荐] 踩坑 MySQL 索引，看看你真的会用吗？</a><br /><a href="https://toutiao.io/k/6aau0fc">[推荐] 一文读懂，DDD 落地数据库设计实战</a><br /><a href="https://toutiao.io/k/82eogba">[推荐] Git 分支管理策略与工作流程</a><br /><a href="https://toutiao.io/k/gauwubg">[推荐] 我很久没写代码了，但我是个好架构师</a><br /><a href="https://toutiao.io/k/feyaceo">[推荐] 两次被裁之后，我终于解决了数据库缓存一致性问题</a><br /><a href="https://toutiao.io/k/pmlwnuy">[推荐] 有哪些可以提高代码质量的书籍推荐？</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/68q4m1v">[推荐] 架构设计方法论</a><br /><a href="https://toutiao.io/k/bi1fr9y">[推荐] 码云 Gitee：高并发大存储下的架构演进之路</a><br /><a href="https://toutiao.io/k/906zu1i">[推荐] 教你从头写游戏服务器框架</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><a href="https://toutiao.io/k/811or1j">[推荐] 学会这 10 种定时任务，我有点飘了</a><br /><a href="https://toutiao.io/k/4zqz7k1">[推荐] RESTful API 设计最佳实践</a><br /><hr /><a href="https://github.com/CyberPunkMetalHead/Binance-News-Sentiment-Bot">This is a fully functioning Binance trading bot that takes into account the news sentiment for the top 100 crypto feeds.</a><br /><a href="https://github.com/testerSunshine/12306">12306智能刷票，订票</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/login?return_to=%2Fsharkdp%2Fbat">A cat(1) clone with wings.</a><br /><a href="https://github.com/scottbez1/splitflap">DIY split-flap display</a><br /><a href="https://github.com/chefyuan/algorithm-base">专门为刚开始刷题的同学准备的算法基地，没有最细只有更细，立志用动画将晦涩难懂的算法说的通俗易懂！</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/Rog3rSm1th/Profil3r">OSINT tool that allows you to find a person's accounts and emails + breached emails 🕵️</a><br /><a href="https://github.com/Chia-Network/chia-blockchain-gui">Chia blockchain GUI in electron/react</a><br /><a href="https://github.com/Netflix/consoleme">A Central Control Plane for AWS Permissions and Access</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/github/docs">The open-source repo for docs.github.com</a><br /><a href="https://github.com/recastnavigation/recastnavigation">Navigation-mesh Toolset for Games</a><br /><a href="https://github.com/SerenityOS/serenity">The Serenity Operating System 🐞</a><br /><a href="https://github.com/ekzhang/graphics-workshop">Learn computer graphics by writing GPU shaders!</a><br /><a href="https://github.com/speechbrain/speechbrain">A PyTorch-based Speech Toolkit</a><br /><a href="https://github.com/mpv-player/mpv">🎥 Command line video player</a><br /><a href="https://github.com/ascoders/weekly">前端精读周刊。帮你理解最前沿、实用的技术。</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/louisfb01/start-machine-learning-in-2020">A complete guide to start and improve in machine learning (ML), artificial intelligence (AI) in 2021 without ANY background in the field and stay up-to-date with the latest news and state-of-the-art techniques!</a><br /><a href="https://github.com/croccio/CarTube">YouTube for Android Auto without ROOT (rootless)</a><br /><a href="https://github.com/Datalux/Osintgram">Osintgram is a OSINT tool on Instagram. It offers an interactive shell to perform analysis on Instagram account of any users by its nickname</a><br /><a href="https://github.com/jasontaylordev/CleanArchitecture">Clean Architecture Solution Template for Angular 10 and .NET 5</a><br /><a href="https://github.com/Minhluu2911/Machine_Learning_2_months">I'm challenging to myself to learn Machine Learning Algorithms, as much as I can within 2 months</a><br /><a href="https://github.com/onnx/onnx">Open standard for machine learning interoperability</a><br /><hr />解码方法<br /><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>

<pre>
'A' -> 1
'B' -> 2
...
'Z' -> 26
</pre>

<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>"11106"</code> 可以映射为：</p>

<ul>
	<li><code>"AAJF"</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
	<li><code>"KJF"</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>

<p>注意，消息不能分组为  <code>(1 11 06)</code> ，因为 <code>"06"</code> 不能映射为 <code>"F"</code> ，这是由于 <code>"6"</code> 和 <code>"06"</code> 在映射中并不等价。</p>

<p>给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>

<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "12"
<strong>输出：</strong>2
<strong>解释：</strong>它可以解码为 "AB"（1 2）或者 "L"（12）。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "226"
<strong>输出：</strong>3
<strong>解释：</strong>它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "0"
<strong>输出：</strong>0
<strong>解释：</strong>没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>s = "06"
<strong>输出：</strong>0
<strong>解释：</strong>"06" 不能映射到 "F" ，因为字符串含有前导 0（<code>"6"</code> 和 <code>"06"</code> 在映射中并不等价）。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= s.length <= 100</code></li>
	<li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
<br />#### 方法一：动态规划

**思路与算法**

对于给定的字符串 $s$，设它的长度为 $n$，其中的字符从左到右依次为 $s[1], s[2], \cdots, s[n]$。我们可以使用动态规划的方法计算出字符串 $s$ 的解码方法数。

具体地，设 $f_i$ 表示字符串 $s$ 的前 $i$ 个字符 $s[1..i]$ 的解码方法数。在进行状态转移时，我们可以考虑最后一次解码使用了 $s$ 中的哪些字符，那么会有下面的两种情况：

- 第一种情况是我们使用了一个字符，即 $s[i]$ 进行解码，那么只要 $s[i] \neq 0$，它就可以被解码成 $\text{A} \sim \text{I}$ 中的某个字母。由于剩余的前 $i-1$ 个字符的解码方法数为 $f_{i-1}$，因此我们可以写出状态转移方程：

    $$
    f_i = f_{i-1}, \quad 其中 ~ s[i] \neq 0
    $$

- 第二种情况是我们使用了两个字符，即 $s[i-1]$ 和 $s[i]$ 进行编码。与第一种情况类似，$s[i-1]$ 不能等于 $0$，并且 $s[i-1]$ 和 $s[i]$ 组成的整数必须小于等于 $26$，这样它们就可以被解码成 $\text{J} \sim \text{Z}$ 中的某个字母。由于剩余的前 $i-2$ 个字符的解码方法数为 $f_{i-2}$，因此我们可以写出状态转移方程：

    $$
    f_i = f_{i-2}, \quad 其中 ~ s[i-1] \neq 0 ~并且~ 10\cdot s[i-1]+s[i] \leq 26
    $$

    需要注意的是，只有当 $i>1$ 时才能进行转移，否则 $s[i-1]$ 不存在。

将上面的两种状态转移方程在对应的条件满足时进行累加，即可得到 $f_i$ 的值。在动态规划完成后，最终的答案即为 $f_n$。

**细节**

动态规划的边界条件为：

$$
f_0 = 1
$$

即**空字符串可以有 $1$ 种解码方法，解码出一个空字符串**。

同时，由于在大部分语言中，字符串的下标是从 $0$ 而不是 $1$ 开始的，因此在代码的编写过程中，我们需要将所有字符串的下标减去 $1$，与使用的语言保持一致。

**代码**

```C++ [sol11-C++]
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> f(n + 1);
        f[0] = 1;
        for (int i = 1; i <= n; ++i) {
            if (s[i - 1] != '0') {
                f[i] += f[i - 1];
            }
            if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
};
```

```Java [sol11-Java]
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i <= n; ++i) {
            if (s.charAt(i - 1) != '0') {
                f[i] += f[i - 1];
            }
            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                f[i] += f[i - 2];
            }
        }
        return f[n];
    }
}
```

```Python [sol11-Python3]
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        f = [1] + [0] * n
        for i in range(1, n + 1):
            if s[i - 1] != '0':
                f[i] += f[i - 1]
            if i > 1 and s[i - 2] != '0' and int(s[i-2:i]) <= 26:
                f[i] += f[i - 2]
        return f[n]
```

```JavaScript [sol11-JavaScript]
var numDecodings = function(s) {
    const n = s.length;
    const f = new Array(n + 1).fill(0);
    f[0] = 1;
    for (let i = 1; i <= n; ++i) {
        if (s[i - 1] !== '0') {
            f[i] += f[i - 1];
        }
        if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
            f[i] += f[i - 2];
        }
    }
    return f[n];
};
```

```go [sol11-Golang]
func numDecodings(s string) int {
    n := len(s)
    f := make([]int, n+1)
    f[0] = 1
    for i := 1; i <= n; i++ {
        if s[i-1] != '0' {
            f[i] += f[i-1]
        }
        if i > 1 && s[i-2] != '0' && ((s[i-2]-'0')*10+(s[i-1]-'0') <= 26) {
            f[i] += f[i-2]
        }
    }
    return f[n]
}
```

```C [sol11-C]
int numDecodings(char* s) {
    int n = strlen(s);
    int f[n + 1];
    memset(f, 0, sizeof(f));
    f[0] = 1;
    for (int i = 1; i <= n; ++i) {
        if (s[i - 1] != '0') {
            f[i] += f[i - 1];
        }
        if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
            f[i] += f[i - 2];
        }
    }
    return f[n];
}
```

注意到在状态转移方程中，$f_i$ 的值仅与 $f_{i-1}$ 和 $f_{i-2}$ 有关，因此我们可以使用三个变量进行状态转移，省去数组的空间。

```C++ [sol12-C++]
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        // a = f[i-2], b = f[i-1], c = f[i]
        int a = 0, b = 1, c;
        for (int i = 1; i <= n; ++i) {
            c = 0;
            if (s[i - 1] != '0') {
                c += b;
            }
            if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
                c += a;
            }
            tie(a, b) = {b, c};
        }
        return c;
    }
};
```

```Java [sol12-Java]
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        // a = f[i-2], b = f[i-1], c=f[i]
        int a = 0, b = 1, c = 0;
        for (int i = 1; i <= n; ++i) {
            c = 0;
            if (s.charAt(i - 1) != '0') {
                c += b;
            }
            if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                c += a;
            }
            a = b;
            b = c;
        }
        return c;
    }
}
```

```Python [sol12-Python3]
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        # a = f[i-2], b = f[i-1], c = f[i]
        a, b, c = 0, 1, 0
        for i in range(1, n + 1):
            c = 0
            if s[i - 1] != '0':
                c += b
            if i > 1 and s[i - 2] != '0' and int(s[i-2:i]) <= 26:
                c += a
            a, b = b, c
        return c
```

```JavaScript [sol12-JavaScript]
var numDecodings = function(s) {
    const n = s.length;
    // a = f[i-2], b = f[i-1], c = f[i]
    let a = 0, b = 1, c = 0;
    for (let i = 1; i <= n; ++i) {
        c = 0;
        if (s[i - 1] !== '0') {
            c += b;
        }
        if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
            c += a;
        }
        a = b;
        b = c;
    }
    return c;
};
```

```go [sol12-Golang]
func numDecodings(s string) int {
    n := len(s)
    // a = f[i-2], b = f[i-1], c = f[i]
    a, b, c := 0, 1, 0
    for i := 1; i <= n; i++ {
        c = 0
        if s[i-1] != '0' {
            c += b
        }
        if i > 1 && s[i-2] != '0' && ((s[i-2]-'0')*10+(s[i-1]-'0') <= 26) {
            c += a
        }
        a, b = b, c
    }
    return c
}
```

```C [sol12-C]
int numDecodings(char* s) {
    int n = strlen(s);
    // a = f[i-2], b = f[i-1], c = f[i]
    int a = 0, b = 1, c;
    for (int i = 1; i <= n; ++i) {
        c = 0;
        if (s[i - 1] != '0') {
            c += b;
        }
        if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {
            c += a;
        }
        a = b, b = c;
    }
    return c;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。

- 空间复杂度：$O(n)$ 或 $O(1)$。如果使用数组进行状态转移，空间复杂度为 $O(n)$；如果仅使用三个变量，空间复杂度为 $O(1)$。