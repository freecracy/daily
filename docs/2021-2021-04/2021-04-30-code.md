# 2021年04月30日 code
<a href="https://toutiao.io/k/8gzyh5c">可能是最好用的 Taro 小程序路由库</a><br /><a href="https://toutiao.io/k/eyk6ijj">云上细粒度访问管理的参考架构</a><br /><a href="https://toutiao.io/k/5g18w9p">运行 3000 次都不出错的 MIT 6.824 Raft 实验</a><br /><a href="https://toutiao.io/k/09egmu8">Prometheus + Grafana 快速上手</a><br /><a href="https://toutiao.io/k/ikalxbo">万字长文讲述我是怎样保送清华的 | 寒门学子奋斗史（四）</a><br /><a href="https://toutiao.io/k/bllxzxj">排查 Dubbo 接口重复注销问题，我发现了一个巧妙的设计</a><br /><a href="https://toutiao.io/k/v1291xo">基于拉链式和线性探测式散列表实现 Map</a><br /><a href="https://toutiao.io/k/upn8q80">代码审查实践经验分享：应该是大写还是小写？</a><br /><a href="https://toutiao.io/k/x7otoc2">我是如何把微服务的这个模式落地的：一个服务一个数据库模式（中）</a><br /><a href="https://toutiao.io/k/oq5qkeb">GitHub 提权项目推荐</a><br /><a href="https://toutiao.io/k/y1kcddr">如何把 Caffeine Cache 用得如丝般顺滑？</a><br /><a href="https://toutiao.io/k/70xdujl">一坨一坨的 if/else 参数校验，终于被 Spring Boot 参数校验组件整干净了</a><br /><a href="https://toutiao.io/k/ij2hbj5">MySQL 索引十连问</a><br /><a href="https://toutiao.io/k/zoaa9id">你已经用上 5G 网络了吗？</a><br /><a href="https://toutiao.io/k/nb71eib">WorkManager 系列课程 | MAD Skills</a><br /><a href="https://toutiao.io/k/8jy3xbs">一文学会 Hive 解析 Json 数组</a><br /><a href="https://toutiao.io/k/m5yhd4b">闲鱼正在悄悄放弃 Flutter 吗？</a><br /><a href="https://toutiao.io/k/0qwa25x">漫画：如何在人群中快速识别一个程序员</a><br /><a href="https://toutiao.io/k/foj50ju">图神经网络在生化医疗方面的相关应用</a><br /><a href="https://toutiao.io/k/wyhlltd">有趣的面试题：Go 语言字符串的字节长度和字符个数</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/zxa65u1">[推荐] 超级详细的 Spring Boot 注解总结</a><br /><a href="https://toutiao.io/k/90vs9kg">[推荐] ClickHouse 在 Bilibili 用户行为分析的实践</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/syxnrph">[推荐] OpenResty 实现限流</a><br /><hr /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/scala-open-letter/scala-open-letter.github.io"></a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/login?return_to=%2Fopenssl%2Fopenssl">TLS/SSL and crypto library</a><br /><a href="https://github.com/doocs/leetcode">😏 LeetCode solutions in any programming language | 多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解</a><br /><a href="https://github.com/Developer-Y/cs-video-courses">List of Computer Science courses with video lectures.</a><br /><a href="https://github.com/nextapps-de/winbox">WinBox is a professional HTML5 window manager for the web: lightweight, outstanding performance, no dependencies, fully customizable, open source!</a><br /><a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a><br /><a href="https://github.com/nekohasekai/SagerNet">The universal proxy toolchain for Android.</a><br /><a href="https://github.com/chrisleekr/binance-trading-bot">Automated Binance trading bot - Buy low/Sell high with stop loss limit/Trade multiple cryptocurrencies</a><br /><a href="https://github.com/johnBuffer/AntSimulator">Simple Ants simulator</a><br /><a href="https://github.com/UnityTechnologies/open-project-1">Unity Open Project #1: Chop Chop</a><br /><a href="https://github.com/vuetifyjs/vuetify">🐉 Material Component Framework for Vue</a><br /><a href="https://github.com/jackfrued/Python-100-Days">Python - 100天从新手到大师</a><br /><a href="https://github.com/ansible/ansible">Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems. https://docs.ansible.com.</a><br /><a href="https://github.com/ryanmcdermott/clean-code-javascript">🛁 Clean Code concepts adapted for JavaScript</a><br /><a href="https://github.com/terraform-providers/terraform-provider-azurerm">Terraform provider for Azure Resource Manager</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/wuyouzhuguli/SpringAll">循序渐进，学习Spring Boot、Spring Boot & Shiro、Spring Batch、Spring Cloud、Spring Cloud Alibaba、Spring Security & Spring Security OAuth2，博客Spring系列源码：https://mrbird.cc</a><br /><a href="https://github.com/airbus-seclab/qemu_blog">A series of posts about QEMU internals</a><br /><a href="https://github.com/pointfreeco/swift-composable-architecture">A library for building applications in a consistent and understandable way, with composition, testing, and ergonomics in mind.</a><br /><a href="https://github.com/Unity-Technologies/Graphics">Unity Graphics - Including Scriptable Render Pipeline</a><br /><a href="https://github.com/tensorflow/tensorflow">An Open Source Machine Learning Framework for Everyone</a><br /><a href="https://github.com/acidanthera/OpenCorePkg">OpenCore bootloader</a><br /><hr />只出现一次的数字 II<br /><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,2,3,2]
<strong>输出：</strong>3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,1,0,1,0,1,99]
<strong>输出：</strong>99
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>
	<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>
	<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<br />#### 方法一：哈希表

**思路与算法**

我们可以使用哈希映射统计数组中每个元素的出现次数。对于哈希映射中的每个键值对，键表示一个元素，值表示其出现的次数。

在统计完成后，我们遍历哈希映射即可找出只出现一次的元素。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> freq;
        for (int num: nums) {
            ++freq[num];
        }
        int ans = 0;
        for (auto [num, occ]: freq) {
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        freq = collections.Counter(nums)
        ans = [num for num, occ in freq.items() if occ == 1][0]
        return ans
```

```JavaScript [sol1-JavaScript]
var singleNumber = function(nums) {
    const freq = new Map();
    for (const num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    let ans = 0;
    for (const [num, occ] of freq.entries()) {
        if (occ === 1) {
            ans = num;
            break;
        }
    }
    return ans;
};
```

```go [sol1-Golang]
func singleNumber(nums []int) int {
    freq := map[int]int{}
    for _, v := range nums {
        freq[v]++
    }
    for num, occ := range freq {
        if occ == 1 {
            return num
        }
    }
    return 0 // 不会发生，数据保证有一个元素仅出现一次
}
```

```C [sol1-C]
struct HashTable {
    int key, val;
    UT_hash_handle hh;
};

int singleNumber(int *nums, int numsSize) {
    struct HashTable *hashTable = NULL;
    for (int i = 0; i < numsSize; i++) {
        struct HashTable *tmp;
        HASH_FIND_INT(hashTable, &nums[i], tmp);
        if (tmp == NULL) {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = nums[i];
            tmp->val = 1;
            HASH_ADD_INT(hashTable, key, tmp);
        } else {
            tmp->val++;
        }
    }
    int ans = 0;
    struct HashTable *iter, *tmp;
    HASH_ITER(hh, hashTable, iter, tmp) {
        if (iter->val == 1) {
            ans = iter->key;
            break;
        }
    }
    return ans;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。

- 空间复杂度：$O(n)$。哈希映射中包含最多 $\lfloor n/3 \rfloor + 1$ 个元素，即需要的空间为 $O(n)$。

#### 方法二：依次确定每一个二进制位

**思路与算法**

为了方便叙述，我们称「只出现了一次的元素」为「答案」。

由于数组中的元素都在 $\texttt{int}$（即 $32$ 位整数）范围内，因此我们可以依次计算答案的每一个二进制位是 $0$ 还是 $1$。

具体地，考虑答案的第 $i$ 个二进制位（$i$ 从 $0$ 开始编号），它可能为 $0$ 或 $1$。对于数组中非答案的元素，每一个元素都出现了 $3$ 次，对应着第 $i$ 个二进制位的 $3$ 个 $0$ 或 $3$ 个 $1$，无论是哪一种情况，它们的和都是 $3$ 的倍数（即和为 $0$ 或 $3$）。因此：

> 答案的第 $i$ 个二进制位就是数组中所有元素的第 $i$ 个二进制位之和除以 $3$ 的余数。

这样一来，对于数组中的每一个元素 $x$，我们使用位运算 $\texttt{(x >> i) \& 1}$ 得到 $x$ 的第 $i$ 个二进制位，并将它们相加再对 $3$ 取余，得到的结果一定为 $0$ 或 $1$，即为答案的第 $i$ 个二进制位。

**细节**

需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。这是因为「有符号整数类型」（即 $\texttt{int}$ 类型）的第 $31$ 个二进制位（即最高位）是补码意义下的符号位，对应着 $-2^{31}$，而「无符号整数类型」由于没有符号，第 $31$ 个二进制位对应着 $2^{31}$。因此在某些语言（例如 $\texttt{Python}$）中需要对最高位进行特殊判断。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
}
```

```Python [sol2-Python3]
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            total = sum((num >> i) & 1 for num in nums)
            if total % 3:
                # Python 这里对于最高位需要特殊判断
                if i == 31:
                    ans -= (1 << i)
                else:
                    ans |= (1 << i)
        return ans
```

```JavaScript [sol2-JavaScript]
var singleNumber = function(nums) {
    let ans = 0;
    for (let i = 0; i < 32; ++i) {
        let total = 0;
        for (const num of nums) {
            total += ((num >> i) & 1);
        }
        if (total % 3 != 0) {
            ans |= (1 << i);
        }
    }
    return ans;
};
```

```go [sol2-Golang]
func singleNumber(nums []int) int {
    ans := int32(0)
    for i := 0; i < 32; i++ {
        total := int32(0)
        for _, num := range nums {
            total += int32(num) >> i & 1
        }
        if total%3 > 0 {
            ans |= 1 << i
        }
    }
    return int(ans)
}
```

```C [sol2-C]
int singleNumber(int *nums, int numsSize) {
    int ans = 0;
    for (int i = 0; i < 32; ++i) {
        int total = 0;
        for (int j = 0; j < numsSize; ++j) {
            total += ((nums[j] >> i) & 1);
        }
        if (total % 3) {
            ans |= (1u << i);
        }
    }
    return ans;
}
```

**复杂度分析**

- 时间复杂度：$O(n \log C)$，其中 $n$ 是数组的长度，$C$ 是元素的数据范围，在本题中 $\log C=\log 2^{32} = 32$，也就是我们需要遍历第 $0\sim31$ 个二进制位。

- 空间复杂度：$O(1)$。

#### 方法三：数字电路设计

**说明**

方法三以及后续进行优化的方法四需要读者有一定的数字电路设计的基础。读者需要对以下知识：

- 简单的门电路（例如与门、异或门等）

- 给定数字电路输入和输出（真值表），使用门电路设计出一种满足要求的数字电路结构

有一定的了解。

**门电路表示**

我们将会用到四种门电路，使用的符号如下：

- 非门：我们用 $A'$ 表示输入为 $A$ 的非门的输出；

- 与门：我们用 $AB$ 表示输入为 $A$ 和 $B$ 的与门的输出。由于「与运算」具有结合律，因此如果同时用了多个与门（例如将 $A$ 和 $B$ 进行与运算后，再和 $C$ 进行与运算），我们可以将多个输入写在一起（例如 $ABC$）；

- 或门：我们用 $A+B$ 表示输入为 $A$ 和 $B$ 的或门的输出。同样地，多个或门可以写在一起（例如 $A+B+C$）；

- 异或门：我们用 $A\oplus B$ 表示输入为 $A$ 和 $B$ 的异或门的输出。同样的，多个异或门可以写在一起（例如 $A\oplus B\oplus C$）。

**思路与算法**

在方法二中，我们是依次处理每一个二进制位的，那么时间复杂度中就引入了 $O(\log C)$ 这一项。既然我们在对两个整数进行普通的二元运算时，都是将它们看成整体进行处理的，那么我们是否能以普通的二元运算为基础，同时处理所有的二进制位？

答案是可以的。我们可以使用一个「黑盒」存储当前遍历过的所有整数。「黑盒」的第 $i$ 位为 $\{ 0, 1, 2 \}$ 三者之一，表示当前遍历过的所有整数的第 $i$ 位之和除以 $3$ 的余数。但由于二进制表示中只有 $0$ 和 $1$ 而没有 $2$，因此我们可以考虑在「黑盒」中使用两个整数来进行存储，即：

> 黑盒中存储了两个整数 $a$ 和 $b$，且会有三种情况：
> - $a$ 的第 $i$ 位为 $0$ 且 $b$ 的第 $i$ 位为 $0$，表示 $0$；
> - $a$ 的第 $i$ 位为 $0$ 且 $b$ 的第 $i$ 位为 $1$，表示 $1$；
> - $a$ 的第 $i$ 位为 $1$ 且 $b$ 的第 $i$ 位为 $0$，表示 $2$。
>
> 为了方便叙述，我们用 $(00)$ 表示 $a$ 的第 $i$ 位为 $0$ 且 $b$ 的第 $i$ 位为 $0$，其余的情况类似。

当我们遍历到一个新的整数 $x$ 时，对于 $x$ 的第 $i$ 位 $x_i$，如果 $x_i=0$，那么 $a$ 和 $b$ 的第 $i$ 位不变；如果 $x_i=1$，那么 $a$ 和 $b$ 的第 $i$ 位按照 $(00)\to(01)\to(10)\to(00)$ 这一循环进行变化。因此我们可以得出下面的真值表：

| $(a_i ~ b_i)$ | $x_i$ | 新的 $(a_i ~ b_i)$ |
| :-: | :-: | :-: |
| $00$ | $0$ | $00$ |
| $00$ | $1$ | $01$ |
| $01$ | $0$ | $01$ |
| $01$ | $1$ | $10$ |
| $10$ | $0$ | $10$ |
| $10$ | $1$ | $00$ |

当我们考虑输出为 $a_i$ 时：

| $(a_i ~ b_i)$ | $x_i$ | 新的 $a_i$ |
| :-: | :-: | :-: |
| $00$ | $0$ | $0$ |
| $00$ | $1$ | $0$ |
| $01$ | $0$ | $0$ |
| $01$ | $1$ | $1$ |
| $10$ | $0$ | $1$ |
| $10$ | $1$ | $0$ |

根据真值表可以设计出电路：

$$
a_i = a_i'b_ix_i + a_ib_i'x_i'
$$

当我们考虑输出为 $b_i$ 时：

| $(a_i ~ b_i)$ | $x_i$ | 新的 $b_i$ |
| :-: | :-: | :-: |
| $00$ | $0$ | $0$ |
| $00$ | $1$ | $1$ |
| $01$ | $0$ | $1$ |
| $01$ | $1$ | $0$ |
| $10$ | $0$ | $0$ |
| $10$ | $1$ | $0$ |

根据真值表可以设计出电路：

$$
b_i = a_i'b_i'x_i + a_i'b_ix_i' = a_i'(b_i \oplus x_i)
$$

将上面的电路逻辑运算转换为等价的整数位运算，最终的转换规则即为：

$$
\begin{cases}
\texttt{a = (\textasciitilde a \& b \& x) | (a \& \textasciitilde b \& \textasciitilde x)} \\
\texttt{b = \textasciitilde a \& (b\^ x)}
\end{cases}
$$

其中 $\texttt{\textasciitilde, \&, |, \^ }$ 分别表示按位非、与、或、异或运算。

当我们遍历完数组中的所有元素后，$(a_i b_i)$ 要么是 $(00)$，表示答案的第 $i$ 位是 $0$；要么是 $(01)$，表示答案的第 $i$ 位是 $1$。因此我们只需要返回 $b$ 作为答案即可。

**细节**

由于电路中的 $a_i$ 和 $b_i$ 是「同时」得出结果的，因此我们在计算 $a$ 和 $b$ 时，需要使用临时变量暂存它们之前的值，再使用转换规则进行计算。

**代码**

```C++ [sol3-C++]
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a = 0, b = 0;
        for (int num: nums) {
            tie(a, b) = pair{(~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)};
        }
        return b;
    }
};
```

```Java [sol3-Java]
class Solution {
    public int singleNumber(int[] nums) {
        int a = 0, b = 0;
        for (int num : nums) {
            int aNext = (~a & b & num) | (a & ~b & ~num), bNext = ~a & (b ^ num);
            a = aNext;
            b = bNext;
        }
        return b;
    }
}
```

```Python [sol3-Python3]
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        a = b = 0
        for num in nums:
            a, b = (~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)
        return b
```

```JavaScript [sol3-JavaScript]
var singleNumber = function(nums) {
    let a = 0, b = 0;
    for (const num of nums) {
        const aNext = (~a & b & num) | (a & ~b & ~num), bNext = ~a & (b ^ num);
        a = aNext;
        b = bNext;
    }
    return b;
};
```

```go [sol3-Golang]
func singleNumber(nums []int) int {
    a, b := 0, 0
    for _, num := range nums {
        a, b = b&^a&num|a&^b&^num, (b^num)&^a
    }
    return b
}
```

```C [sol1-C]
int singleNumber(int *nums, int numsSize) {
    int a = 0, b = 0;
    for (int i = 0; i < numsSize; i++) {
        int tmp_a = (~a & b & nums[i]) | (a & ~b & ~nums[i]);
        int tmp_b = ~a & (b ^ nums[i]);
        a = tmp_a;
        b = tmp_b;
    }
    return b;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。

- 空间复杂度：$O(1)$。

#### 方法四：数字电路设计优化

**思路与算法**

我们发现方法三中计算 $b$ 的规则较为简单，而 $a$ 的规则较为麻烦，因此可以将「同时计算」改为「分别计算」，即先计算出 $b$，再拿新的 $b$ 值计算 $a$。

对于原始的真值表：

| $(a_i ~ b_i)$ | $x_i$ | 新的 $(a_i ~ b_i)$ |
| :-: | :-: | :-: |
| $00$ | $0$ | $00$ |
| $00$ | $1$ | $01$ |
| $01$ | $0$ | $01$ |
| $01$ | $1$ | $10$ |
| $10$ | $0$ | $10$ |
| $10$ | $1$ | $00$ |

我们将第一列的 $b_i$ 替换新的 $b_i$ 即可得到：

| $(a_i,$ 新的 $b_i)$ | $x_i$ | 新的 $a_i$ |
| :-: | :-: | :-: |
| $00$ | $0$ | $0$ |
| $01$ | $1$ | $0$ |
| $01$ | $0$ | $0$ |
| $00$ | $1$ | $1$ |
| $10$ | $0$ | $1$ |
| $10$ | $1$ | $0$ |

根据真值表可以设计出电路：

$$
a_i = a_i'b_i'x_i + a_ib_i'x_i' = b_i'(a_i \oplus x_i)
$$

这样就与 $b_i$ 的电路逻辑非常类似了。最终的转换规则即为：

$$
\begin{cases}
\texttt{b = \textasciitilde a \& (b\^ x)} \\
\texttt{a = \textasciitilde b \& (a\^ x)}
\end{cases}
$$

需要注意先计算 $b$，再计算 $a$。

**代码**

```C++ [sol4-C++]
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a = 0, b = 0;
        for (int num: nums) {
            b = ~a & (b ^ num);
            a = ~b & (a ^ num);
        }
        return b;
    }
};
```

```Java [sol4-Java]
class Solution {
    public int singleNumber(int[] nums) {
        int a = 0, b = 0;
        for (int num : nums) {
            b = ~a & (b ^ num);
            a = ~b & (a ^ num);
        }
        return b;
    }
}
```

```Python [sol4-Python3]
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        a = b = 0
        for num in nums:
            b = ~a & (b ^ num)
            a = ~b & (a ^ num)
        return b
```

```JavaScript [sol4-JavaScript]
var singleNumber = function(nums) {
    let a = 0, b = 0;
    for (const num of nums) {
        b = ~a & (b ^ num);
        a = ~b & (a ^ num);
    }
    return b;
};
```

```go [sol4-Golang]
func singleNumber(nums []int) int {
    a, b := 0, 0
    for _, num := range nums {
        b = (b ^ num) &^ a
        a = (a ^ num) &^ b
    }
    return b
}
```

```C [sol1-C]
int singleNumber(int *nums, int numsSize) {
    int a = 0, b = 0;
    for (int i = 0; i < numsSize; i++) {
        b = ~a & (b ^ nums[i]);
        a = ~b & (a ^ nums[i]);
    }
    return b;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。

- 空间复杂度：$O(1)$。