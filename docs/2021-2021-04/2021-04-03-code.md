# 2021年04月03日 code
<a href="https://toutiao.io/k/iyge3cy">史上最全教程：idea 将 Java 项目打包 Jar 包，并生成 exe 可执行文件</a><br /><a href="https://toutiao.io/k/de00pgg">Java 中的集合 List（入门篇）</a><br /><a href="https://toutiao.io/k/6jo6q1t">Go 应用优化指北</a><br /><a href="https://toutiao.io/k/0yy2iga">[译] Uber：面向领域的微服务架构</a><br /><a href="https://toutiao.io/k/ea28kfh">你该如何为 Kubernetes 定制特性</a><br /><a href="https://toutiao.io/k/oxjrbtj">程序员如何管理你的上级领导？</a><br /><a href="https://toutiao.io/k/55l066q">JVM 进阶之路（七）：垃圾收集器盘点</a><br /><a href="https://toutiao.io/k/scyqk7j">微服务时代组件化和服务化的抉择</a><br /><a href="https://toutiao.io/k/0hxavz1">你要偷偷学会排查线上 CPU 飙高的问题，然后惊艳所有人</a><br /><a href="https://toutiao.io/k/h0br9z2">如何用 Python 操作 Docker？</a><br /><a href="https://toutiao.io/k/vs0zegr">书单：互联网企业面试案头书之数据分析师篇</a><br /><a href="https://toutiao.io/k/pi52ruq">架构设计笔记（十二）：关键模式_读写分离</a><br /><a href="https://toutiao.io/k/w7axyzy">2021 年 Web 核心性能指标是什么？谷歌工程师告诉你，FMP 过时啦</a><br /><a href="https://toutiao.io/k/7up61zr">Clickhouse 平台无感搬迁 Zookeeper 实践</a><br /><a href="https://toutiao.io/k/ng18jyd">手撕 Go 面试官：Go 结构体是否可以比较，为什么？</a><br /><a href="https://toutiao.io/k/am1mh5y">[译] WebStorm 访谈：我们是如何构建 JavaScript IDE 的？</a><br /><a href="https://toutiao.io/k/zp6ph9o">为您的应用配置 Play Feature Delivery</a><br /><a href="https://toutiao.io/k/ab762mm">The small web is beautiful</a><br /><a href="https://toutiao.io/k/rxeztzb">iOS 中触摸事件的传递和响应分析</a><br /><a href="https://toutiao.io/k/sdvf5ne">CSS 灵感：一大堆优质 CSS Demo</a><br /><a href="https://toutiao.io/k/adg4qv6">[推荐] Redis 分布式锁遇到的序列化问题</a><br /><a href="https://toutiao.io/k/ny7vvdw">[推荐] 万字详解整个数据仓库建设体系</a><br /><a href="https://toutiao.io/k/47wemjf">[推荐] 超实用的 IDEA 插件推荐！百万级下载量</a><br /><a href="https://toutiao.io/k/sso4l2l">[推荐] 我在架构设计和代码开发中的一些常用原则</a><br /><a href="https://toutiao.io/k/f0361xm">[推荐] 高并发下如何保证接口的幂等性？</a><br /><a href="https://toutiao.io/k/ukg83qx">[推荐] 值得拥有的手绘风格画图工具</a><br /><a href="https://toutiao.io/k/v9aar7o">[推荐] 这 30 个我精选的含答案的面试题，硬不硬你说吧</a><br /><a href="https://toutiao.io/k/mvtejua">[推荐] 书单：互联网企业面试案头书之架构师篇</a><br /><a href="https://toutiao.io/k/2qkwu5f">[推荐] Spring Boot 中优雅的使用 Swagger 2（史上最全注解篇）</a><br /><a href="https://toutiao.io/k/nu45i3g">[推荐] 架构实践全景图</a><br /><a href="https://toutiao.io/k/vulmd0h">[推荐] 浅谈分库分表那些事儿</a><br /><a href="https://toutiao.io/k/cifpaoe">[推荐] 如何吃透一个 Java 项目？（附学习实践）</a><br /><hr /><a href="https://github.com/catchorg/Catch2">A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or C++03 on the Catch1.x branch)</a><br /><a href="https://github.com/johnBuffer/AntSimulator">Simple Ants simulator</a><br /><a href="https://github.com/btcpayserver/btcpayserver">Accept Bitcoin payments. Free, open-source & self-hosted, Bitcoin payment processor.</a><br /><a href="https://github.com/login?return_to=%2Ftrungk18%2Fangular-spotify">Spotify client built with Angular 11, Nx Workspace, ngrx, TailwindCSS and ng-zorro</a><br /><a href="https://github.com/microsoft/vscode">Visual Studio Code</a><br /><a href="https://github.com/Asabeneh/30-Days-Of-React">30 Days of React challenge is a step by step guide to learn React in 30 days. It requires HTML, CSS, and JavaScript knowledge. You should be comfortable with JavaScript before you start to React. If you are not comfortable with JavaScript check out 30DaysOfJavaScript. This is a continuation of 30 Days Of JS. This challenge may take up to 100 day…</a><br /><a href="https://github.com/ansible/ansible">Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems. https://docs.ansible.com.</a><br /><a href="https://github.com/envoyproxy/envoy">Cloud-native high-performance edge/middle/service proxy</a><br /><a href="https://github.com/wez/wezterm">A GPU-accelerated cross-platform terminal emulator and multiplexer written by @wez and implemented in Rust</a><br /><a href="https://github.com/pinterest/querybook">Querybook is a Big Data Querying UI, combining collocated table metadata and a simple notebook interface.</a><br /><a href="https://github.com/gto76/python-cheatsheet">Comprehensive Python Cheatsheet</a><br /><a href="https://github.com/ahmedbahaaeldin/From-0-to-Research-Scientist-resources-guide">Detailed and tailored guide for undergraduate students or anybody want to dig deep into the field of AI with solid foundation.</a><br /><a href="https://github.com/mytechnotalent/Reverse-Engineering">A FREE comprehensive reverse engineering course covering x86, x64, 32-bit ARM & 64-bit ARM architectures.</a><br /><a href="https://github.com/mrcodedev/frontend-developer-resources">Recursos gratuitos para empezar a ser un Frontend Developer o ampliar conocimientos</a><br /><a href="https://github.com/olmps/memo">Memo is an Anki mobile app written in Flutter</a><br /><a href="https://github.com/Lifka/hacking-resources">Hacking resources and cheat sheets. References, tools, scripts, tutorials, and other resources that help offensive and defensive security professionals.</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/facebookresearch/madgrad">MADGRAD Optimization Method</a><br /><a href="https://github.com/tonarino/innernet">A private network system that uses WireGuard under the hood.</a><br /><a href="https://github.com/pixeltris/TwitchAdSolutions"></a><br /><a href="https://github.com/OpenTTD/OpenTTD">OpenTTD is an open source simulation game based upon Transport Tycoon Deluxe</a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/microsoft/ProjectReunion">Project Reunion empowers all Windows apps (not just UWP/MSIX) with modern Windows UI, APIs, and platform features, including back-compat support, shipped via NuGet.</a><br /><a href="https://github.com/nicehash/NiceHashQuickMiner">Super simple & easy Windows 10 cryptocurrency miner made by NiceHash.</a><br /><a href="https://github.com/alibaba/COLA">🥤 COLA: Clean Object-oriented & Layered Architecture</a><br /><hr />最长公共子序列<br /><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>

<p>一个字符串的 <strong>子序列</strong><em> </em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>

<ul>
	<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>

<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>text1 = "abcde", text2 = "ace" 
<strong>输出：</strong>3  
<strong>解释：</strong>最长公共子序列是 "ace" ，它的长度为 3 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>text1 = "abc", text2 = "abc"
<strong>输出：</strong>3
<strong>解释：</strong>最长公共子序列是 "abc" ，它的长度为 3 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>text1 = "abc", text2 = "def"
<strong>输出：</strong>0
<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= text1.length, text2.length <= 1000</code></li>
	<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<br />#### 方法一：动态规划

最长公共子序列问题是典型的二维动态规划问题。

假设字符串 $\textit{text}_1$ 和 $\textit{text}_2$ 的长度分别为 $m$ 和 $n$，创建 $m+1$ 行 $n+1$ 列的二维数组 $\textit{dp}$，其中 $\textit{dp}[i][j]$ 表示 $\textit{text}_1[0:i]$ 和 $\textit{text}_2[0:j]$ 的最长公共子序列的长度。

> 上述表示中，$\textit{text}_1[0:i]$ 表示 $\textit{text}_1$ 的长度为 $i$ 的前缀，$\textit{text}_2[0:j]$ 表示 $\textit{text}_2$ 的长度为 $j$ 的前缀。

考虑动态规划的边界情况：

- 当 $i=0$ 时，$\textit{text}_1[0:i]$ 为空，空字符串和任何字符串的最长公共子序列的长度都是 $0$，因此对任意 $0 \le j \le n$，有 $\textit{dp}[0][j]=0$；

- 当 $j=0$ 时，$\textit{text}_2[0:j]$ 为空，同理可得，对任意 $0 \le i \le m$，有 $\textit{dp}[i][0]=0$。

因此动态规划的边界情况是：当 $i=0$ 或 $j=0$ 时，$\textit{dp}[i][j]=0$。

当 $i>0$ 且 $j>0$ 时，考虑 $\textit{dp}[i][j]$ 的计算：

- 当 $\textit{text}_1[i-1]=\textit{text}_2[j-1]$ 时，将这两个相同的字符称为公共字符，考虑 $\textit{text}_1[0:i-1]$ 和 $\textit{text}_2[0:j-1]$ 的最长公共子序列，再增加一个字符（即公共字符）即可得到 $\textit{text}_1[0:i]$ 和 $\textit{text}_2[0:j]$ 的最长公共子序列，因此 $\textit{dp}[i][j]=\textit{dp}[i-1][j-1]+1$。

- 当 $\textit{text}_1[i-1] \ne \textit{text}_2[j-1]$ 时，考虑以下两项：

   - $\textit{text}_1[0:i-1]$ 和 $\textit{text}_2[0:j]$ 的最长公共子序列；

   - $\textit{text}_1[0:i]$ 和 $\textit{text}_2[0:j-1]$ 的最长公共子序列。

   要得到 $\textit{text}_1[0:i]$ 和 $\textit{text}_2[0:j]$ 的最长公共子序列，应取两项中的长度较大的一项，因此 $\textit{dp}[i][j]=\max(\textit{dp}[i-1][j],\textit{dp}[i][j-1])$。

由此可以得到如下状态转移方程：

$$
\textit{dp}[i][j] = \begin{cases}
\textit{dp}[i-1][j-1]+1, & \textit{text}_1[i]=\textit{text}_2[j] \\
\max(\textit{dp}[i-1][j],\textit{dp}[i][j-1]), & \textit{text}_1[i] \ne \textit{text}_2[j]
\end{cases}
$$

最终计算得到 $\textit{dp}[m][n]$ 即为 $\textit{text}_1$ 和 $\textit{text}_2$ 的最长公共子序列的长度。

![fig1](https://assets.leetcode-cn.com/solution-static/1143/1.png){:width="85%"}

```Java [sol1-Java]
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

```JavaScript [sol1-JavaScript]
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 1; i <= m; i++) {
        const c1 = text1[i - 1];
        for (let j = 1; j <= n; j++) {
            const c2 = text2[j - 1];
            if (c1 === c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```

```go [sol1-Golang]
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i, c1 := range text1 {
        for j, c2 := range text2 {
            if c1 == c2 {
                dp[i+1][j+1] = dp[i][j] + 1
            } else {
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```Python [sol1-Python3]
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[m][n]
```

```C++ [sol1-C++]
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length(), n = text2.length();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; i++) {
            char c1 = text1.at(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.at(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};
```

```C [sol1-C]
int longestCommonSubsequence(char* text1, char* text2) {
    int m = strlen(text1), n = strlen(text2);
    int dp[m + 1][n + 1];
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= m; i++) {
        char c1 = text1[i - 1];
        for (int j = 1; j <= n; j++) {
            char c2 = text2[j - 1];
            if (c1 == c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = fmax(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

**复杂度分析**

- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是字符串 $\textit{text}_1$ 和 $\textit{text}_2$ 的长度。二维数组 $\textit{dp}$ 有 $m+1$ 行和 $n+1$ 列，需要对 $\textit{dp}$ 中的每个元素进行计算。

- 空间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是字符串 $\textit{text}_1$ 和 $\textit{text}_2$ 的长度。创建了 $m+1$ 行 $n+1$ 列的二维数组 $\textit{dp}$。