# 2021年04月27日 code
<a href="https://toutiao.io/k/b2sfp14">Rust 开源：24 个绝佳框架、项目及资料库</a><br /><a href="https://toutiao.io/k/ye8mh35">使用 Go defer 要小心这 2 个雷区</a><br /><a href="https://toutiao.io/k/otmhhst">面试官：两个 nil 比较结果是什么？</a><br /><a href="https://toutiao.io/k/0pi916j">源码解析 GitHub 上 14.1k Star 的 RocketMQ</a><br /><a href="https://toutiao.io/k/6nlq54b">广告行业中那些趣事系列 (32)：美团搜索 NER 技术实践学习笔记</a><br /><a href="https://toutiao.io/k/r4thw3m">[译] 工作六年后，对软件开发的一些新观点</a><br /><a href="https://toutiao.io/k/nn3a1b3">来一起用 Vue3 做个飞机大战游戏（附源码）</a><br /><a href="https://toutiao.io/k/r1qlgmu">初识同态加密</a><br /><a href="https://toutiao.io/k/yn5394d">Go 和 Rust 设计模式对比：工厂模式</a><br /><a href="https://toutiao.io/k/4d6i5td">Redis 破障之路（二）：Redis 安装和基本数据结构</a><br /><a href="https://toutiao.io/k/tykh0r4">赢机酒！直飞北京现场参加 ServerlessDays</a><br /><a href="https://toutiao.io/k/x79dp8v">让中后台产品跑的更快更远</a><br /><a href="https://toutiao.io/k/shj3w7p">Netty 源码解析：PoolSubpage 实现原理</a><br /><a href="https://toutiao.io/k/qkyb30l">通用性接口健壮性扫描方案</a><br /><a href="https://toutiao.io/k/1pyaf9q">AI 入行那些事儿（十一）：人工智能浪潮中的企业与人才</a><br /><a href="https://toutiao.io/k/bwuutcy">Docker 实战：MySQL 操作</a><br /><a href="https://toutiao.io/k/t80elrv">自然语言处理中数据增强 (Data Augmentation) 技术最全盘点</a><br /><a href="https://toutiao.io/k/6asie8q">Reverse Shell 杂谈</a><br /><a href="https://toutiao.io/k/w3q1ccp">OWASP 十大网站安全风险 （三）：敏感信息泄漏</a><br /><a href="https://toutiao.io/k/4xjacbn">这一次，彻底搞懂 Go Cond</a><br /><a href="https://toutiao.io/k/zxa65u1">[推荐] 超级详细的 Spring Boot 注解总结</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/4zqz7k1">[推荐] RESTful API 设计最佳实践</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><a href="https://toutiao.io/k/82eogba">[推荐] Git 分支管理策略与工作流程</a><br /><a href="https://toutiao.io/k/zpo0xd7">[推荐] 职场：工作五年之后，对技术和业务的思考</a><br /><a href="https://toutiao.io/k/omkb9gy">[推荐] InnoDB 解决幻读的方案：LBCC & MVCC</a><br /><a href="https://toutiao.io/k/z5c0vp0">[推荐] 谈谈 MySQL 锁</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><a href="https://toutiao.io/k/811or1j">[推荐] 学会这 10 种定时任务，我有点飘了</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/syxnrph">[推荐] OpenResty 实现限流</a><br /><hr /><a href="https://github.com/microsoft/wslg">Enabling the Windows Subsystem for Linux to include support for Wayland and X server related scenarios</a><br /><a href="https://github.com/chrisleekr/binance-trading-bot">Automated Binance trading bot - Buy low/Sell high with stop loss limit/Trade multiple cryptocurrencies</a><br /><a href="https://github.com/login?return_to=%2Fphotoprism%2Fphotoprism">Personal Photo Management powered by Go and Google TensorFlow</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/jackfrued/Python-100-Days">Python - 100天从新手到大师</a><br /><a href="https://github.com/chefyuan/algorithm-base">专门为刚开始刷题的同学准备的算法基地，没有最细只有更细，立志用动画将晦涩难懂的算法说的通俗易懂！</a><br /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/ornicar/lila">♞ lichess.org: the forever free, adless and open source chess server ♞</a><br /><a href="https://github.com/login?return_to=%2Fkamranahmedse%2Fdeveloper-roadmap">Roadmap to becoming a web developer in 2021</a><br /><a href="https://github.com/v2fly/v2ray-core">A platform for building proxies to bypass network restrictions.</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/danistefanovic/build-your-own-x">🤓 Build your own (insert technology here)</a><br /><a href="https://github.com/josepholiveira/podcastr">A platform built for podcast broadcasting. Developed during @Rocketseat NLW#05 free training.</a><br /><a href="https://github.com/ml-tooling/opyrator">🪄 Turns your machine learning code into microservices with web API, interactive GUI, and more.</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/bmorelli25/Become-A-Full-Stack-Web-Developer">Free resources for learning Full Stack Web Development</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/Emadabdelhamied/Eng-Mohamed-Hammad-Posts"></a><br /><a href="https://github.com/bradtraversy/design-resources-for-developers">Curated list of design and UI resources from stock photos, web templates, CSS frameworks, UI libraries, tools and much more</a><br /><a href="https://github.com/DidierRLopes/GamestonkTerminal">The next best thing after Bloomberg Terminal</a><br /><a href="https://github.com/RH12503/triangula">Generate high-quality triangulated art from images.</a><br /><a href="https://github.com/you-dont-need/You-Dont-Need-JavaScript">CSS is powerful, you can do a lot of things without JS.</a><br /><a href="https://github.com/aladinyo/WhatsappyApp">A whatsapp clone progressive web application built with react nodejs and firebase</a><br /><hr />二叉搜索树的范围和<br /><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" style="width: 400px; height: 222px;" />
<pre>
<strong>输入：</strong>root = [10,5,15,3,7,null,18], low = 7, high = 15
<strong>输出：</strong>32
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" style="width: 400px; height: 335px;" />
<pre>
<strong>输入：</strong>root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
<strong>输出：</strong>23
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>树中节点数目在范围 <code>[1, 2 * 10<sup>4</sup>]</code> 内</li>
	<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>
	<li><code>1 <= low <= high <= 10<sup>5</sup></code></li>
	<li>所有 <code>Node.val</code> <strong>互不相同</strong></li>
</ul>
<br />#### 方法一：深度优先搜索

**思路**

按深度优先搜索的顺序计算范围和。记当前子树根节点为 $\textit{root}$，分以下四种情况讨论：

1. $\textit{root}$ 节点为空

   返回 $0$。

2. $\textit{root}$ 节点的值大于 $\textit{high}$

   由于二叉搜索树右子树上所有节点的值均大于根节点的值，即均大于 $\textit{high}$，故无需考虑右子树，返回左子树的范围和。

3. $\textit{root}$ 节点的值小于 $\textit{low}$

   由于二叉搜索树左子树上所有节点的值均小于根节点的值，即均小于 $\textit{low}$，故无需考虑左子树，返回右子树的范围和。

4. $\textit{root}$ 节点的值在 $[\textit{low},\textit{high}]$ 范围内

   此时应返回 $\textit{root}$ 节点的值、左子树的范围和、右子树的范围和这三者之和。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int rangeSumBST(TreeNode *root, int low, int high) {
        if (root == nullptr) {
            return 0;
        }
        if (root->val > high) {
            return rangeSumBST(root->left, low, high);
        }
        if (root->val < low) {
            return rangeSumBST(root->right, low, high);
        }
        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
    }
};
```

```Java [sol1-Java]
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if (root == null) {
            return 0;
        }
        if (root.val > high) {
            return rangeSumBST(root.left, low, high);
        }
        if (root.val < low) {
            return rangeSumBST(root.right, low, high);
        }
        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    }
}
```

```go [sol1-Golang]
func rangeSumBST(root *TreeNode, low, high int) int {
    if root == nil {
        return 0
    }
    if root.Val > high {
        return rangeSumBST(root.Left, low, high)
    }
    if root.Val < low {
        return rangeSumBST(root.Right, low, high)
    }
    return root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)
}
```

```JavaScript [sol1-JavaScript]
var rangeSumBST = function(root, low, high) {
    if (!root) {
        return 0;
    }
    if (root.val > high) {
        return rangeSumBST(root.left, low, high);
    }
    if (root.val < low) {
        return rangeSumBST(root.right, low, high);
    }
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
};
```

```Python [sol1-Python3]
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        if not root:
            return 0
        if root.val > high:
            return self.rangeSumBST(root.left, low, high)
        if root.val < low:
            return self.rangeSumBST(root.right, low, high)
        return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)
```

```C [sol1-C]
int rangeSumBST(struct TreeNode *root, int low, int high) {
    if (root == NULL) {
        return 0;
    }
    if (root->val > high) {
        return rangeSumBST(root->left, low, high);
    }
    if (root->val < low) {
        return rangeSumBST(root->right, low, high);
    }
    return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。

- 空间复杂度：$O(n)$。空间复杂度主要取决于栈空间的开销。

#### 方法二：广度优先搜索

**思路**

使用广度优先搜索的方法，用一个队列 $q$ 存储需要计算的节点。每次取出队首节点时，若节点为空则跳过该节点，否则按方法一中给出的大小关系来决定加入队列的子节点。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    int rangeSumBST(TreeNode *root, int low, int high) {
        int sum = 0;
        queue<TreeNode*> q({root});
        while (!q.empty()) {
            auto node = q.front();
            q.pop();
            if (node == nullptr) {
                continue;
            }
            if (node->val > high) {
                q.push(node->left);
            } else if (node->val < low) {
                q.push(node->right);
            } else {
                sum += node->val;
                q.push(node->left);
                q.push(node->right);
            }
        }
        return sum;
    }
};
```

```Java [sol2-Java]
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        int sum = 0;
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(root);
        while (!q.isEmpty()) {
            TreeNode node = q.poll();
            if (node == null) {
                continue;
            }
            if (node.val > high) {
                q.offer(node.left);
            } else if (node.val < low) {
                q.offer(node.right);
            } else {
                sum += node.val;
                q.offer(node.left);
                q.offer(node.right);
            }
        }
        return sum;
    }
}
```

```go [sol2-Golang]
func rangeSumBST(root *TreeNode, low, high int) (sum int) {
    q := []*TreeNode{root}
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        if node == nil {
            continue
        }
        if node.Val > high {
            q = append(q, node.Left)
        } else if node.Val < low {
            q = append(q, node.Right)
        } else {
            sum += node.Val
            q = append(q, node.Left, node.Right)
        }
    }
    return
}
```

```JavaScript [sol2-JavaScript]
var rangeSumBST = function(root, low, high) {
    let sum = 0;
    const q = [root];
    while (q.length) {
        const node = q.shift();
        if (!node) {
            continue;
        }
        if (node.val > high) {
            q.push(node.left);
        } else if (node.val < low) {
            q.push(node.right);
        } else {
            sum += node.val;
            q.push(node.left);
            q.push(node.right);
        }
    }
    return sum;
};
```

```Python [sol2-Python3]
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        total = 0
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if not node:
                continue
            if node.val > high:
                q.append(node.left)
            elif node.val < low:
                q.append(node.right)
            else:
                total += node.val
                q.append(node.left)
                q.append(node.right)

        return total
```

```C [sol2-C]
int rangeSumBST(struct TreeNode *root, int low, int high) {
    int sum = 0;
    struct TreeNode *q[40000];
    int left = 0, right = 0;
    q[right++] = root;
    while (left < right) {
        struct TreeNode *node = q[left++];
        if (node == NULL) {
            continue;
        }
        if (node->val > high) {
            q[right++] = node->left;
        } else if (node->val < low) {
            q[right++] = node->right;
        } else {
            sum += node->val;
            q[right++] = node->left;
            q[right++] = node->right;
        }
    }
    return sum;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是二叉搜索树的节点数。

- 空间复杂度：$O(n)$。空间复杂度主要取决于队列的空间。