# 2021年06月04日 code
<a href="https://toutiao.io/k/msg8jaf">2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你</a><br /><a href="https://toutiao.io/k/6tcdyp9">Spring Boot 在 K8s 下实现优雅停机</a><br /><a href="https://toutiao.io/k/do1s28r">读写锁为什么那么快?（二）</a><br /><a href="https://toutiao.io/k/1w6pqdc">源码解析：K8s 创建 pod 时，背后发生了什么（五）（2021）</a><br /><a href="https://toutiao.io/k/et43dwl">分布式链路跟踪中的 traceid 和 spanid 代表什么？</a><br /><a href="https://toutiao.io/k/rf5urv9">手把手教你刷搜索</a><br /><a href="https://toutiao.io/k/8lt4hm3">Java 并发编程专题系列之从源码分析 Mutex 锁的运行原理</a><br /><a href="https://toutiao.io/k/l7j9cmb">Mybatis-Plus 的应用场景及注入 SQL 原理分析</a><br /><a href="https://toutiao.io/k/ae4scnq">Go 语言如何实现可重入锁？</a><br /><a href="https://toutiao.io/k/2jdamkc">Android 之 Java 的 GC 垃圾回收机制详解：层层分析步步深入</a><br /><a href="https://toutiao.io/k/omu95pl">Kubernetes 笔记（一）：系统概述</a><br /><a href="https://toutiao.io/k/exgxuoy">Presto 动态过滤 (dynamic filtering) 原理与应用</a><br /><a href="https://toutiao.io/k/d8c62pc">为什么说混合云是新基建的流行架构？</a><br /><a href="https://toutiao.io/k/e0aawhc">现代 C++：新的字符串格式化方法</a><br /><a href="https://toutiao.io/k/h40uv9z">Coobox 之 LastWinExecutor，后来居上执行器</a><br /><a href="https://toutiao.io/k/j6zwgop">解决甩锅的一大难题，就是留个凭证</a><br /><a href="https://toutiao.io/k/gi8u7pt">[译] 深入 LINQ：揭开 IQueryable 的面纱</a><br /><a href="https://toutiao.io/k/g04fcq3">漫画：IT 大牛是怎样炼成的？</a><br /><a href="https://toutiao.io/k/lixfwt6">细节满满！理解对比学习和 SimCSE，就看这 6 个知识点</a><br /><a href="https://toutiao.io/k/4gnbjiy">第七届 NJSD 全球软件大会正式开放报名 | 6.22-6.23 中国.南京</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/osge9c2">[推荐] 这款远程桌面软件开源了</a><br /><a href="https://toutiao.io/k/5u1byn9">[推荐] 各厂三年 Go 面经，已入字节</a><br /><a href="https://toutiao.io/k/ep5e8sd">[推荐] 亿级系统的 Redis 缓存如何设计？</a><br /><a href="https://toutiao.io/k/q62fiq2">[推荐] 如闪电划破雨夜，这些开源项目瞬间点亮了命令行</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/t1o49fm">[推荐] 企业微信万亿级日志检索系统</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/lq1k5bp">[推荐] [译] 您不想错过的 IntelliJ IDEA 十大插件</a><br /><a href="https://toutiao.io/k/5za3e5u">[推荐] Golang 内存管理分析</a><br /><a href="https://toutiao.io/k/ngx4og0">[推荐] “三次握手，四次挥手” 这么讲，保证你忘不了</a><br /><a href="https://toutiao.io/k/ybiw04u">[推荐] 高并发、高性能、高可用系统设计经验</a><br /><a href="https://toutiao.io/k/18gz8ap">[推荐] 百亿规模 API 网关服务 Shepherd 的设计与实现</a><br /><hr /><a href="https://github.com/black7375/Firefox-UI-Fix">🦊 I respect proton UI and aim to improve it.</a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/TheAlgorithms/Java">All Algorithms implemented in Java</a><br /><a href="https://github.com/Azure/bicep">Bicep is a declarative language for describing and deploying Azure resources</a><br /><a href="https://github.com/koreader/koreader">An ebook reader application supporting PDF, DjVu, EPUB, FB2 and many more formats, running on Cervantes, Kindle, Kobo, PocketBook and Android devices</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/chinnkarahoi/jd_scripts">lxk0301/jd_scripts备份。不要star。不要fork。谢谢配合。</a><br /><a href="https://github.com/helix-editor/helix">A post-modern modal text editor.</a><br /><a href="https://github.com/obsproject/obs-studio">OBS Studio - Free and open source software for live streaming and screen recording</a><br /><a href="https://github.com/Rikj000/MoniGoMani">Isn't that what we all want? Our money to go many? Well that's what this strategy hopes to do for you! By giving you/HyperOpt a lot of signals to alter the weight from.</a><br /><a href="https://github.com/Awesome-HarmonyOS/HarmonyOS">A curated list of awesome things related to HarmonyOS. 华为鸿蒙操作系统。</a><br /><a href="https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot">This is a fully functioning Binance trading bot that measures the volatility of every coin on Binance and places trades with the highest gaining coins If you like this project consider donating though the Brave browser to allow me to continuously improve the script.</a><br /><a href="https://github.com/login?return_to=%2Fdeepfakes%2Ffaceswap">Deepfakes Software For All</a><br /><a href="https://github.com/files-community/Files">A modern file explorer that pushes the boundaries of the platform.</a><br /><a href="https://github.com/megaease/easegress">An all-rounder traffic orchestration system</a><br /><a href="https://github.com/pmndrs/racing-game">🏎 Open source racing game developed by everyone willing</a><br /><a href="https://github.com/ChristianChiarulli/LunarVim">A Neovim config made with sane defaults</a><br /><a href="https://github.com/CyC2018/CS-Notes">📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/fsnotify/fsnotify">Cross-platform file system notifications for Go.</a><br /><a href="https://github.com/login?return_to=%2Flaurent22%2Fjoplin">Joplin - an open source note taking and to-do application with synchronization capabilities for Windows, macOS, Linux, Android and iOS. Forum: https://discourse.joplinapp.org/</a><br /><a href="https://github.com/googleapis/googleapis">Public interface definitions of Google APIs.</a><br /><a href="https://github.com/prisma/prisma">Next-generation ORM for Node.js & TypeScript | PostgreSQL, MySQL, MariaDB, SQL Server & SQLite</a><br /><a href="https://github.com/Snailclimb/JavaGuide">「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！</a><br /><a href="https://github.com/roseduan/rosedb">A simple k-v database in pure Golang, supports string, list, hash, set, sorted set. Go 语言实现的 k-v 数据库项目，简洁易懂，适合新手进阶，欢迎 Pr！</a><br /><hr />相交链表<br /><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>

<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>

<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" style="height: 130px; width: 400px;" /></a></p>

<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>

<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" style="height: 130px; width: 400px;" /></a></p>

<pre>
<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
<strong>输出：</strong>Intersected at '8'
<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</pre>

<p><strong>示例 2：</strong></p>

<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" style="height: 136px; width: 350px;" /></a></p>

<pre>
<strong>输入：</strong>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>输出：</strong>Intersected at '2'
<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</pre>

<p><strong>示例 3：</strong></p>

<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank"><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" style="height: 126px; width: 200px;" /></a></p>

<pre>
<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>输出：</strong>null
<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>listA</code> 中节点数目为 <code>m</code></li>
	<li><code>listB</code> 中节点数目为 <code>n</code></li>
	<li><code>0 <= m, n <= 3 * 10<sup>4</sup></code></li>
	<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>
	<li><code>0 <= skipA <= m</code></li>
	<li><code>0 <= skipB <= n</code></li>
	<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
	<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>
</ul>

<p> </p>

<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<br />#### 方法一：哈希集合

**思路和算法**

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表 $\textit{headA}$，并将链表 $\textit{headA}$ 中的每个节点加入哈希集合中。然后遍历链表 $\textit{headB}$，对于遍历到的每个节点，判断该节点是否在哈希集合中：

- 如果当前节点不在哈希集合中，则继续遍历下一个节点；

- 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 $\textit{headB}$ 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。

如果链表 $\textit{headB}$ 中的所有节点都不在哈希集合中，则两个链表不相交，返回 $\text{null}$。

**代码**

```Java [sol1-Java]
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> visited = new HashSet<ListNode>();
        ListNode temp = headA;
        while (temp != null) {
            visited.add(temp);
            temp = temp.next;
        }
        temp = headB;
        while (temp != null) {
            if (visited.contains(temp)) {
                return temp;
            }
            temp = temp.next;
        }
        return null;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {
        ISet<ListNode> visited = new HashSet<ListNode>();
        ListNode temp = headA;
        while (temp != null) {
            visited.Add(temp);
            temp = temp.next;
        }
        temp = headB;
        while (temp != null) {
            if (visited.Contains(temp)) {
                return temp;
            }
            temp = temp.next;
        }
        return null;
    }
}
```

```JavaScript [sol1-JavaScript]
var getIntersectionNode = function(headA, headB) {
    const visited = new Set();
    let temp = headA;
    while (temp !== null) {
        visited.add(temp);
        temp = temp.next;
    }
    temp = headB;
    while (temp !== null) {
        if (visited.has(temp)) {
            return temp;
        }
        temp = temp.next;
    }
    return null;
};
```

```go [sol1-Golang]
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    vis := map[*ListNode]bool{}
    for tmp := headA; tmp != nil; tmp = tmp.Next {
        vis[tmp] = true
    }
    for tmp := headB; tmp != nil; tmp = tmp.Next {
        if vis[tmp] {
            return tmp
        }
    }
    return nil
}
```

```C++ [sol1-C++]
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode *> visited;
        ListNode *temp = headA;
        while (temp != nullptr) {
            visited.insert(temp);
            temp = temp->next;
        }
        temp = headB;
        while (temp != nullptr) {
            if (visited.count(temp)) {
                return temp;
            }
            temp = temp->next;
        }
        return nullptr;
    }
};
```

```C [sol1-C]
struct HashTable {
    struct ListNode *key;
    UT_hash_handle hh;
};

struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct HashTable *hashTable = NULL;
    struct ListNode *temp = headA;
    while (temp != NULL) {
        struct HashTable *tmp;
        HASH_FIND(hh, hashTable, &temp, sizeof(struct HashTable *), tmp);
        if (tmp == NULL) {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = temp;
            HASH_ADD(hh, hashTable, key, sizeof(struct HashTable *), tmp);
        }
        temp = temp->next;
    }
    temp = headB;
    while (temp != NULL) {
        struct HashTable *tmp;
        HASH_FIND(hh, hashTable, &temp, sizeof(struct HashTable *), tmp);
        if (tmp != NULL) {
            return temp;
        }
        temp = temp->next;
    }
    return NULL;
}
```

**复杂度分析**

- 时间复杂度：$O(m+n)$，其中 $m$ 和 $n$ 是分别是链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度。需要遍历两个链表各一次。

- 空间复杂度：$O(m)$，其中 $m$ 是链表 $\textit{headA}$ 的长度。需要使用哈希集合存储链表 $\textit{headA}$ 中的全部节点。

#### 方法二：双指针

**思路和算法**

使用双指针的方法，可以将空间复杂度降至 $O(1)$。

只有当链表 $\textit{headA}$ 和 $\textit{headB}$ 都不为空时，两个链表才可能相交。因此首先判断链表 $\textit{headA}$ 和 $\textit{headB}$ 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 $\text{null}$。

当链表 $\textit{headA}$ 和 $\textit{headB}$ 都不为空时，创建两个指针 $\textit{pA}$ 和 $\textit{pB}$，初始时分别指向两个链表的头节点 $\textit{headA}$ 和 $\textit{headB}$，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

- 每步操作需要同时更新指针 $\textit{pA}$ 和 $\textit{pB}$；

- 如果指针 $\textit{pA}$ 不为空，则将指针 $\textit{pA}$ 移到下一个节点；如果指针 $\textit{pB}$ 不为空，则将指针 $\textit{pB}$ 移到下一个节点。

- 如果指针 $\textit{pA}$ 为空，则将指针 $\textit{pA}$ 移到链表 $\textit{headB}$ 的头节点；如果指针 $\textit{pB}$ 为空，则将指针 $\textit{pB}$ 移到链表 $\textit{headA}$ 的头节点。

- 当指针 $\textit{pA}$ 和 $\textit{pB}$ 指向同一个节点或者都为空时，返回它们指向的节点或者 $\text{null}$。

**证明**

下面提供双指针方法的正确性证明。考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。

情况一：两个链表相交

链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度分别是 $m$ 和 $n$。假设链表 $\textit{headA}$ 的不相交部分有 $a$ 个节点，链表 $\textit{headB}$ 的不相交部分有 $b$ 个节点，两个链表相交的部分有 $c$ 个节点，则有 $a+c=m$，$b+c=n$。

- 如果 $a=b$，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；

- 如果 $a \ne b$，则指针 $\textit{pA}$ 会遍历完链表 $\textit{headA}$，指针 $\textit{pB}$ 会遍历完链表 $\textit{headB}$，两个指针不会同时到达链表的尾节点，然后指针 $\textit{pA}$ 移到链表 $\textit{headB}$ 的头节点，指针 $\textit{pB}$ 移到链表 $\textit{headA}$ 的头节点，然后两个指针继续移动，在指针 $\textit{pA}$ 移动了 $a+c+b$ 次、指针 $\textit{pB}$ 移动了 $b+c+a$ 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。

情况二：两个链表不相交

链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度分别是 $m$ 和 $n$。考虑当 $m=n$ 和 $m \ne n$ 时，两个指针分别会如何移动：

- 如果 $m=n$，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 $\text{null}$，此时返回 $\text{null}$；

- 如果 $m \ne n$，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 $\textit{pA}$ 移动了 $m+n$ 次、指针 $\textit{pB}$ 移动了 $n+m$ 次之后，两个指针会同时变成空值 $\text{null}$，此时返回 $\text{null}$。

**代码**

```Java [sol2-Java]
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

```JavaScript [sol2-JavaScript]
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) {
        return null;
    }
    let pA = headA, pB = headB;
    while (pA !== pB) {
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }
    return pA;
};
```

```go [sol2-Golang]
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    pa, pb := headA, headB
    for pa != pb {
        if pa == nil {
            pa = headB
        } else {
            pa = pa.Next
        }
        if pb == nil {
            pb = headA
        } else {
            pb = pb.Next
        }
    }
    return pa
}
```

```C++ [sol2-C++]
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        ListNode *pA = headA, *pB = headB;
        while (pA != pB) {
            pA = pA == nullptr ? headB : pA->next;
            pB = pB == nullptr ? headA : pB->next;
        }
        return pA;
    }
};
```

```C [sol1-C]

```

**复杂度分析**

- 时间复杂度：$O(m+n)$，其中 $m$ 和 $n$ 是分别是链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。

- 空间复杂度：$O(1)$。