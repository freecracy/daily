# 2021年06月18日 code
<a href="https://toutiao.io/k/77iozz6">跟 Kafka 学技术系列之时间轮</a><br /><a href="https://toutiao.io/k/ow2rhiz">[推荐] Linux 调度系统全景指南（终结篇）</a><br /><a href="https://toutiao.io/k/3xscqep">[推荐] 一文理解 Java 中的 SPI 机制</a><br /><a href="https://toutiao.io/k/2rcud9q">[推荐] Redis 存储对象信息是用 Hash 还是 String</a><br /><a href="https://toutiao.io/k/85kvlje">[推荐] 面试题：MySQL 一棵 B+ 树能存多少条数据？</a><br /><a href="https://toutiao.io/k/a7bxrhs">[推荐] 有赞 TCP 网络编程最佳实践</a><br /><a href="https://toutiao.io/k/a3gplbq">[推荐] 一文理解 Redis 底层数据结构</a><br /><a href="https://toutiao.io/k/mr1knwm">[推荐] 微服务拆分之道</a><br /><a href="https://toutiao.io/k/xjnx4kp">[推荐] 杭州某大厂：MySQL 连环问</a><br /><a href="https://toutiao.io/k/qnyxbs9">[推荐] 惊！这个 Go 开源项目号称「不改一行代码做秒杀」</a><br /><a href="https://toutiao.io/k/kkc4ght">[推荐] 利用 Kubernetes 搭建便携式开发环境之 MySQL 和 Redis</a><br /><a href="https://toutiao.io/k/b9vlrcu">[推荐] 网络连接存在大量 time_wait 和 close_wait 的原因以及解决方法</a><br /><hr /><a href="https://github.com/nushell/nushell">A new type of shell</a><br /><a href="https://github.com/thanos-io/thanos">Highly available Prometheus setup with long term storage capabilities. A CNCF Incubating project.</a><br /><a href="https://github.com/keras-team/keras">Deep Learning for humans</a><br /><a href="https://github.com/vercel/next.js">The React Framework</a><br /><a href="https://github.com/chromium/chromium">The official GitHub mirror of the Chromium source</a><br /><a href="https://github.com/google/fully-homomorphic-encryption">Libraries and tools to perform fully homomorphic encryption operations on an encrypted data set.</a><br /><a href="https://github.com/AkashSingh3031/The-Complete-FAANG-Preparation">This repository contains all the DSA (Data-Structures, Algorithms, 450 DSA by Love Babbar Bhaiya, FAANG Questions), Technical Subjects (OS + DBMS + SQL + CN + OOPs) Theory+Questions, FAANG Interview questions, and Miscellaneous Stuff (Programming MCQs, Puzzles, Aptitude, Reasoning). The Programming languages used for demonstration are C++, Pytho…</a><br /><a href="https://github.com/programthink/books">【编程随想】收藏的电子书清单（多个学科，含下载链接）</a><br /><a href="https://github.com/vxunderground/MalwareSourceCode">Collection of malware source code for a variety of platforms in an array of different programming languages.</a><br /><a href="https://github.com/monyhar/monyhar-lite">梦弘浏览器 自主研发版本 - 完全自主研发，打破国外垄断，比 Chrome 快 600%。缺少上网功能。</a><br /><a href="https://github.com/lydiahallie/javascript-questions">A long list of (advanced) JavaScript questions, and their explanations ✨</a><br /><a href="https://github.com/ibraheemdev/modern-unix">A collection of modern/faster/saner alternatives to common unix commands.</a><br /><a href="https://github.com/Asabeneh/30-Days-Of-JavaScript">30 days of JavaScript programming challenge is a step-by-step guide to learn JavaScript programming language in 30 days. This challenge may take more than 100 days, please just follow your own pace.</a><br /><a href="https://github.com/massgravel/Microsoft-Activation-Scripts">A collection of scripts for activating Microsoft products using HWID / KMS38 / Online KMS activation methods with a focus on open-source code, less antivirus detection and user-friendliness.</a><br /><a href="https://github.com/trimstray/the-book-of-secret-knowledge">A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more.</a><br /><a href="https://github.com/neuralchen/SimSwap">The official project of SimSwap (ACM MM 2020)</a><br /><a href="https://github.com/programthink/zhao">【编程随想】整理的《太子党关系网络》，专门揭露赵国的权贵</a><br /><a href="https://github.com/jina-ai/jina">Cloud-native neural search framework for any kind of data</a><br /><a href="https://github.com/hotwired/turbo-rails">Use Turbo in your Ruby on Rails app</a><br /><a href="https://github.com/seata/seata">🔥 Seata is an easy-to-use, high-performance, open source distributed transaction solution.</a><br /><a href="https://github.com/allenai/allennlp">An open-source NLP research library, built on PyTorch.</a><br /><a href="https://github.com/siduck76/NvChad">beautiful neovim setup configured in lua</a><br /><a href="https://github.com/dotnet/AspNetCore.Docs">Documentation for ASP.NET Core</a><br /><a href="https://github.com/yunjey/pytorch-tutorial">PyTorch Tutorial for Deep Learning Researchers</a><br /><a href="https://github.com/neon-age/Smart-Inspector">Keeps your screen real-estate clean with refined, compact UX.</a><br /><hr />最小好进制<br /><p>对于给定的整数 n, 如果n的k（k&gt;=2）进制数的所有数位全为1，则称&nbsp;k（k&gt;=2）是 n 的一个<em><strong>好进制</strong></em>。</p>

<p>以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>&quot;13&quot;
<strong>输出：</strong>&quot;3&quot;
<strong>解释：</strong>13 的 3 进制是 111。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>&quot;4681&quot;
<strong>输出：</strong>&quot;8&quot;
<strong>解释：</strong>4681 的 8 进制是 11111。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>&quot;1000000000000000000&quot;
<strong>输出：</strong>&quot;999999999999999999&quot;
<strong>解释：</strong>1000000000000000000 的 999999999999999999 进制是 11。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li>n的取值范围是&nbsp;[3, 10^18]。</li>
	<li>输入总是有效且没有前导 0。</li>
</ol>

<p>&nbsp;</p>
<br />#### 方法一：数学

**思路及解法**

假设正整数 $n$ 在 $k~(k \geq 2)$ 进制下的所有数位都为 $1$，且位数为 $m + 1$，那么有：

$$
n = k^0 + k^1 + k^2 + \dots + k^m\tag{1}
$$

我们首先讨论两种特殊情况：

- $m=0$，此时 $n=1$，而题目保证 $n \geq 3$，所以本题中 $m>0$。
- $m=1$，此时 $n=(11)_k$，即 $k=n-1\geq 2$，这保证了本题有解。

然后我们分别证明一般情况下的两个结论，以帮助解决本题。

**结论一：$m < \log_k n$** 

注意到 $(1)$ 式右侧是一个首项为 $1$、公比为 $k$ 的等比数列，利用等比数列求和公式，我们可以得到：

$$
n = \frac{1 - k^{m+1}}{1 - k}
$$
 
对公式进行变换可得：

$$
k^{m+1} = kn - n + 1 < kn
$$

移项并化简可得：

$$
m < \log_k n
$$

这个结论帮助我们限制了 $m$ 的范围，本题中 $3 \leq n \leq 10^{18}$ 且 $k \geq 2$，所以 $m < \log_2 10^{18} < 60$。

**结论二：$k = \lfloor \sqrt[m]{n} \rfloor$** 

依据 $(1)$ 式，可知：

$$
n = k^0 + k^1 + k^2 + \dots + k^m > k^m \tag{2}
$$

依据二项式定理可知：

$$
(k+1)^m = \binom{m}{0}k^0 + \binom{m}{1}k^1 + \binom{m}{2}k^2 + \dots + \binom{m}{m}k^m
$$

因为当 $m>1$ 时，$\forall i \in [1,m-1], \dbinom{m}{i} > 1$，所以有：

$$
\begin{aligned}
(k+1)^m &= \binom{m}{0}k^0 + \binom{m}{1}k^1 + \binom{m}{2}k^2 + \dots + \binom{m}{m}k^m \\
&> k^0 + k^1 + k^2 + \dots + k^m = n \tag{3}
\end{aligned}
$$

结合 $(2)(3)$ 两式可知，当 $m>1$ 时，有 $k^m < n < (k+1)^m$。两边同时开方得：

$$
k < \sqrt[m]{n} < k+1
$$

依据这个公式我们知道，$\sqrt[m]{n}$ 必然为一个小数，且 $k$ 为 $\sqrt[m]{n}$ 的整数部分，即 $k = \lfloor \sqrt[m]{n} \rfloor$。

这个结论帮助我们在 $n$ 和 $m$ 已知的情况下快速确定 $k$ 的值。

综合上述两个结论，依据结论一，我们知道 $m$ 的取值范围为 $[1,\log_k n)$，且 $m = 1$ 时必然有解。因为随着 $m$ 的增大，$k$ 不断减小，所以我们只需要从大到小检查每一个 $m$ 可能的取值，利用结论二快速算出对应的 $k$ 值，然后校验计算出的 $k$ 值是否有效即可。如果 $k$ 值有效，我们即可返回结果。

在实际代码中，我们首先算出 $m$ 取值的上界 $\textit{mMax}$，然后从上界开始向下枚举 $m$ 值，如果当前 $m$ 值对应的 $k$ 合法，那么我们即可返回当前的 $k$ 值。如果我们一直检查到 $m=2$ 都没能找到答案，那么此时即可直接返回 $m=1$ 对应的 $k$ 值：$n-1$。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    string smallestGoodBase(string n) {
        long nVal = stol(n);
        int mMax = floor(log(nVal) / log(2));
        for (int m = mMax; m > 1; m--) {
            int k = pow(nVal, 1.0 / m);
            long mul = 1, sum = 1;
            for (int i = 0; i < m; i++) {
                mul *= k;
                sum += mul;
            }
            if (sum == nVal) {
                return to_string(k);
            }
        }
        return to_string(nVal - 1);
    }
};
```

```Java [sol1-Java]
class Solution {
    public String smallestGoodBase(String n) {
        long nVal = Long.parseLong(n);
        int mMax = (int) Math.floor(Math.log(nVal) / Math.log(2));
        for (int m = mMax; m > 1; m--) {
            int k = (int) Math.pow(nVal, 1.0 / m);
            long mul = 1, sum = 1;
            for (int i = 0; i < m; i++) {
                mul *= k;
                sum += mul;
            }
            if (sum == nVal) {
                return Integer.toString(k);
            }
        }
        return Long.toString(nVal - 1);
    }
}
```

```C# [sol1-C#]
public class Solution {
    public string SmallestGoodBase(string n) {
        long nVal = long.Parse(n);
        int mMax = (int) Math.Floor(Math.Log(nVal) / Math.Log(2));
        for (int m = mMax; m > 1; m--) {
            int k = (int) Math.Pow(nVal, 1.0 / m);
            long mul = 1, sum = 1;
            for (int i = 0; i < m; i++) {
                mul *= k;
                sum += mul;
            }
            if (sum == nVal) {
                return k.ToString();
            }
        }
        return (nVal - 1).ToString();
    }
}
```

```JavaScript [sol1-JavaScript]
var smallestGoodBase = function(n) {
    const nVal = parseInt(n);
    const mMax = Math.floor(Math.log(nVal) / Math.log(2));
    for (let m = mMax; m > 1; m--) {
        const k = BigInt(Math.floor(Math.pow(nVal, 1.0 / m)));
        if (k > 1) {
            let mul = BigInt(1), sum = BigInt(1);
            for (let i = 1; i <= m; i++) {
                mul *= k;
                sum += mul;
            }
            if (sum === BigInt(n)) {
                return k + '';
            }
        }
    }
    return (BigInt(n) - BigInt(1)) + '';
};
```

```go [sol1-Golang]
func smallestGoodBase(n string) string {
    nVal, _ := strconv.Atoi(n)
    mMax := bits.Len(uint(nVal)) - 1
    for m := mMax; m > 1; m-- {
        k := int(math.Pow(float64(nVal), 1/float64(m)))
        mul, sum := 1, 1
        for i := 0; i < m; i++ {
            mul *= k
            sum += mul
        }
        if sum == nVal {
            return strconv.Itoa(k)
        }
    }
    return strconv.Itoa(nVal - 1)
}
```

```C [sol1-C]
char* smallestGoodBase(char* n) {
    long nVal = atol(n);
    int mMax = floor(log(nVal) / log(2));
    char* ret = malloc(sizeof(char) * (mMax + 1));
    for (int m = mMax; m > 1; m--) {
        int k = pow(nVal, 1.0 / m);
        long mul = 1, sum = 1;
        for (int i = 0; i < m; i++) {
            mul *= k;
            sum += mul;
        }
        if (sum == nVal) {
            sprintf(ret, "%lld", k);
            return ret;
        }
    }
    sprintf(ret, "%lld", nVal - 1);
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(\log^2 n)$。至多需要进行 $O(\log n)$ 次检查，每次检查的时间复杂度为 $O(\log n)$。

- 空间复杂度：$O(1)$。只需要常数的空间保存若干变量。