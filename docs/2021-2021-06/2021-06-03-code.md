# 2021年06月03日 code
<a href="https://toutiao.io/k/3db8n15">Spring Boot 2 集成测试组件，七种测试手段对比</a><br /><a href="https://toutiao.io/k/pp7infh">JavaScript 中如何实现大文件并发上传？</a><br /><a href="https://toutiao.io/k/u5hnz1y">搞 Go 要了解的 2 个 Header，你知道吗？</a><br /><a href="https://toutiao.io/k/84pqgj8">JVM 进阶之路（十四）：类加载器和类加载机制</a><br /><a href="https://toutiao.io/k/sx601m9">《面试官：谈谈你对索引的认知》系列之 B+ 树</a><br /><a href="https://toutiao.io/k/y23prsw">[译] 在分布式系统中解决，或平衡微服务的复杂度（二）</a><br /><a href="https://toutiao.io/k/ctx3gpj">实用前端调试技巧</a><br /><a href="https://toutiao.io/k/50n24x9">如何设计 API 接口，实现统一格式返回？</a><br /><a href="https://toutiao.io/k/eegwzhn">在浏览器上运行 VS Code：GitHub 热点速览 v.21.22</a><br /><a href="https://toutiao.io/k/ca9haay">赢在起跑线还是智商税？聊一聊少儿编程</a><br /><a href="https://toutiao.io/k/lsu2nae">资料 | 凤凰架构_构筑可靠的大型分布式系统.pdf</a><br /><a href="https://toutiao.io/k/rnwvxmu">JS 兵法 36 计，你会多少？</a><br /><a href="https://toutiao.io/k/x63awoh">Rust 不能做的事情，用什么替代？</a><br /><a href="https://toutiao.io/k/oux072a">物联网数据库 IoTDB：从协议到数据</a><br /><a href="https://toutiao.io/k/ultvymn">C++ 基础库 co v2.0 正式发布</a><br /><a href="https://toutiao.io/k/mhor87n">我的项目出了一个高危漏洞，值得注意</a><br /><a href="https://toutiao.io/k/ndkydbf">Golang 调度策略</a><br /><a href="https://toutiao.io/k/z248mze">Flink + Iceberg 在去哪儿的实时数仓实践</a><br /><a href="https://toutiao.io/k/i5gh9t6">你需要了解的 App 安全</a><br /><a href="https://toutiao.io/k/eh9k2t1">AES 算法（五）：GCM 工作模式</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/osge9c2">[推荐] 这款远程桌面软件开源了</a><br /><a href="https://toutiao.io/k/ep5e8sd">[推荐] 亿级系统的 Redis 缓存如何设计？</a><br /><a href="https://toutiao.io/k/5za3e5u">[推荐] Golang 内存管理分析</a><br /><a href="https://toutiao.io/k/lq1k5bp">[推荐] [译] 您不想错过的 IntelliJ IDEA 十大插件</a><br /><a href="https://toutiao.io/k/ngx4og0">[推荐] “三次握手，四次挥手” 这么讲，保证你忘不了</a><br /><a href="https://toutiao.io/k/5u1byn9">[推荐] 各厂三年 Go 面经，已入字节</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/pws2m3l">[推荐] 微软又一个数据可视化神器开源了！非常酷炫</a><br /><a href="https://toutiao.io/k/18gz8ap">[推荐] 百亿规模 API 网关服务 Shepherd 的设计与实现</a><br /><a href="https://toutiao.io/k/t1o49fm">[推荐] 企业微信万亿级日志检索系统</a><br /><hr /><a href="https://github.com/alibaba/PolarDB-for-PostgreSQL"></a><br /><a href="https://github.com/login?return_to=%2Fphotoprism%2Fphotoprism">Open-Source Photo Management powered by Go and Google TensorFlow</a><br /><a href="https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot">This is a fully functioning Binance trading bot that measures the volatility of every coin on Binance and places trades with the highest gaining coins If you like this project consider donating though the Brave browser to allow me to continuously improve the script.</a><br /><a href="https://github.com/chinnkarahoi/jd_scripts">lxk0301/jd_scripts备份。不要star。不要fork。谢谢配合。</a><br /><a href="https://github.com/login?return_to=%2Fbinji%2Fpokegb">A gameboy emulator that only plays Pokemon Blue, in ~70 lines of c++.</a><br /><a href="https://github.com/microsoft/winget-cli">Windows Package Manager CLI (aka winget)</a><br /><a href="https://github.com/curtinlv/JD-Script"></a><br /><a href="https://github.com/prisma/prisma">Next-generation ORM for Node.js & TypeScript | PostgreSQL, MySQL, MariaDB, SQL Server & SQLite</a><br /><a href="https://github.com/files-community/Files">A modern file explorer that pushes the boundaries of the platform.</a><br /><a href="https://github.com/sarthaksavvy/100DaysOfAWS"></a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/Snailclimb/JavaGuide">「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！</a><br /><a href="https://github.com/login?return_to=%2Fdeepfakes%2Ffaceswap">Deepfakes Software For All</a><br /><a href="https://github.com/login?return_to=%2FGuitarML%2FNeuralPi">Raspberry Pi guitar pedal using neural networks to emulate real amps and pedals.</a><br /><a href="https://github.com/pmndrs/racing-game">🏎 Open source racing game developed by everyone willing</a><br /><a href="https://github.com/ionic-team/ionic-framework">A powerful cross-platform UI toolkit for building native-quality iOS, Android, and Progressive Web Apps with HTML, CSS, and JavaScript.</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/koreader/koreader">An ebook reader application supporting PDF, DjVu, EPUB, FB2 and many more formats, running on Cervantes, Kindle, Kobo, PocketBook and Android devices</a><br /><a href="https://github.com/leonardomso/33-js-concepts">📜 33 JavaScript concepts every developer should know.</a><br /><a href="https://github.com/TheAlgorithms/Java">All Algorithms implemented in Java</a><br /><a href="https://github.com/redis/redis">Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported: Strings, Lists, Sets, Sorted Sets, Hashes, Streams, HyperLogLogs, Bitmaps.</a><br /><a href="https://github.com/admin-ch/CovidCertificate-Documents">Documents related to covid certificate system in Switzerland</a><br /><a href="https://github.com/obsproject/obs-studio">OBS Studio - Free and open source software for live streaming and screen recording</a><br /><a href="https://github.com/datasciencemasters/go">The Open Source Data Science Masters</a><br /><a href="https://github.com/nodejs/node">Node.js JavaScript runtime ✨🐢🚀✨</a><br /><hr />连续数组<br /><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> nums = [0,1]
<strong>输出:</strong> 2
<strong>说明:</strong> [0, 1] 是具有相同数量0和1的最长连续子数组。</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> nums = [0,1,0]
<strong>输出:</strong> 2
<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ul>
<br />#### 方法一：前缀和 + 哈希表

由于「$0$ 和 $1$ 的数量相同」等价于「$1$ 的数量减去 $0$ 的数量等于 $0$」，我们可以将数组中的 $0$ 视作 $-1$，则原问题转换成「求最长的连续子数组，其元素和为 $0$」。

设数组 $\textit{nums}$ 的长度为 $n$，将数组 $\textit{nums}$ 进行转换得到长度相等的新数组 $\textit{newNums}$：对于 $0 \le i<n$，当 $\textit{nums}[i]=1$ 时 $\textit{newNums}[i]=1$，当 $\textit{nums}[i]=0$ 时 $\textit{newNums}[i]=-1$。

为了快速计算 $\textit{newNums}$ 的子数组的元素和，需要首先计算 $\textit{newNums}$ 的前缀和。用 $\textit{prefixSums}[i]$ 表示 $\textit{newNums}$ 从下标 $0$ 到下标 $i$ 的前缀和，则 $\textit{newNums}$ 从下标 $j+1$ 到下标 $k$（其中 $j<k$）的子数组的元素和为 $\textit{prefixSums}[k]-\textit{prefixSums}[j]$，该子数组的长度为 $k-j$。

当 $\textit{prefixSums}[k]-\textit{prefixSums}[j]=0$ 时，即得到 $\textit{newNums}$ 的一个长度为 $k-j$ 的子数组元素和为 $0$，对应 $\textit{nums}$ 的一个长度为 $k-j$ 的子数组中有相同数量的 $0$ 和 $1$。

实现方面，不需要创建数组 $\textit{newNums}$ 和 $\textit{prefixSums}$，只需要维护一个变量 $\textit{counter}$ 存储 $\textit{newNums}$ 的前缀和即可。具体做法是，遍历数组 $\textit{nums}$，当遇到元素 $1$ 时将 $\textit{counter}$ 的值加 $1$，当遇到元素 $0$ 时将 $\textit{counter}$ 的值减 $1$，遍历过程中使用哈希表存储每个前缀和第一次出现的下标。

规定空的前缀的结束下标为 $-1$，由于空的前缀的元素和为 $0$，因此在遍历之前，首先在哈希表中存入键值对 $(0,-1)$。遍历过程中，对于每个下标 $i$，进行如下操作：

- 如果 $\textit{counter}$ 的值在哈希表中已经存在，则取出 $\textit{counter}$ 在哈希表中对应的下标 $\textit{prevIndex}$，$\textit{nums}$ 从下标 $\textit{prevIndex}+1$ 到下标 $i$ 的子数组中有相同数量的 $0$ 和 $1$，该子数组的长度为 $i-\textit{prevIndex}$，使用该子数组的长度更新最长连续子数组的长度；

- 如果 $\textit{counter}$ 的值在哈希表中不存在，则将当前余数和当前下标 $i$ 的键值对存入哈希表中。

由于哈希表存储的是 $\textit{counter}$ 的每个取值第一次出现的下标，因此当遇到重复的前缀和时，根据当前下标和哈希表中存储的下标计算得到的子数组长度是以当前下标结尾的子数组中满足有相同数量的 $0$ 和 $1$ 的最长子数组的长度。遍历结束时，即可得到 $\textit{nums}$ 中的有相同数量的 $0$ 和 $1$ 的最长子数组的长度。

```Java [sol1-Java]
class Solution {
    public int findMaxLength(int[] nums) {
        int maxLength = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int counter = 0;
        map.put(counter, -1);
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            if (num == 1) {
                counter++;
            } else {
                counter--;
            }
            if (map.containsKey(counter)) {
                int prevIndex = map.get(counter);
                maxLength = Math.max(maxLength, i - prevIndex);
            } else {
                map.put(counter, i);
            }
        }
        return maxLength;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int FindMaxLength(int[] nums) {
        int maxLength = 0;
        Dictionary<int, int> dictionary = new Dictionary<int, int>();
        int counter = 0;
        dictionary.Add(counter, -1);
        int n = nums.Length;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            if (num == 1) {
                counter++;
            } else {
                counter--;
            }
            if (dictionary.ContainsKey(counter)) {
                int prevIndex = dictionary[counter];
                maxLength = Math.Max(maxLength, i - prevIndex);
            } else {
                dictionary.Add(counter, i);
            }
        }
        return maxLength;
    }
}
```

```JavaScript [sol1-JavaScript]
var findMaxLength = function(nums) {
    let maxLength = 0;
    const map = new Map();
    let counter = 0;
    map.set(counter, -1);
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        const num = nums[i];
        if (num == 1) {
            counter++;
        } else {
            counter--;
        }
        if (map.has(counter)) {
            const prevIndex = map.get(counter);
            maxLength = Math.max(maxLength, i - prevIndex);
        } else {
            map.set(counter, i);
        }
    }
    return maxLength;
};
```

```go [sol1-Golang]
func findMaxLength(nums []int) (maxLength int) {
    mp := map[int]int{0: -1}
    counter := 0
    for i, num := range nums {
        if num == 1 {
            counter++
        } else {
            counter--
        }
        if prevIndex, has := mp[counter]; has {
            maxLength = max(maxLength, i-prevIndex)
        } else {
            mp[counter] = i
        }
    }
    return
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```C++ [sol1-c++]
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int maxLength = 0;
        unordered_map<int, int> mp;
        int counter = 0;
        mp[counter] = -1;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            if (num == 1) {
                counter++;
            } else {
                counter--;
            }
            if (mp.count(counter)) {
                int prevIndex = mp[counter];
                maxLength = max(maxLength, i - prevIndex);
            } else {
                mp[counter] = i;
            }
        }
        return maxLength;
    }
};
```

```C [sol1-C]
struct HashTable {
    int key, val;
    UT_hash_handle hh;
};

int findMaxLength(int* nums, int numsSize) {
    int maxLength = 0;
    struct HashTable* hashTable = NULL;
    struct HashTable* tmp = malloc(sizeof(struct HashTable));
    tmp->key = 0, tmp->val = -1;
    HASH_ADD_INT(hashTable, key, tmp);
    int counter = 0;
    int n = numsSize;
    for (int i = 0; i < n; i++) {
        int num = nums[i];
        if (num == 1) {
            counter++;
        } else {
            counter--;
        }
        HASH_FIND_INT(hashTable, &counter, tmp);
        if (tmp != NULL) {
            int prevIndex = tmp->val;
            maxLength = fmax(maxLength, i - prevIndex);
        } else {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = counter, tmp->val = i;
            HASH_ADD_INT(hashTable, key, tmp);
        }
    }
    return maxLength;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。需要遍历数组一次。

- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。空间复杂度主要取决于哈希表，哈希表中存储的不同的 $\textit{counter}$ 的值不超过 $n$ 个。