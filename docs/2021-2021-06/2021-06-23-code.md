# 2021年06月23日 code
<a href="https://toutiao.io/k/88ebc7h">[译] 如何优化您的日常决策</a><br /><a href="https://toutiao.io/k/ic0wg6u">近期做的稳定性建设总结</a><br /><a href="https://toutiao.io/k/gnbgq3w">一文理解 MySQL 的锁机制与死锁排查</a><br /><a href="https://toutiao.io/k/jqofcc1">Ethers.js 非权威开发指南（下）</a><br /><a href="https://toutiao.io/k/4ycv1d9">在 Golang 中是锁或 Channel 还是 Atomic</a><br /><a href="https://toutiao.io/k/9mznc2m">中后台领域低代码搭建设计与实践</a><br /><a href="https://toutiao.io/k/akx3jo7">一文带你深入理解 Serializable 隔离最新技术 SSI</a><br /><a href="https://toutiao.io/k/53zqdvc">十亿级流量下，我与 Redis 时延小突刺的战斗史</a><br /><a href="https://toutiao.io/k/uvnskcx">os.Chmod 时到底用 777 还是 0777</a><br /><a href="https://toutiao.io/k/5e72t8f">弱口令问题引发安全的思考</a><br /><a href="https://toutiao.io/k/7uogyta">漫谈 MQ：要消息队列 (MQ) 有什么用？</a><br /><a href="https://toutiao.io/k/c4fn3ry">Heidou：CRUD 终结者</a><br /><a href="https://toutiao.io/k/kv32nv6">有了这个 4.5 万 Star 的工具，可在浏览器中运行最强编辑器 VS Code</a><br /><a href="https://toutiao.io/k/6zsmt7e">TCP 基础知识</a><br /><a href="https://toutiao.io/k/y44f8iu">宝，我今天 CR 了，C 的什么 R? 走过场的 CR</a><br /><a href="https://toutiao.io/k/913ftw6">揭秘 MySQL 的主从同步实现方案</a><br /><a href="https://toutiao.io/k/nd1ollu">好习惯！Pandas 8 个常用的 option 设置</a><br /><a href="https://toutiao.io/k/8qv5k2e">比构建速度，Bazel 是 Gradle 的 10 倍，不服不行</a><br /><a href="https://toutiao.io/k/pynz6pb">Lucene 查询 TopN 的优化（一）</a><br /><a href="https://toutiao.io/k/nhzgwc7">Transformer 在计算机视觉领域疯狂 “内卷”</a><br /><a href="https://toutiao.io/k/a7bxrhs">[推荐] 有赞 TCP 网络编程最佳实践</a><br /><a href="https://toutiao.io/k/l55l3jp">[推荐] 这可能是最轻量高效的运维监控工具：开源 WGCLOUD</a><br /><a href="https://toutiao.io/k/xjnx4kp">[推荐] 杭州某大厂：MySQL 连环问</a><br /><a href="https://toutiao.io/k/96b5kbd">[推荐] 领域驱动设计、可视化与遗留系统的微服务改造</a><br /><a href="https://toutiao.io/k/t9ic9wp">[推荐] 徒手用 Go 写个 Redis 服务器</a><br /><a href="https://toutiao.io/k/92nisj7">[推荐] 高吞吐、低延迟 Java 应用的 GC 优化实践</a><br /><a href="https://toutiao.io/k/3kwp297">[推荐] 月薪两万程序员应该知道的编程模型</a><br /><a href="https://toutiao.io/k/pbwl6pl">[推荐] 95% 的算法都是基于这 6 种算法思想</a><br /><a href="https://toutiao.io/k/kkc4ght">[推荐] 利用 Kubernetes 搭建便携式开发环境之 MySQL 和 Redis</a><br /><a href="https://toutiao.io/k/xhidp2b">[推荐] 一文通关苦涩难懂的 Java 泛型</a><br /><hr /><a href="https://github.com/six-ddc/plow">A high-performance HTTP benchmarking tool with real-time web UI and terminal displaying</a><br /><a href="https://github.com/n8n-io/n8n">Free and open fair-code licensed node based Workflow Automation Tool. Easily automate tasks across different services.</a><br /><a href="https://github.com/maaslalani/slides">Terminal based presentation tool</a><br /><a href="https://github.com/OffcierCia/DeFi-Developer-Road-Map">DeFi Developer Road Map. Feel free to submit a pull request, with anything from small fixes to translations, docs or tools you'd like to add.</a><br /><a href="https://github.com/login?return_to=%2Frwightman%2Fpytorch-image-models">PyTorch image models, scripts, pretrained weights -- ResNet, ResNeXT, EfficientNet, EfficientNetV2, NFNet, Vision Transformer, MixNet, MobileNet-V3/V2, RegNet, DPN, CSPNet, and more</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/PaddlePaddle/PaddleClas">A treasure chest for visual recognition powered by PaddlePaddle</a><br /><a href="https://github.com/tstewart161/Reddit_Sentiment_Trader"></a><br /><a href="https://github.com/facebookresearch/AugLy">A data augmentations library for audio, image, text, and video.</a><br /><a href="https://github.com/madebygps/self-taught-guide-to-cloud-computing">My self taught guide to cloud computing.</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/algorithm-visualizer/algorithm-visualizer">🎆Interactive Online Platform that Visualizes Algorithms from Code</a><br /><a href="https://github.com/home-assistant/core">🏡 Open source home automation that puts local control and privacy first</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/benthecoder/yt-channels-DS-AI-ML-CS">A comprehensive list of 160+ YouTube Channels for Data Science, Data Engineering, Machine Learning, Deep learning, Computer Science, programming, software engineering, etc.</a><br /><a href="https://github.com/KarenOk/whatsapp-web-clone">Clone of Whatsapp Web's current UI.</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/kwai/DouZero">[ICML 2021] DouZero: Mastering DouDizhu with Self-Play Deep Reinforcement Learning | 斗地主AI</a><br /><a href="https://github.com/danistefanovic/build-your-own-x">🤓 Build your own (insert technology here)</a><br /><a href="https://github.com/kdn251/interviews">Everything you need to know to get the job.</a><br /><a href="https://github.com/bradtraversy/design-resources-for-developers">Curated list of design and UI resources from stock photos, web templates, CSS frameworks, UI libraries, tools and much more</a><br /><a href="https://github.com/vxunderground/MalwareSourceCode">Collection of malware source code for a variety of platforms in an array of different programming languages.</a><br /><a href="https://github.com/login?return_to=%2Fkamranahmedse%2Fdeveloper-roadmap">Roadmap to becoming a web developer in 2021</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/CyC2018/CS-Notes">📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</a><br /><hr />二进制中1的个数<br /><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>00000000000000000000000000001011
<strong>输出：</strong>3
<strong>解释：</strong>输入的二进制串 <code><strong>00000000000000000000000000001011</strong> 中，共有三位为 '1'。</code>
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>00000000000000000000000010000000
<strong>输出：</strong>1
<strong>解释：</strong>输入的二进制串 <strong>00000000000000000000000010000000</strong> 中，共有一位为 '1'。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>11111111111111111111111111111101
<strong>输出：</strong>31
<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 31 位为 '1'。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>

<p> </p>

<p>注意：本题与主站 191 题相同：<a href="https://leetcode-cn.com/problems/number-of-1-bits/">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>
<br />#### 方法一：循环检查二进制位

**思路及解法**

我们可以直接循环检查给定整数 $n$ 的二进制位的每一位是否为 $1$。

具体代码中，当检查第 $i$ 位时，我们可以让 $n$ 与 $2^i$ 进行与运算，当且仅当 $n$ 的第 $i$ 位为 $1$ 时，运算结果不为 $0$。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                ret++;
            }
        }
        return ret;
    }
};
```

```Java [sol1-Java]
public class Solution {
    public int hammingWeight(int n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                ret++;
            }
        }
        return ret;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int HammingWeight(uint n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                ret++;
            }
        }
        return ret;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i)) 
        return ret
```

```go [sol1-Golang]
func hammingWeight(num uint32) (ones int) {
    for i := 0; i < 32; i++ {
        if 1<<i&num > 0 {
            ones++
        }
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var hammingWeight = function(n) {
    let ret = 0;
    for (let i = 0; i < 32; i++) {
        if ((n & (1 << i)) !== 0) {
            ret++;
        }
    }
    return ret;
};
```

```C [sol1-C]
int hammingWeight(uint32_t n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) {
        if (n & (1u << i)) {
            ret++;
        }
    }
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(k)$，其中 $k$ 是 $\texttt{int}$ 型的二进制位数，$k=32$。我们需要检查 $n$ 的二进制位的每一位，一共需要检查 $32$ 位。

- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。

#### 方法二：位运算优化

**思路及解法**

观察这个运算：$n~\&~(n - 1)$，其预算结果恰为把 $n$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

如：$6~\&~(6-1) = 4, 6 = (110)_2, 4 = (100)_2$，运算结果 $4$ 即为把 $6$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 $n$ 与 $n - 1$ 做与运算，直到 $n$ 变为 $0$ 即可。因为每次运算会使得 $n$ 的最低位的 $1$ 被翻转，因此运算次数就等于 $n$ 的二进制位中 $1$ 的个数。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};
```

```Java [sol2-Java]
public class Solution {
    public int hammingWeight(int n) {
        int ret = 0;
        while (n != 0) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int HammingWeight(uint n) {
        int ret = 0;
        while (n != 0) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
}
```

```Python [sol2-Python3]
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = 0
        while n:
            n &= n - 1
            ret += 1
        return ret
```

```go [sol2-Golang]
func hammingWeight(num uint32) (ones int) {
    for ; num > 0; num &= num - 1 {
        ones++
    }
    return
}
```

```JavaScript [sol2-JavaScript]
var hammingWeight = function(n) {
    let ret = 0;
    while (n) {
        n &= n - 1;
        ret++;
    }
    return ret;
};
```

```C [sol2-C]
int hammingWeight(uint32_t n) {
    int ret = 0;
    while (n) {
        n &= n - 1;
        ret++;
    }
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(\log n)$。循环次数等于 $n$ 的二进制位中 $1$ 的个数，最坏情况下 $n$ 的二进制位全部为 $1$。我们需要循环 $\log n$ 次。

- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。