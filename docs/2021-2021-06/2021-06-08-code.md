# 2021年06月08日 code
<a href="https://toutiao.io/k/3xscqep">一文理解 Java 中的 SPI 机制</a><br /><a href="https://toutiao.io/k/mr1knwm">微服务拆分之道</a><br /><a href="https://toutiao.io/k/9kcl6r7">假如 Go 能说话，听听 GMP 的心声</a><br /><a href="https://toutiao.io/k/zasa0zm">原始套接字打造 ping 命令</a><br /><a href="https://toutiao.io/k/6qaznpz">面试侃集合：SynchronousQueue 非公平模式篇</a><br /><a href="https://toutiao.io/k/opt3f3h">什么是线程安全？一文带你深入理解</a><br /><a href="https://toutiao.io/k/5pjcy2l">如何不 Review 每一行代码，同时保持代码不被写乱？</a><br /><a href="https://toutiao.io/k/mhxkvxn">程序员与年龄：四十岁普通开发、三十五岁首席架构、三十岁基层 Leader</a><br /><a href="https://toutiao.io/k/6fbpfkb">[译] Kubernetes 单点登录详解</a><br /><a href="https://toutiao.io/k/dp8odki">eBPF 介绍</a><br /><a href="https://toutiao.io/k/5brs7n5">读写分离水太深，你把握不住，让叔来</a><br /><a href="https://toutiao.io/k/u0c27wf">关于自动化测试的几个正确认知</a><br /><a href="https://toutiao.io/k/jo10x1d">Spark 中如何使用矩阵运算间接实现 i2i</a><br /><a href="https://toutiao.io/k/vaqdn3v">Kotlin 中使用 Hilt 的开发实践</a><br /><a href="https://toutiao.io/k/qw4n9w2">日常 Bug 排查：消息不消费</a><br /><a href="https://toutiao.io/k/fytbybw">比特币白皮书：回收硬盘空间</a><br /><a href="https://toutiao.io/k/06o6gpr">密码学基础（二）：数字证书、密钥基础知识</a><br /><a href="https://toutiao.io/k/vi02cmo">从自动驾驶到自动扩缩容：达达智能弹性伸缩架构和实践</a><br /><a href="https://toutiao.io/k/hv9yjg0">低代码开发简史</a><br /><a href="https://toutiao.io/k/ozo6omu">开源鸿蒙网络和 hdc 连接方法</a><br /><a href="https://toutiao.io/k/jwzcso7">[推荐] 字节跳动异构场景下的高可用建设实践</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/te3l12o">[推荐] 人人都是架构师？？？谈何容易</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/wwmsd4f">[推荐] 学会这 10 个设计原则，离架构师又进了一步</a><br /><a href="https://toutiao.io/k/ow2rhiz">[推荐] Linux 调度系统全景指南（终结篇）</a><br /><a href="https://toutiao.io/k/6tcdyp9">[推荐] Spring Boot 在 K8s 下实现优雅停机</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/z26byeu">[推荐] 25 张图，一万字，拆解 Linux 网络包发送过程</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/lq1k5bp">[推荐] [译] 您不想错过的 IntelliJ IDEA 十大插件</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/3tudqnj">[推荐] 做一次黑客，入侵一次服务器</a><br /><a href="https://toutiao.io/k/ngx4og0">[推荐] “三次握手，四次挥手” 这么讲，保证你忘不了</a><br /><hr /><a href="https://github.com/login?return_to=%2Fdeepfakes%2Ffaceswap">Deepfakes Software For All</a><br /><a href="https://github.com/firstcontributions/first-contributions">🚀✨ Help beginners to contribute to open source projects</a><br /><a href="https://github.com/home-assistant/core">🏡 Open source home automation that puts local control and privacy first</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/chubin/cheat.sh">the only cheat sheet you need</a><br /><a href="https://github.com/freqtrade/freqtrade">Free, open source crypto trading bot</a><br /><a href="https://github.com/login?return_to=%2Filuwatar%2Fjava-design-patterns">Design patterns implemented in Java</a><br /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Beta)</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/Awesome-HarmonyOS/HarmonyOS">A curated list of awesome things related to HarmonyOS. 华为鸿蒙操作系统。</a><br /><a href="https://github.com/KranX/Perimeter"></a><br /><a href="https://github.com/topjohnwu/Magisk">The Magic Mask for Android</a><br /><a href="https://github.com/ParthJadhav/Tkinter-Designer">Create Beautiful Tkinter GUIs by Drag and Drop ☄️</a><br /><a href="https://github.com/maaslalani/slides">Terminal based presentation tool</a><br /><a href="https://github.com/academind/react-complete-guide-code">Code snapshots and materials for our "React - The Complete Guide" course (https://acad.link/reactjs)</a><br /><a href="https://github.com/sundowndev/phoneinfoga">Information gathering & OSINT framework for phone numbers</a><br /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/python-telegram-bot/python-telegram-bot">We have made you a wrapper you can't refuse</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/login?return_to=%2Fgeerlingguy%2Fmac-dev-playbook">Mac setup and configuration via Ansible.</a><br /><a href="https://github.com/login?return_to=%2Fswisskyrepo%2FPayloadsAllTheThings">A list of useful payloads and bypass for Web Application Security and Pentest/CTF</a><br /><a href="https://github.com/freddier/hyperblog">Un blog increíble para el curso de Git y Github de Platzi</a><br /><a href="https://github.com/jhu-ep-coursera/fullstack-course4">Example code for HTML, CSS, and Javascript for Web Developers Coursera Course</a><br /><a href="https://github.com/atlas-engineer/nyxt">Nyxt - the internet on your terms.</a><br /><a href="https://github.com/electron/electron">Build cross-platform desktop apps with JavaScript, HTML, and CSS</a><br /><hr />最后一块石头的重量 II<br /><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>

<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x <= y</code>。那么粉碎的可能结果如下：</p>

<ul>
	<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
	<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>

<p>最后，<strong>最多只会剩下一块 </strong>石头。返回此石头 <strong>最小的可能重量 </strong>。如果没有石头剩下，就返回 <code>0</code>。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>stones = [2,7,4,1,8,1]
<strong>输出：</strong>1
<strong>解释：</strong>
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>stones = [31,26,33,21,40]
<strong>输出：</strong>5
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>stones = [1,2]
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= stones.length <= 30</code></li>
	<li><code>1 <= stones[i] <= 100</code></li>
</ul>
<br />#### 前言：合法性证明

为了便于讨论，若最终没有石头剩下，则视作最终剩下了一块重量为 $0$ 的石头。

用归纳法可以证明，无论按照何种顺序粉碎石头，最后一块石头的重量总是可以表示成

$$
\sum_{i=0}^{n-1} k_i \times \textit{stones}_i,\ \ k_i\in\{-1,1\}
$$

但不是所有 $k_i$ 的取值都是合法的。例如有四块石头，其重量分别为 $a$，$b$，$c$，$d$，且满足 $a\le b\le c\le d$。由于石头的重量不可能增加，无论怎么操作，我们是不可能得到大小为 $d+c+b-a$ 的石头的，该重量已经超过了 $c$ 以及 $d$。

那么，上述和式的最小非负值所对应的这组 $\{k_i\}$ 是合法的吗？

我们将这组 $\{k_i\}$ 对应的石头划分成两堆，$k_i=1$ 的石头分至一堆，$k_i=-1$ 的石头分至另一堆。由于这是最小非负值所对应的 $\{k_i\}$，**这两堆石头重量之差的绝对值也是所有划分当中最小的**。

记这两堆石头重量之差的绝对值为 $\textit{diff}$。若能找到一种粉碎方案，使得最后一块石头的重量也为 $\textit{diff}$，那就能说明这组 $\{k_i\}$ 是合法的。

我们不断地粉碎石头。每次粉碎时，记重量最大的石头所处的堆为 $A$（若两堆最大重量相同则任选一堆），另一堆为 $B$。从 $A$ 中取出重量最大的石头，$B$ 中任取一石头，若没有完全粉碎，则将新石头重新放入 $A$。这一操作从每堆石头中减去了同样的重量，从而保证重量之差的绝对值在粉碎前后是不变的。

若出现一堆没有石头，而另一堆不止一块石头的情况，记有石头的那一堆为 $A$，另一堆为 $B$。要继续粉碎，则需要从 $A$ 中取出一块石头移入 $B$，然后按规则粉碎。但移入操作让重量之差的绝对值变得更小，与事实（上文加粗文字）矛盾，所以不会出现这种情况。

因此，按照上述流程操作，最后一块石头的重量为 $\textit{diff}$，所以这组 $\{k_i\}$ 对应着一个合法的粉碎结果。

#### 方法一：动态规划

记石头的总重量为 $\textit{sum}$，$k_i=-1$ 的石头的重量之和为 $\textit{neg}$，则其余 $k_i=1$ 的石头的重量之和为 $\textit{sum}-\textit{neg}$。则有

$$
\sum_{i=0}^{n-1} k_i\cdot\textit{stones}_i = (\textit{sum}-\textit{neg})-\textit{neg} = \textit{sum}-2\cdot\textit{neg}
$$

要使最后一块石头的重量尽可能地小，$\textit{neg}$ 需要在不超过 $\lfloor \textit{sum}/2 \rfloor$ 的前提下尽可能地大。因此本问题可以看作是背包容量为 $\lfloor \textit{sum}/2 \rfloor$，物品重量和价值均为 $\textit{stones}_i$ 的 0-1 背包问题。

对于该问题，定义二维布尔数组 $\textit{dp}$，其中 $\textit{dp}[i+1][j]$ 表示前 $i$ 个石头能否凑出重量 $j$。特别地，$\textit{dp}[0][]$ 为不选任何石头的状态，因此除了 $\textit{dp}[0][0]$ 为真，其余 $\textit{dp}[0][j]$ 全为假。

对于第 $i$ 个石头，考虑凑出重量 $j$：

- 若 $j<\textit{stones}[i]$，则不能选第 $i$ 个石头，此时有 $\textit{dp}[i+1][j]=\textit{dp}[i][j]$；
- 若 $j\ge \textit{stones}[i]$，存在选或不选两种决策，不选时有 $\textit{dp}[i+1][j]=\textit{dp}[i][j]$，选时需要考虑能否凑出重量 $j-\textit{stones}[i]$，即 $\textit{dp}[i+1][j]=\textit{dp}[i][j-\textit{stones}[i]]$。若二者均为假则 $\textit{dp}[i+1][j]$ 为假，否则 $\textit{dp}[i+1][j]$ 为真。

因此状态转移方程如下：

$$
\textit{dp}[i+1][j]=
\begin{cases}
\textit{dp}[i][j],& j<\textit{stones}[i] \\
\textit{dp}[i][j] \lor \textit{dp}[i][j-\textit{stones}[i]]), & j\ge \textit{stones}[i]
\end{cases}
$$

其中 $\lor$ 表示逻辑或运算。求出 $\textit{dp}[n][]$ 后，所有为真的 $\textit{dp}[n][j]$ 中，最大的 $j$ 即为 $\textit{neg}$ 能取到的最大值。代入 $\textit{sum}-2\cdot\textit{neg}$ 中即得到最后一块石头的最小重量。

```C++ [sol1-C++]
class Solution {
public:
    int lastStoneWeightII(vector<int> &stones) {
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int n = stones.size(), m = sum / 2;
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        dp[0][0] = true;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (j < stones[i]) {
                    dp[i + 1][j] = dp[i][j];
                } else {
                    dp[i + 1][j] = dp[i][j] || dp[i][j - stones[i]];
                }
            }
        }
        for (int j = m;; --j) {
            if (dp[n][j]) {
                return sum - 2 * j;
            }
        }
    }
};
```

```Java [sol1-Java]
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int weight : stones) {
            sum += weight;
        }
        int n = stones.length, m = sum / 2;
        boolean[][] dp = new boolean[n + 1][m + 1];
        dp[0][0] = true;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (j < stones[i]) {
                    dp[i + 1][j] = dp[i][j];
                } else {
                    dp[i + 1][j] = dp[i][j] || dp[i][j - stones[i]];
                }
            }
        }
        for (int j = m;; --j) {
            if (dp[n][j]) {
                return sum - 2 * j;
            }
        }
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int LastStoneWeightII(int[] stones) {
        int sum = 0;
        foreach (int weight in stones) {
            sum += weight;
        }
        int n = stones.Length, m = sum / 2;
        bool[,] dp = new bool[n + 1, m + 1];
        dp[0, 0] = true;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (j < stones[i]) {
                    dp[i + 1, j] = dp[i, j];
                } else {
                    dp[i + 1, j] = dp[i, j] || dp[i, j - stones[i]];
                }
            }
        }
        for (int j = m;; --j) {
            if (dp[n, j]) {
                return sum - 2 * j;
            }
        }
    }
}
```

```go [sol1-Golang]
func lastStoneWeightII(stones []int) int {
    sum := 0
    for _, v := range stones {
        sum += v
    }
    n, m := len(stones), sum/2
    dp := make([][]bool, n+1)
    for i := range dp {
        dp[i] = make([]bool, m+1)
    }
    dp[0][0] = true
    for i, weight := range stones {
        for j := 0; j <= m; j++ {
            if j < weight {
                dp[i+1][j] = dp[i][j]
            } else {
                dp[i+1][j] = dp[i][j] || dp[i][j-weight]
            }
        }
    }
    for j := m; ; j-- {
        if dp[n][j] {
            return sum - 2*j
        }
    }
}
```

```JavaScript [sol1-JavaScript]
var lastStoneWeightII = function(stones) {
    let sum = 0;
    for (const weight of stones) {
        sum += weight;
    }
    const n = stones.length, m = Math.floor(sum / 2);
    const dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(false));
    dp[0][0] = true;
    for (let i = 0; i < n; ++i) {
        for (let j = 0; j <= m; ++j) {
            if (j < stones[i]) {
                dp[i + 1][j] = dp[i][j];
            } else {
                dp[i + 1][j] = dp[i][j] || dp[i][j - stones[i]];
            }
        }
    }
    for (let j = m;; --j) {
        if (dp[n][j]) {
            return sum - 2 * j;
        }
    }
};
```

```Python [sol1-Python3]
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        total = sum(stones)
        n, m = len(stones), total // 2
        dp = [[False] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = True

        for i in range(n):
            for j in range(m + 1):
                if j < stones[i]:
                    dp[i + 1][j] = dp[i][j]
                else:
                    dp[i + 1][j] = dp[i][j] or dp[i][j - stones[i]]
        
        ans = None
        for j in range(m, -1, -1):
            if dp[n][j]:
                ans = total - 2 * j
                break
        
        return ans
```

```C [sol1-C]
int lastStoneWeightII(int* stones, int stonesSize) {
    int sum = 0;
    for (int i = 0; i < stonesSize; i++) {
        sum += stones[i];
    }
    int n = stonesSize, m = sum / 2;
    int dp[n + 1][m + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = true;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j <= m; ++j) {
            if (j < stones[i]) {
                dp[i + 1][j] = dp[i][j];
            } else {
                dp[i + 1][j] = dp[i][j] || dp[i][j - stones[i]];
            }
        }
    }
    for (int j = m;; --j) {
        if (dp[n][j]) {
            return sum - 2 * j;
        }
    }
}
```

由于 $\textit{dp}[i+1][]$ 的每个元素值的计算只和 $\textit{dp}[i][]$ 的元素值有关，因此可以使用滚动数组的方式，去掉 $\textit{dp}$ 的第一个维度。

对于转移方程 

$$
\textit{dp}[i+1][j]=\textit{dp}[i][j] \lor \textit{dp}[i][j-\textit{stones}[i]]
$$

在去掉第一个维度后，若仍采用正序遍历，在计算 $\textit{dp}[j]$ 时，$\textit{dp}[j-\textit{stones}[i]]$ 的值已经被覆盖，这意味着 $\textit{dp}[j-\textit{stones}[i]]$ 实际对应的是 $\textit{dp}[i+1][j-\textit{stones}[i]]$，即我们计算的是一个错误的转移方程

$$
\textit{dp}[i+1][j]=\textit{dp}[i][j] \lor \textit{dp}[i+1][j-\textit{stones}[i]]
$$

若采用倒序遍历，则可消除该错误，这种方式保证计算 $\textit{dp}[j]$ 时，$\textit{dp}[j-\textit{stones}[i]]$ 的值实际对应的是 $\textit{dp}[i][j-\textit{stones}[i]]$，从而保证转移方程与去掉维度前一致。

```C++ [sol2-C++]
class Solution {
public:
    int lastStoneWeightII(vector<int> &stones) {
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int m = sum / 2;
        vector<int> dp(m + 1);
        dp[0] = true;
        for (int weight : stones) {
            for (int j = m; j >= weight; --j) {
                dp[j] = dp[j] || dp[j - weight];
            }
        }
        for (int j = m;; --j) {
            if (dp[j]) {
                return sum - 2 * j;
            }
        }
    }
};
```

```Java [sol2-Java]
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int weight : stones) {
            sum += weight;
        }
        int m = sum / 2;
        boolean[] dp = new boolean[m + 1];
        dp[0] = true;
        for (int weight : stones) {
            for (int j = m; j >= weight; --j) {
                dp[j] = dp[j] || dp[j - weight];
            }
        }
        for (int j = m;; --j) {
            if (dp[j]) {
                return sum - 2 * j;
            }
        }
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int LastStoneWeightII(int[] stones) {
        int sum = 0;
        foreach (int weight in stones) {
            sum += weight;
        }
        int m = sum / 2;
        bool[] dp = new bool[m + 1];
        dp[0] = true;
        foreach (int weight in stones) {
            for (int j = m; j >= weight; --j) {
                dp[j] = dp[j] || dp[j - weight];
            }
        }
        for (int j = m;; --j) {
            if (dp[j]) {
                return sum - 2 * j;
            }
        }
    }
}
```

```go [sol2-Golang]
func lastStoneWeightII(stones []int) int {
    sum := 0
    for _, v := range stones {
        sum += v
    }
    m := sum / 2
    dp := make([]bool, m+1)
    dp[0] = true
    for _, weight := range stones {
        for j := m; j >= weight; j-- {
            dp[j] = dp[j] || dp[j-weight]
        }
    }
    for j := m; ; j-- {
        if dp[j] {
            return sum - 2*j
        }
    }
}
```

```JavaScript [sol2-JavaScript]
var lastStoneWeightII = function(stones) {
    let sum = 0;
    for (const weight of stones) {
        sum += weight;
    }
    const m = Math.floor(sum / 2);
    const dp = new Array(m + 1).fill(false);
    dp[0] = true;
    for (const weight of stones) {
        for (let j = m; j >= weight; --j) {
            dp[j] = dp[j] || dp[j - weight];
        }
    }
    for (let j = m;; --j) {
        if (dp[j]) {
            return sum - 2 * j;
        }
    }
};
```

```Python [sol2-Python3]
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        total = sum(stones)
        n, m = len(stones), total // 2
        dp = [False] * (m + 1)
        dp[0] = True

        for weight in stones:
            for j in range(m, weight - 1, -1):
                dp[j] |= dp[j - weight]
        
        ans = None
        for j in range(m, -1, -1):
            if dp[j]:
                ans = total - 2 * j
                break
        
        return ans
```

```C [sol2-C]
int lastStoneWeightII(int* stones, int stonesSize) {
    int sum = 0;
    for (int i = 0; i < stonesSize; i++) {
        sum += stones[i];
    }
    int m = sum / 2;
    int dp[m + 1];
    dp[0] = true;
    for (int i = 0; i < stonesSize; ++i) {
        for (int j = m; j >= stones[i]; --j) {
            dp[j] = dp[j] || dp[j - stones[i]];
        }
    }
    for (int j = m;; --j) {
        if (dp[j]) {
            return sum - 2 * j;
        }
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n\cdot \textit{sum})$。其中 $n$ 是数组 $\textit{stones}$ 的长度，$\textit{sum}$ 为 $\textit{stones}$ 所有元素之和。

- 空间复杂度：$O(\textit{sum})$。