# 2021年06月11日 code
<a href="https://toutiao.io/k/ojtkz91">JSON 是什么</a><br /><a href="https://toutiao.io/k/x0hrwl9">一文带你深究无线缓冲 channel 的实现</a><br /><a href="https://toutiao.io/k/fi3i498">[译] Kubernetes 的自动伸缩你用对了吗？</a><br /><a href="https://toutiao.io/k/0yy5hi2">HarmonyOS 鸿蒙 App 开发真机测试以及遇到的各种坑</a><br /><a href="https://toutiao.io/k/pcu7stg">工作多年，Linux 文件系统还不太了解？</a><br /><a href="https://toutiao.io/k/0tsphq6">实操笔记：为 NSQ 配置监控服务的心路历程</a><br /><a href="https://toutiao.io/k/ix0c5uk">使用 curl 进行网站测速</a><br /><a href="https://toutiao.io/k/ylywg7x">数据管理：业务数据清洗，落地实现方案</a><br /><a href="https://toutiao.io/k/lii07l7">硅谷的数据科学家究竟是什么？</a><br /><a href="https://toutiao.io/k/8mw8b3j"> fastHttp 服务端处理请求的过程 </a><br /><a href="https://toutiao.io/k/8et5vgj">Partition 的基本概念和实现介绍</a><br /><a href="https://toutiao.io/k/xa12iyb">三张图带你弄懂 STL 中内存分配器</a><br /><a href="https://toutiao.io/k/d5ngnu7">工具 | 一个 Golang 实现全能型流量编排系统</a><br /><a href="https://toutiao.io/k/647srsl">一文理解消息队列如何保证高可用</a><br /><a href="https://toutiao.io/k/c1etzu4">字节跳动打造的轮子：Go 表单验证器</a><br /><a href="https://toutiao.io/k/m7m4s5u">一文读懂 SQL 执行计划</a><br /><a href="https://toutiao.io/k/b3kdh9y">Go timer 是如何被调度的？</a><br /><a href="https://toutiao.io/k/r9qloei">细说 Spring AOP 的核心用法和原理解析</a><br /><a href="https://toutiao.io/k/uiew0yv">比特币白皮书：简化的支付确认</a><br /><a href="https://toutiao.io/k/aawvqf9">快速上手 Linkerd v2  Service Mesh</a><br /><a href="https://toutiao.io/k/msg8jaf">[推荐] 2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你</a><br /><a href="https://toutiao.io/k/d6e55fr">[推荐] 搜狗面试题：IO 多路复用之 select、poll、epoll 的区别</a><br /><a href="https://toutiao.io/k/3xscqep">[推荐] 一文理解 Java 中的 SPI 机制</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/6tcdyp9">[推荐] Spring Boot 在 K8s 下实现优雅停机</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/b70jpzu">[推荐] 10 问 10 答：你真的了解线程池吗？</a><br /><a href="https://toutiao.io/k/qnyxbs9">[推荐] 惊！这个 Go 开源项目号称「不改一行代码做秒杀」</a><br /><a href="https://toutiao.io/k/xha1t37">[推荐] 架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/b9vlrcu">[推荐] 网络连接存在大量 time_wait 和 close_wait 的原因以及解决方法</a><br /><a href="https://toutiao.io/k/2rcud9q">[推荐] Redis 存储对象信息是用 Hash 还是 String</a><br /><a href="https://toutiao.io/k/wwmsd4f">[推荐] 学会这 10 个设计原则，离架构师又进了一步</a><br /><a href="https://toutiao.io/k/z26byeu">[推荐] 25 张图，一万字，拆解 Linux 网络包发送过程</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><hr /><a href="https://github.com/madMAx43v3r/chia-plotter"></a><br /><a href="https://github.com/TuSimple/naive-ui">A Vue 3 Component Library. Fairly Complete. Customizable Themes. Uses TypeScript. Not too Slow.</a><br /><a href="https://github.com/maaslalani/slides">Terminal based presentation tool</a><br /><a href="https://github.com/hashicorp/terraform">Terraform enables you to safely and predictably create, change, and improve infrastructure. It is an open source tool that codifies APIs into declarative configuration files that can be shared amongst team members, treated as code, edited, reviewed, and versioned.</a><br /><a href="https://github.com/Charmve/computer-vision-in-action">《计算机视觉实战演练：算法与应用》中文电子书、源码、读者交流社区（更新中，可以先 star）</a><br /><a href="https://github.com/chinnkarahoi/jd_scripts">lxk0301/jd_scripts备份。不要star。不要fork。谢谢配合。</a><br /><a href="https://github.com/apple/swift-algorithms">Commonly used sequence and collection algorithms for Swift</a><br /><a href="https://github.com/protocolbuffers/protobuf">Protocol Buffers - Google's data interchange format</a><br /><a href="https://github.com/escape2020/school2021">ESCAPE Summer School 2021</a><br /><a href="https://github.com/microsoft/playwright">Node.js library to automate Chromium, Firefox and WebKit with a single API</a><br /><a href="https://github.com/peng-zhihui/XUAN-Bike"></a><br /><a href="https://github.com/PaddlePaddle/PaddleHub">Awesome pre-trained models toolkit based on PaddlePaddle.(300+ models including Image, Text, Audio and Video with Easy Inference & Serving deployment)</a><br /><a href="https://github.com/danistefanovic/build-your-own-x">🤓 Build your own (insert technology here)</a><br /><a href="https://github.com/fmeringdal/nettu-meet">Open source video conferencing system for tutors.</a><br /><a href="https://github.com/snowpackjs/astro">🚀🧑‍🚀 Keep your eyes to the skies, astronauts!</a><br /><a href="https://github.com/PaperMC/Paper">High performance Spigot fork that aims to fix gameplay and mechanics inconsistencies</a><br /><a href="https://github.com/udacity/nd064_course_1"></a><br /><a href="https://github.com/actions/virtual-environments">GitHub Actions virtual environments</a><br /><a href="https://github.com/CaffeineMC/sodium-fabric">A Fabric mod designed to improve frame rates and reduce micro-stutter</a><br /><a href="https://github.com/OATML/non-parametric-transformers">Code for "Self-Attention Between Datapoints: Going Beyond Individual Input-Output Pairs in Deep Learning"</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/iamadamdev/bypass-paywalls-chrome">Bypass Paywalls web browser extension for Chrome and Firefox.</a><br /><a href="https://github.com/facebook/folly">An open-source C++ library developed and used at Facebook.</a><br /><a href="https://github.com/PaddlePaddle/PaddleNLP">An NLP library with Awesome pre-trained Transformer models and easy-to-use interface, supporting wide-range of NLP tasks from research to industrial applications.</a><br /><a href="https://github.com/peng-zhihui/HoloCubic">带网络功能的伪全息透明显示桌面站</a><br /><hr />完全平方数<br /><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于<em> n</em>。你需要让组成和的完全平方数的个数最少。</p>

<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p>

<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = <code>12</code>
<strong>输出：</strong>3 
<strong>解释：</strong><code>12 = 4 + 4 + 4</code></pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = <code>13</code>
<strong>输出：</strong>2
<strong>解释：</strong><code>13 = 4 + 9</code></pre>
 

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= n <= 10<sup>4</sup></code></li>
</ul>
<br />#### 方法一：动态规划

**思路及算法**

我们可以依据题目的要求写出状态表达式：$f[i]$ 表示最少需要多少个数的平方来表示整数 $i$。

这些数必然落在区间 $[1,\sqrt{n}]$。我们可以枚举这些数，假设当前枚举到 $j$，那么我们还需要取若干数的平方，构成 $i-j^2$。此时我们发现该子问题和原问题类似，只是规模变小了。这符合了动态规划的要求，于是我们可以写出状态转移方程。

$$
f[i]=1+\min_{j=1}^{\lfloor\sqrt{i}\rfloor}{f[i-j^2]}
$$

其中 $f[0]=0$ 为边界条件，实际上我们无法表示数字 $0$，只是为了保证状态转移过程中遇到 $j$ 恰为 $\sqrt{i}$ 的情况合法。

同时因为计算 $f[i]$ 时所需要用到的状态仅有 $f[i-j^2]$，必然小于 $i$，因此我们只需要从小到大地枚举 $i$ 来计算 $f[i]$ 即可。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int numSquares(int n) {
        vector<int> f(n + 1);
        for (int i = 1; i <= n; i++) {
            int minn = INT_MAX;
            for (int j = 1; j * j <= i; j++) {
                minn = min(minn, f[i - j * j]);
            }
            f[i] = minn + 1;
        }
        return f[n];
    }
};
```

```Java [sol1-Java]
class Solution {
    public int numSquares(int n) {
        int[] f = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int minn = Integer.MAX_VALUE;
            for (int j = 1; j * j <= i; j++) {
                minn = Math.min(minn, f[i - j * j]);
            }
            f[i] = minn + 1;
        }
        return f[n];
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int NumSquares(int n) {
        int[] f = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            int minn = int.MaxValue;
            for (int j = 1; j * j <= i; j++) {
                minn = Math.Min(minn, f[i - j * j]);
            }
            f[i] = minn + 1;
        }
        return f[n];
    }
}
```

```go [sol1-Golang]
func numSquares(n int) int {
    f := make([]int, n+1)
    for i := 1; i <= n; i++ {
        minn := math.MaxInt32
        for j := 1; j*j <= i; j++ {
            minn = min(minn, f[i-j*j])
        }
        f[i] = minn + 1
    }
    return f[n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```JavaScript [sol1-JavaScript]
var numSquares = function(n) {
    const f = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        let minn = Number.MAX_VALUE;
        for (let j = 1; j * j <= i; j++) {
            minn = Math.min(minn, f[i - j * j]);
        }
        f[i] = minn + 1;
    }
    return f[n];
};
```

```C [sol1-C]
int numSquares(int n) {
    int f[n + 1];
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        int minn = INT_MAX;
        for (int j = 1; j * j <= i; j++) {
            minn = fmin(minn, f[i - j * j]);
        }
        f[i] = minn + 1;
    }
    return f[n];
}
```

**复杂度分析**

- 时间复杂度：$O(n\sqrt{n})$，其中 $n$ 为给定的正整数。状态转移方程的时间复杂度为 $O(\sqrt{n})$，共需要计算 $n$ 个状态，因此总时间复杂度为 $O(n \sqrt{n})$。

- 空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间保存状态。

#### 方法二：数学

**思路及算法**

一个数学定理可以帮助解决本题：「[四平方和定理](https://baike.baidu.com/item/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86)」。

四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。

同时四平方和定理包含了一个更强的结论：当且仅当 $n \neq 4^k \times (8m+7)$ 时，$n$ 可以被表示为至多三个正整数的平方和。因此，当 $n = 4^k \times (8m+7)$ 时，$n$ 只能被表示为四个正整数的平方和。此时我们可以直接返回 $4$。

当 $n \neq 4^k \times (8m+7)$ 时，我们需要判断到底多少个完全平方数能够表示 $n$，我们知道答案只会是 $1,2,3$ 中的一个：

- 答案为 $1$ 时，则必有 $n$ 为完全平方数，这很好判断；

- 答案为 $2$ 时，则有 $n=a^2+b^2$，我们只需要枚举所有的 $a(1 \leq a \leq \sqrt{n})$，判断 $n-a^2$ 是否为完全平方数即可；

- 答案为 $3$ 时，我们很难在一个优秀的时间复杂度内解决它，但我们只需要检查答案为 $1$ 或 $2$ 的两种情况，即可利用排除法确定答案。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    // 判断是否为完全平方数
    bool isPerfectSquare(int x) {
        int y = sqrt(x);
        return y * y == x;
    }

    // 判断是否能表示为 4^k*(8m+7)
    bool checkAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }

    int numSquares(int n) {
        if (isPerfectSquare(n)) {
            return 1;
        }
        if (checkAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (isPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }
};
```

```Java [sol2-Java]
class Solution {
    public int numSquares(int n) {
        if (isPerfectSquare(n)) {
            return 1;
        }
        if (checkAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (isPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }

    // 判断是否为完全平方数
    public boolean isPerfectSquare(int x) {
        int y = (int) Math.sqrt(x);
        return y * y == x;
    }

    // 判断是否能表示为 4^k*(8m+7)
    public boolean checkAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int NumSquares(int n) {
        if (IsPerfectSquare(n)) {
            return 1;
        }
        if (CheckAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (IsPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }

    // 判断是否为完全平方数
    public bool IsPerfectSquare(int x) {
        int y = (int) Math.Sqrt(x);
        return y * y == x;
    }

    // 判断是否能表示为 4^k*(8m+7)
    public bool CheckAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }
}
```

```go [sol2-Golang]
// 判断是否为完全平方数
func isPerfectSquare(x int) bool {
    y := int(math.Sqrt(float64(x)))
    return y*y == x
}

// 判断是否能表示为 4^k*(8m+7)
func checkAnswer4(x int) bool {
    for x%4 == 0 {
        x /= 4
    }
    return x%8 == 7
}

func numSquares(n int) int {
    if isPerfectSquare(n) {
        return 1
    }
    if checkAnswer4(n) {
        return 4
    }
    for i := 1; i*i <= n; i++ {
        j := n - i*i
        if isPerfectSquare(j) {
            return 2
        }
    }
    return 3
}
```

```JavaScript [sol2-JavaScript]
var numSquares = function(n) {
    if (isPerfectSquare(n)) {
        return 1;
    }
    if (checkAnswer4(n)) {
        return 4;
    }
    for (let i = 1; i * i <= n; i++) {
        let j = n - i * i;
        if (isPerfectSquare(j)) {
            return 2;
        }
    }
    return 3;
}

// 判断是否为完全平方数
const isPerfectSquare = (x) => {
    const y = Math.floor(Math.sqrt(x));
    return y * y == x;
}

// 判断是否能表示为 4^k*(8m+7)
const checkAnswer4 = (x) => {
    while (x % 4 == 0) {
        x /= 4;
    }
    return x % 8 == 7;
}
```

```C [sol1-C]
// 判断是否为完全平方数
bool isPerfectSquare(int x) {
    int y = sqrt(x);
    return y * y == x;
}

// 判断是否能表示为 4^k*(8m+7)
bool checkAnswer4(int x) {
    while (x % 4 == 0) {
        x /= 4;
    }
    return x % 8 == 7;
}

int numSquares(int n) {
    if (isPerfectSquare(n)) {
        return 1;
    }
    if (checkAnswer4(n)) {
        return 4;
    }
    for (int i = 1; i * i <= n; i++) {
        int j = n - i * i;
        if (isPerfectSquare(j)) {
            return 2;
        }
    }
    return 3;
}
```

**复杂度分析**

- 时间复杂度：$O(\sqrt{n})$，其中 $n$ 为给定的正整数。最坏情况下答案为 $3$，我们需要运行所有的判断，而判断答案是否为 $1$ 的时间复杂度为 $O(1)$，判断答案是否为 $4$ 的时间复杂度为 $O(\log n)$，剩余判断为 $O(\sqrt n)$，因此总时间复杂度为 $O(\log n + \sqrt n) = O(\sqrt n)$。

- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。