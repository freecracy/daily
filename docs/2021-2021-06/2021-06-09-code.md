# 2021年06月09日 code
<a href="https://toutiao.io/k/a3gplbq">一文理解 Redis 底层数据结构</a><br /><a href="https://toutiao.io/k/85kvlje">面试题：MySQL 一棵 B+ 树能存多少条数据？</a><br /><a href="https://toutiao.io/k/0qku0g2">故事篇：终于给老婆讲明白什么是 Logback 了</a><br /><a href="https://toutiao.io/k/8jbq0n3">一个地区问题引发的一些列思考</a><br /><a href="https://toutiao.io/k/jpbyt2n">被同事嘲笑说技术方案没深度？</a><br /><a href="https://toutiao.io/k/s9it7l1">Reactive Spring 实战：理解 Reactor 的设计与实现</a><br /><a href="https://toutiao.io/k/qqf7d1s">Flutter 实现视频全屏播放逻辑及解析</a><br /><a href="https://toutiao.io/k/udlyg9t">通过扩展 Spark SQL ，打造自己的大数据分析引擎</a><br /><a href="https://toutiao.io/k/08kxgoe">用实例带你了解 MySQL 全局锁</a><br /><a href="https://toutiao.io/k/55edatn">独立开发变现周刊（第 5 期）: Notion Api 终于开放公测啦</a><br /><a href="https://toutiao.io/k/ycuatas">谈谈写作与写作的意义</a><br /><a href="https://toutiao.io/k/j07hhc5">在容器里设置 GOMAXPROCS 的正确姿势</a><br /><a href="https://toutiao.io/k/r91to63">目标检测干货：多级特征重复使用大幅度提升检测精度</a><br /><a href="https://toutiao.io/k/g5opeyo">Transaction 的基本概念和介绍</a><br /><a href="https://toutiao.io/k/9di26jb">58 个 UI & UX  小知识提升你的设计能力</a><br /><a href="https://toutiao.io/k/1sk3kth">如何从 Java 字节码分析解决问题</a><br /><a href="https://toutiao.io/k/ta727ns">你的扫描器可以绕过防火墙么？（一）</a><br /><a href="https://toutiao.io/k/cy5qrj0">你不知道的 VSCode 代码高亮原理</a><br /><a href="https://toutiao.io/k/3y7w1bo">[译] 在 Kubernetes 上使用 Spinnaker 构建部署流水线</a><br /><a href="https://toutiao.io/k/1ebdl4v">工具 | 广泛投产于腾讯广告后台的现代化 C++ 开发框架</a><br /><a href="https://toutiao.io/k/a0hyfb5">解析 HTTP 协议实现文件上传</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/d6e55fr">[推荐] 搜狗面试题：IO 多路复用之 select、poll、epoll 的区别</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/b70jpzu">[推荐] 10 问 10 答：你真的了解线程池吗？</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/2rcud9q">[推荐] Redis 存储对象信息是用 Hash 还是 String</a><br /><a href="https://toutiao.io/k/msg8jaf">[推荐] 2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你</a><br /><a href="https://toutiao.io/k/wwmsd4f">[推荐] 学会这 10 个设计原则，离架构师又进了一步</a><br /><a href="https://toutiao.io/k/3tudqnj">[推荐] 做一次黑客，入侵一次服务器</a><br /><a href="https://toutiao.io/k/jwzcso7">[推荐] 字节跳动异构场景下的高可用建设实践</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/xha1t37">[推荐] 架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/ybiw04u">[推荐] 高并发、高性能、高可用系统设计经验</a><br /><hr /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/escape2020/school2021">ESCAPE Summer School 2021</a><br /><a href="https://github.com/facebook/folly">An open-source C++ library developed and used at Facebook.</a><br /><a href="https://github.com/jhu-ep-coursera/fullstack-course4">Example code for HTML, CSS, and Javascript for Web Developers Coursera Course</a><br /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Beta)</a><br /><a href="https://github.com/TuSimple/naive-ui">A Vue 3 Component Library. Fairly Complete. Customizable Themes. Uses Typescript. Not too Slow.</a><br /><a href="https://github.com/mattnotmax/cyberchef-recipes">A list of cyber-chef recipes and curated links</a><br /><a href="https://github.com/taosdata/TDengine">An open-source big data platform designed and optimized for the Internet of Things (IoT).</a><br /><a href="https://github.com/Charmve/computer-vision-in-action">《计算机视觉实战演练：算法与应用》中文电子书、源码、读者交流社区（更新中，可以先 star）</a><br /><a href="https://github.com/PaddlePaddle/PaddleNLP">An NLP library with Awesome pre-trained Transformer models and easy-to-use interface, supporting wide-range of NLP tasks from research to industrial applications.</a><br /><a href="https://github.com/peng-zhihui/XUAN-Bike"></a><br /><a href="https://github.com/jlevy/the-art-of-command-line">Master the command line, in one page</a><br /><a href="https://github.com/ekzhang/rustpad">Efficient and minimal collaborative code editor, self-hosted, no database required</a><br /><a href="https://github.com/electron/electron">Build cross-platform desktop apps with JavaScript, HTML, and CSS</a><br /><a href="https://github.com/firstcontributions/first-contributions">🚀✨ Help beginners to contribute to open source projects</a><br /><a href="https://github.com/KibaeKim/SectorTradingAlgorithm"></a><br /><a href="https://github.com/login?return_to=%2Fpedronauck%2Fdocz">✍ It has never been so easy to document your things!</a><br /><a href="https://github.com/hasherezade/transacted_hollowing">Transacted Hollowing - a PE injection technique, hybrid between ProcessHollowing and ProcessDoppelgänging</a><br /><a href="https://github.com/ParthJadhav/Tkinter-Designer">Create Beautiful Tkinter GUIs by Drag and Drop ☄️</a><br /><a href="https://github.com/maaslalani/slides">Terminal based presentation tool</a><br /><a href="https://github.com/login?return_to=%2Fdeepfakes%2Ffaceswap">Deepfakes Software For All</a><br /><a href="https://github.com/renovatebot/renovate">Universal dependency update tool that fits into your workflows.</a><br /><a href="https://github.com/chubin/cheat.sh">the only cheat sheet you need</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/danistefanovic/build-your-own-x">🤓 Build your own (insert technology here)</a><br /><hr />盈利计划<br /><p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>

<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>

<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>

<p>有多少种计划可以选择？因为答案很大，所以<strong> 返回结果模 </strong><code>10^9 + 7</code><strong> 的值</strong>。</p>

<div class="original__bRMd">
<div>
<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]
<strong>输出：</strong>2
<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
<strong>输出：</strong>7
<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</pre>
</div>
</div>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= n <= 100</code></li>
	<li><code>0 <= minProfit <= 100</code></li>
	<li><code>1 <= group.length <= 100</code></li>
	<li><code>1 <= group[i] <= 100</code></li>
	<li><code>profit.length == group.length</code></li>
	<li><code>0 <= profit[i] <= 100</code></li>
</ul>
<br />#### 方法一：动态规划

本题与经典背包问题非常相似。两者不同点在于经典背包问题只有一种容量限制，而本题却有两种限制：集团员工人数上限 $n$，以及工作产生的利润下限 $\textit{minProfit}$。

通过经典背包问题的练习，我们已知经典背包问题可以使用二维动态规划求解：两个维度分别代表物品和容量的限制标准。对于本题上述的两种限制，我们可以想到使用三维动态规划求解。本题解法的三个维度分别为：当前**可选择**的工作，**已选择**的小组员工人数，以及**目前状态的工作获利下限**。

根据上述分析，我们可以定义一个三维数组 $\textit{dp}$ 作为动态规划的状态，其中 $\textit{dp}[i][j][k]$ 表示在前 $i$ 个工作中选择了 $j$ 个员工，并且满足工作利润至少为 $k$ 的情况下的盈利计划的总数目。假设 $\textit{group}$ 数组长度为 $\textit{len}$，那么不考虑取模运算的情况下，最终答案为：

$$
\sum_{i=0}^{n}\textit{dp}[\textit{len}][i][\textit{minProfit}]
$$

所以我们可以新建一个三维数组 $\textit{dp}[\textit{len} + 1][n + 1][\textit{minProfit} + 1]$，初始化 $\textit{dp}[0][0][0] = 1$。接下来分析状态转移方程，对于每个工作 $i$，我们根据当前工作人数上限 $j$，有**能够开展当前工作**和**无法开展当前工作**两种情况：

- 如果无法开展当前工作 $i$，那么显然：

    $$
    \textit{dp}[i][j][k] = \textit{dp}[i - 1][j][k]
    $$

- 如果能够开展当前工作 $i$，设当前小组人数为 $\textit{group}[i]$，工作获利为 $\textit{profit}[i]$，那么不考虑取模运算的情况下，则有：

    $$
    \textit{dp}[i][j][k] = \textit{dp}[i - 1][j][k] + \textit{dp}[i - 1][j - \textit{group}[i]][\max(0, k - \textit{profit}[i])]
    $$

由于我们定义的第三维是**工作利润至少为 $k$** 而不是 **工作利润恰好为 $k$**，因此上述状态转移方程中右侧的第三维是 $\max(0, k - \textit{profit}[i])$ 而不是 $k - \textit{profit}[i]$。读者可以思考这一步的妙处所在。

根据上述思路，参考代码如下：

```Java [sol11-Java]
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int len = group.length, MOD = (int)1e9 + 7;
        int[][][] dp = new int[len + 1][n + 1][minProfit + 1];
        dp[0][0][0] = 1;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    if (j < members) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][Math.max(0, k - earn)]) % MOD;
                    }
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= n; j++) {
            sum = (sum + dp[len][j][minProfit]) % MOD;
        }
        return sum;
    }
}
```

```C# [sol11-C#]
public class Solution {
    public int ProfitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int len = group.Length, MOD = (int)1e9 + 7;
        int[,,] dp = new int[len + 1, n + 1, minProfit + 1];
        dp[0, 0, 0] = 1;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    if (j < members) {
                        dp[i, j, k] = dp[i - 1, j, k];
                    } else {
                        dp[i, j, k] = (dp[i - 1, j, k] + dp[i - 1, j - members, Math.Max(0, k - earn)]) % MOD;
                    }
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= n; j++) {
            sum = (sum + dp[len, j, minProfit]) % MOD;
        }
        return sum;
    }
}
```

```JavaScript [sol11-JavaScript]
var profitableSchemes = function(n, minProfit, group, profit) {
    const len = group.length, MOD = 1e9 + 7;
    const dp = new Array(len + 1).fill(0).map(() => new Array(n + 1).fill(0).map(() => new Array(minProfit + 1).fill(0)));
    dp[0][0][0] = 1;
    for (let i = 1; i <= len; i++) {
        const members = group[i - 1], earn = profit[i - 1];
        for (let j = 0; j <= n; j++) {
            for (let k = 0; k <= minProfit; k++) {
                if (j < members) {
                    dp[i][j][k] = dp[i - 1][j][k];
                } else {
                    dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][Math.max(0, k - earn)]) % MOD;
                }
            }
        }
    }
    let sum = 0;
    for (let j = 0; j <= n; j++) {
        sum = (sum + dp[len][j][minProfit]) % MOD;
    }
    return sum;
};
```

```Python [sol11-Python3]
class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        MOD = 10**9 + 7
        
        length = len(group)
        dp = [[[0] * (minProfit + 1) for _ in range(n + 1)] for _ in range(length + 1)]
        dp[0][0][0] = 1
        for i in range(1, length + 1):
            members, earn = group[i - 1], profit[i - 1]
            for j in range(n + 1):
                for k in range(minProfit + 1):
                    if j < members:
                        dp[i][j][k] = dp[i - 1][j][k]
                    else:
                        dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][max(0, k - earn)]) % MOD
        
        total = sum(dp[length][j][minProfit] for j in range(n + 1))
        return total % MOD
```

```C++ [sol11-C++]
class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        int len = group.size(), MOD = (int)1e9 + 7;
        vector<vector<vector<int>>> dp(len + 1, vector<vector<int>>(n + 1, vector<int>(minProfit + 1)));
        dp[0][0][0] = 1;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    if (j < members) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][max(0, k - earn)]) % MOD;
                    }
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= n; j++) {
            sum = (sum + dp[len][j][minProfit]) % MOD;
        }
        return sum;
    }
};
```

```C [sol11-C]
int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize) {
    int len = groupSize, MOD = (int)1e9 + 7;
    int dp[len + 1][n + 1][minProfit + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0][0] = 1;
    for (int i = 1; i <= len; i++) {
        int members = group[i - 1], earn = profit[i - 1];
        for (int j = 0; j <= n; j++) {
            for (int k = 0; k <= minProfit; k++) {
                if (j < members) {
                    dp[i][j][k] = dp[i - 1][j][k];
                } else {
                    dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][(int)fmax(0, k - earn)]) % MOD;
                }
            }
        }
    }
    int sum = 0;
    for (int j = 0; j <= n; j++) {
        sum = (sum + dp[len][j][minProfit]) % MOD;
    }
    return sum;
}
```

```go [sol11-Golang]
func profitableSchemes(n, minProfit int, group, profit []int) (sum int) {
    const mod int = 1e9 + 7
    ng := len(group)
    dp := make([][][]int, ng+1)
    for i := range dp {
        dp[i] = make([][]int, n+1)
        for j := range dp[i] {
            dp[i][j] = make([]int, minProfit+1)
        }
    }
    dp[0][0][0] = 1
    for i, members := range group {
        earn := profit[i]
        for j := 0; j <= n; j++ {
            for k := 0; k <= minProfit; k++ {
                if j < members {
                    dp[i+1][j][k] = dp[i][j][k]
                } else {
                    dp[i+1][j][k] = (dp[i][j][k] + dp[i][j-members][max(0, k-earn)]) % mod
                }
            }
        }
    }
    for _, d := range dp[ng] {
        sum = (sum + d[minProfit]) % mod
    }
    return
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

可以发现 $\textit{dp}[i][j][k]$ 仅与 $\textit{dp}[i - 1][..][..]$ 有关，所以本题可以用二维动态规划解决。当采用二维动态规划解法时，对于最小工作利润为 $0$ 的情况，无论当前在工作的员工有多少人，我们总能提供一种方案，所以初始化 $\textit{dp}[i][0] = 1$。此外，降维之后 $\textit{dp}$ 数组的遍历顺序应为**逆序**，与背包问题降维解法类似，因为这样才能保证求状态 $\textit{dp}[j][k]$ 时, 用到的 $\textit{dp}[j - \textit{members}][\max(0, k - \textit{earn})]$ **是上一时刻的值**，而正序遍历则会改写该值。参考代码如下：

```Java [sol12-Java]
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int[][] dp = new int[n + 1][minProfit + 1];
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        int len = group.length, MOD = (int)1e9 + 7;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = n; j >= members; j--) {
                for (int k = minProfit; k >= 0; k--) {
                    dp[j][k] = (dp[j][k] + dp[j - members][Math.max(0, k - earn)]) % MOD;
                }
            }
        }
        return dp[n][minProfit];
    }
}
```

```C# [sol12-C#]
public class Solution {
    public int ProfitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int[,] dp = new int[n + 1, minProfit + 1];
        for (int i = 0; i <= n; i++) {
            dp[i, 0] = 1;
        }
        int len = group.Length, MOD = (int)1e9 + 7;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = n; j >= members; j--) {
                for (int k = minProfit; k >= 0; k--) {
                    dp[j, k] = (dp[j, k] + dp[j - members, Math.Max(0, k - earn)]) % MOD;
                }
            }
        }
        return dp[n, minProfit];
    }
}
```

```Python [sol12-Python3]
class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        MOD = 10**9 + 7
        dp = [[0] * (minProfit + 1) for _ in range(n + 1)]
        for i in range(0, n + 1):
            dp[i][0] = 1
        for earn, members in zip(profit, group):
            for j in range(n, members - 1, -1):
                for k in range(minProfit, -1, -1):
                    dp[j][k] = (dp[j][k] + dp[j - members][max(0, k - earn)]) % MOD;
        return dp[n][minProfit]
```

```JavaScript [sol12-JavaScript]
var profitableSchemes = function(n, minProfit, group, profit) {
    const dp = new Array(n + 1).fill(0).map(() => new Array(minProfit + 1).fill(0));
    for (let i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }
    const len = group.length, MOD = 1e9 + 7;
    for (let i = 1; i <= len; i++) {
        const members = group[i - 1], earn = profit[i - 1];
        for (let j = n; j >= members; j--) {
            for (let k = minProfit; k >= 0; k--) {
                dp[j][k] = (dp[j][k] + dp[j - members][Math.max(0, k - earn)]) % MOD;
            }
        }
    }
    return dp[n][minProfit];
};
```

```C++ [sol12-C++]
class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1));
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        int len = group.size(), MOD = (int)1e9 + 7;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = n; j >= members; j--) {
                for (int k = minProfit; k >= 0; k--) {
                    dp[j][k] = (dp[j][k] + dp[j - members][max(0, k - earn)]) % MOD;
                }
            }
        }
        return dp[n][minProfit];
    }
};
```

```C [sol12-C]
int profitableSchemes(int n, int minProfit, int* group, int groupSize, int* profit, int profitSize) {
    int dp[n + 1][minProfit + 1];
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }
    int len = groupSize, MOD = (int)1e9 + 7;
    for (int i = 1; i <= len; i++) {
        int members = group[i - 1], earn = profit[i - 1];
        for (int j = n; j >= members; j--) {
            for (int k = minProfit; k >= 0; k--) {
                dp[j][k] = (dp[j][k] + dp[j - members][(int)fmax(0, k - earn)]) % MOD;
            }
        }
    }
    return dp[n][minProfit];
}
```

```go [sol12-Golang]
func profitableSchemes(n, minProfit int, group, profit []int) (sum int) {
    const mod int = 1e9 + 7
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, minProfit+1)
        dp[i][0] = 1
    }
    for i, members := range group {
        earn := profit[i]
        for j := n; j >= members; j-- {
            for k := minProfit; k >= 0; k-- {
                dp[j][k] = (dp[j][k] + dp[j-members][max(0, k-earn)]) % mod
            }
        }
    }
    return dp[n][minProfit]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**复杂度分析**

- 时间复杂度：$O(\textit{len} \times n \times \textit{minProfit})$，其中 $\textit{len}$ 为数组 $\textit{group}$ 的长度。
    动态规划需要计算的状态总数是 $O(\textit{len} \times n \times \textit{minProfit})$，每个状态的值需要 $O(1)$ 的时间计算。

- 空间复杂度：$O(n \times \textit{minProfit})$。
    使用空间优化的实现，需要创建 $n + 1$ 行，$\textit{minProfit} + 1$ 列的二维数组 $\textit{dp}$。