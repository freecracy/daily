# 2021年06月12日 code
<a href="https://toutiao.io/k/5vic46a">Nacos 配置中心模块详解</a><br /><a href="https://toutiao.io/k/yg6hxci">没源码怎么排查问题？Arthas 暴力内存搜索对象解决</a><br /><a href="https://toutiao.io/k/yzi0j3y">微信小程序基础架构浅析</a><br /><a href="https://toutiao.io/k/mjupr57">云原生究竟是什么</a><br /><a href="https://toutiao.io/k/wf7tswe">分享两个在开发中需注意的小点</a><br /><a href="https://toutiao.io/k/p6kqiun">漫画：前端发展史的江湖恩怨情仇</a><br /><a href="https://toutiao.io/k/avka7pr">前端插件式可扩展架构设计心得</a><br /><a href="https://toutiao.io/k/bqc2l84">一文理解分布式锁的实现方式</a><br /><a href="https://toutiao.io/k/15c6my9">深度剖析：Redis 分布式锁到底安全吗？看完这篇文章彻底懂了</a><br /><a href="https://toutiao.io/k/ou5zrk7">手写一个 JSON 反序列化程序</a><br /><a href="https://toutiao.io/k/qn3eavy">活动预告｜【Coder Park】MobTech 携手阿里聚焦大数据架构</a><br /><a href="https://toutiao.io/k/1yxojyo">[译] 以和为贵！让 ESlint、Prettier 和 EditorConfig 互不冲突</a><br /><a href="https://toutiao.io/k/o4mipdz">基于 SQL Server Change Tracking 实现宽表的增量更新</a><br /><a href="https://toutiao.io/k/ics57qv">如何避免慢 SQL（一）：构建稳定健壮的统一查询平台</a><br /><a href="https://toutiao.io/k/vuji3tb">Spring Cloud Alibaba 实战（三）：存储设计与基础架构设计</a><br /><a href="https://toutiao.io/k/91u91qs">当 AI 遇上品牌营销内容：图像篇</a><br /><a href="https://toutiao.io/k/z43mm43">C++：再谈 STL reserve 的坑</a><br /><a href="https://toutiao.io/k/edrqlk5">手把手教你实现 Android 开发中的 3D 卡片翻转效果</a><br /><a href="https://toutiao.io/k/393615n">你的扫描器可以绕过防火墙么？（二）</a><br /><a href="https://toutiao.io/k/00g96ki">[译] 72 个网络应用安全实操要点，全方位保护你的 Web 应用</a><br /><a href="https://toutiao.io/k/wwmsd4f">[推荐] 学会这 10 个设计原则，离架构师又进了一步</a><br /><a href="https://toutiao.io/k/z26byeu">[推荐] 25 张图，一万字，拆解 Linux 网络包发送过程</a><br /><a href="https://toutiao.io/k/2rcud9q">[推荐] Redis 存储对象信息是用 Hash 还是 String</a><br /><a href="https://toutiao.io/k/msg8jaf">[推荐] 2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你</a><br /><a href="https://toutiao.io/k/d6e55fr">[推荐] 搜狗面试题：IO 多路复用之 select、poll、epoll 的区别</a><br /><a href="https://toutiao.io/k/qnyxbs9">[推荐] 惊！这个 Go 开源项目号称「不改一行代码做秒杀」</a><br /><a href="https://toutiao.io/k/xha1t37">[推荐] 架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/3xscqep">[推荐] 一文理解 Java 中的 SPI 机制</a><br /><a href="https://toutiao.io/k/b9vlrcu">[推荐] 网络连接存在大量 time_wait 和 close_wait 的原因以及解决方法</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/a3gplbq">[推荐] 一文理解 Redis 底层数据结构</a><br /><a href="https://toutiao.io/k/6tcdyp9">[推荐] Spring Boot 在 K8s 下实现优雅停机</a><br /><a href="https://toutiao.io/k/85kvlje">[推荐] 面试题：MySQL 一棵 B+ 树能存多少条数据？</a><br /><a href="https://toutiao.io/k/ow2rhiz">[推荐] Linux 调度系统全景指南（终结篇）</a><br /><a href="https://toutiao.io/k/b70jpzu">[推荐] 10 问 10 答：你真的了解线程池吗？</a><br /><hr /><a href="https://github.com/madMAx43v3r/chia-plotter"></a><br /><a href="https://github.com/peng-zhihui/XUAN-Bike"></a><br /><a href="https://github.com/kingoflolz/mesh-transformer-jax">Model parallel transformers in JAX and Haiku</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/microsoft/playwright">Node.js library to automate Chromium, Firefox and WebKit with a single API</a><br /><a href="https://github.com/zzanehip/The-OldOS-Project">Recreating a fully functional version of iOS 4 in SwiftUI.</a><br /><a href="https://github.com/TuSimple/naive-ui">A Vue 3 Component Library. Fairly Complete. Customizable Themes. Uses TypeScript. Not too Slow.</a><br /><a href="https://github.com/login?return_to=%2Fdrawrowfly%2Ftiktok-scraper">TikTok Scraper. Download video posts, collect user/trend/hashtag/music feed metadata, sign URL and etc.</a><br /><a href="https://github.com/reactwg/react-18">Workgroup for React 18 release.</a><br /><a href="https://github.com/chinnkarahoi/jd_scripts">lxk0301/jd_scripts备份。不要star。不要fork。谢谢配合。</a><br /><a href="https://github.com/lan-tianxiang/jd_shell">Node网页开发工具</a><br /><a href="https://github.com/spring-projects/spring-boot">Spring Boot</a><br /><a href="https://github.com/Charmve/computer-vision-in-action">《计算机视觉实战演练：算法与应用》中文电子书、源码、读者交流社区（更新中，可以先 star）</a><br /><a href="https://github.com/google/googletest">GoogleTest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/maaslalani/slides">Terminal based presentation tool</a><br /><a href="https://github.com/actions/virtual-environments">GitHub Actions virtual environments</a><br /><a href="https://github.com/lan-tianxiang/JS_TOOL">Node网页开发工具</a><br /><a href="https://github.com/whyour/qinglong">Ant Design、Ant Design Pro 与 Umijs3.0 项目and暗黑主题实践（Crontab定时运行Python和JavaScript的Dashboard）</a><br /><a href="https://github.com/mechaniac/Map-of-Javascript">Javascript on one sheet. (and one for algorithms)</a><br /><a href="https://github.com/GuoxianSong/AgileGAN">Official repo for paper "AgileGAN: Stylizing Portraits by Inversion-Consistent Transfer Learning"</a><br /><a href="https://github.com/goldbergyoni/nodebestpractices">✅ The Node.js best practices list (June 2021)</a><br /><a href="https://github.com/hasura/graphql-engine">Blazing fast, instant realtime GraphQL APIs on your DB with fine grained access control, also trigger webhooks on database events.</a><br /><a href="https://github.com/actions/starter-workflows">Accelerating new GitHub Actions workflows</a><br /><a href="https://github.com/datastaxdevs/workshop-graphql-netflix">Workshop to illustrate how to use GraphQL</a><br /><a href="https://github.com/PaperMC/Paper">High performance Spigot fork that aims to fix gameplay and mechanics inconsistencies</a><br /><hr />数位成本和为目标值的最大数字<br /><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>

<ul>
	<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li>
	<li>总成本必须恰好等于 <code>target</code> 。</li>
	<li>添加的数位中没有数字 0 。</li>
</ul>

<p>由于答案可能会很大，请你以字符串形式返回。</p>

<p>如果按照上述要求无法得到任何整数，请你返回 "0" 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9
<strong>输出：</strong>"7772"
<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
<strong> 数字     成本</strong>
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12
<strong>输出：</strong>"85"
<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5
<strong>输出：</strong>"0"
<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47
<strong>输出：</strong>"32211"
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>cost.length == 9</code></li>
	<li><code>1 <= cost[i] <= 5000</code></li>
	<li><code>1 <= target <= 5000</code></li>
</ul>
<br />#### 方法一：动态规划

若两个整数位数不同，位数更多的整数必然大于位数小的整数。因此我们需要先计算出可以得到的整数的最大位数。

该问题可以看作是**恰好**装满背包容量为 $\textit{target}$，物品重量为 $\textit{cost}[i]$，价值为 $1$ 的完全背包问题。

对于该问题，定义二维数组 $\textit{dp}$，其中 $\textit{dp}[i+1][j]$ 表示使用前 $i$ 个数位且花费总成本**恰好**为 $j$ 时的最大位数，若花费总成本无法为 $j$，则规定其为 $-\infty$。特别地，$\textit{dp}[0][]$ 为不选任何数位的状态，因此除了 $\textit{dp}[0][0]$ 为 $0$，其余 $\textit{dp}[0][j]$ 全为 $-\infty$。

对于第 $i$ 个数位，考虑花费总成本恰好为 $j$ 时的状态转移：

- 若 $j<\textit{cost}[i]$，则无法选第 $i$ 个数位，此时有 $\textit{dp}[i+1][j]=\textit{dp}[i][j]$；
- 若 $j\ge \textit{cost}[i]$，存在选或不选两种决策，不选时有 $\textit{dp}[i+1][j]=\textit{dp}[i][j]$，选时由于第 $i$ 个数位可以重复选择，可以从使用前 $i$ 个数位且花费总成本恰好为 $j-\textit{cost}[i]$ 的状态转移过来，即 $\textit{dp}[i+1][j]=\textit{dp}[i+1][j-\textit{cost}[i]]+1$。取这两种决策的最大值。
      
因此状态转移方程为：

$$
\textit{dp}[i+1][j]=
\begin{cases}
\textit{dp}[i][j],& j<\textit{cost}[i] \\
\max(\textit{dp}[i][j],\textit{dp}[i+1][j-\textit{cost}[i]]+1), & j\ge \textit{cost}[i]
\end{cases}
$$

$\textit{dp}[9][target]$ 即为可以得到的整数的最大位数，若其小于 $0$ 则说明我们无法得到满足要求的整数，返回 $\texttt{"0"}$。否则，我们需要生成一个整数，其位数为 $\textit{dp}[9][target]$ 且数值最大。

为了生成该整数，我们可以用一个额外的二维数组 $\textit{from}$，在状态转移时记录转移来源。这样我们可以从最终状态 $\textit{dp}[9][target]$ 顺着 $\textit{from}$ 不断倒退，直至达到起始状态 $\textit{dp}[0][0]$。在倒退状态时，若转移来源是 $\textit{dp}[i+1][j-\textit{cost}[i]]$ 则说明我们选取了第 $i$ 个数位。

根据转移方程：

- 若 $j<\textit{cost}[i]$，有 $\textit{from}[i+1][j]=j$；
- 若 $j\ge \textit{cost}[i]$，当 $\textit{dp}[i][j]>\textit{dp}[i+1][j-\textit{cost}[i]]+1$ 时有 $\textit{from}[i+1][j]=j$，否则有 $\textit{from}[i+1][j]=j-\textit{cost}[i]$。

注意我们并没有记录转移来源是 $i$ 还是 $i+1$，这是因为若 $\textit{from}[i+1][j]$ 的值为 $j$，则必定从 $i$ 转移过来，否则必定从 $i+1$ 转移过来。

此外，由于我们是从最大的数位向最小的数位倒退，为使生成的整数尽可能地大，对于当前数位应尽可能多地选取，所以当 $\textit{dp}[i][j]$ 与 $\textit{dp}[i+1][j-\textit{cost}[i]]+1$ 相等时，我们选择从后者转移过来。

这样我们就得到了每个数位的选择次数，为使生成的整数尽可能地大，我们应按照从大到小的顺序填入各个数位。由于该顺序与倒退状态的顺序一致，我们可以在倒退状态时，将当前数位直接加入生成的整数末尾。

代码实现时，$-\infty$ 可以用一个非常小的负数表示，保证转移时对于值为 $-\infty$ 的状态，其 $+1$ 之后仍然为负数。

```C++ [sol1-C++]
class Solution {
public:
    string largestNumber(vector<int> &cost, int target) {
        vector<vector<int>> dp(10, vector<int>(target + 1, INT_MIN));
        vector<vector<int>> from(10, vector<int>(target + 1));
        dp[0][0] = 0;
        for (int i = 0; i < 9; ++i) {
            int c = cost[i];
            for (int j = 0; j <= target; ++j) {
                if (j < c) {
                    dp[i + 1][j] = dp[i][j];
                    from[i + 1][j] = j;
                } else {
                    if (dp[i][j] > dp[i + 1][j - c] + 1) {
                        dp[i + 1][j] = dp[i][j];
                        from[i + 1][j] = j;
                    } else {
                        dp[i + 1][j] = dp[i + 1][j - c] + 1;
                        from[i + 1][j] = j - c;
                    }
                }
            }
        }
        if (dp[9][target] < 0) {
            return "0";
        }
        string ans;
        int i = 9, j = target;
        while (i > 0) {
            if (j == from[i][j]) {
                --i;
            } else {
                ans += '0' + i;
                j = from[i][j];
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public String largestNumber(int[] cost, int target) {
        int[][] dp = new int[10][target + 1];
        for (int i = 0; i < 10; ++i) {
            Arrays.fill(dp[i], Integer.MIN_VALUE);
        }
        int[][] from = new int[10][target + 1];
        dp[0][0] = 0;
        for (int i = 0; i < 9; ++i) {
            int c = cost[i];
            for (int j = 0; j <= target; ++j) {
                if (j < c) {
                    dp[i + 1][j] = dp[i][j];
                    from[i + 1][j] = j;
                } else {
                    if (dp[i][j] > dp[i + 1][j - c] + 1) {
                        dp[i + 1][j] = dp[i][j];
                        from[i + 1][j] = j;
                    } else {
                        dp[i + 1][j] = dp[i + 1][j - c] + 1;
                        from[i + 1][j] = j - c;
                    }
                }
            }
        }
        if (dp[9][target] < 0) {
            return "0";
        }
        StringBuffer sb = new StringBuffer();
        int i = 9, j = target;
        while (i > 0) {
            if (j == from[i][j]) {
                --i;
            } else {
                sb.append(i);
                j = from[i][j];
            }
        }
        return sb.toString();
    }
}
```

```C# [sol1-C#]
public class Solution {
    public string LargestNumber(int[] cost, int target) {
        int[,] dp = new int[10, target + 1];
        for (int i = 0; i < 10; ++i) {
            for (int j = 0; j <= target; ++j) {
                dp[i, j] = int.MinValue;
            }
        }
        int[,] from = new int[10, target + 1];
        dp[0, 0] = 0;
        for (int i = 0; i < 9; ++i) {
            int c = cost[i];
            for (int j = 0; j <= target; ++j) {
                if (j < c) {
                    dp[i + 1, j] = dp[i, j];
                    from[i + 1, j] = j;
                } else {
                    if (dp[i, j] > dp[i + 1, j - c] + 1) {
                        dp[i + 1, j] = dp[i, j];
                        from[i + 1, j] = j;
                    } else {
                        dp[i + 1, j] = dp[i + 1, j - c] + 1;
                        from[i + 1, j] = j - c;
                    }
                }
            }
        }
        if (dp[9, target] < 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        int curr = 9, next = target;
        while (curr > 0) {
            if (next == from[curr, next]) {
                --curr;
            } else {
                sb.Append(curr);
                next = from[curr, next];
            }
        }
        return sb.ToString();
    }
}
```

```go [sol1-Golang]
func largestNumber(cost []int, target int) string {
    dp := make([][]int, 10)
    from := make([][]int, 10)
    for i := range dp {
        dp[i] = make([]int, target+1)
        for j := range dp[i] {
            dp[i][j] = math.MinInt32
        }
        from[i] = make([]int, target+1)
    }
    dp[0][0] = 0
    for i, c := range cost {
        for j := 0; j <= target; j++ {
            if j < c {
                dp[i+1][j] = dp[i][j]
                from[i+1][j] = j
            } else {
                if dp[i][j] > dp[i+1][j-c]+1 {
                    dp[i+1][j] = dp[i][j]
                    from[i+1][j] = j
                } else {
                    dp[i+1][j] = dp[i+1][j-c] + 1
                    from[i+1][j] = j - c
                }
            }
        }
    }
    if dp[9][target] < 0 {
        return "0"
    }
    ans := make([]byte, 0, dp[9][target])
    i, j := 9, target
    for i > 0 {
        if j == from[i][j] {
            i--
        } else {
            ans = append(ans, '0'+byte(i))
            j = from[i][j]
        }
    }
    return string(ans)
}
```

```JavaScript [sol1-JavaScript]
var largestNumber = function(cost, target) {
    const dp = new Array(10).fill(0).map(() => new Array(target + 1).fill(-Number.MAX_VALUE));
    const from = new Array(10).fill(0).map(() => new Array(target + 1).fill(0));
    dp[0][0] = 0;
    for (let i = 0; i < 9; ++i) {
        const c = cost[i];
        for (let j = 0; j <= target; ++j) {
            if (j < c) {
                dp[i + 1][j] = dp[i][j];
                from[i + 1][j] = j;
            } else {
                if (dp[i][j] > dp[i + 1][j - c] + 1) {
                    dp[i + 1][j] = dp[i][j];
                    from[i + 1][j] = j;
                } else {
                    dp[i + 1][j] = dp[i + 1][j - c] + 1;
                    from[i + 1][j] = j - c;
                }
            }
        }
    }
    if (dp[9][target] < 0) {
        return "0";
    }
    const sb = [];
    let i = 9, j = target;
    while (i > 0) {
        if (j === from[i][j]) {
            --i;
        } else {
            sb.push(i);
            j = from[i][j];
        }
    }
    return sb.join('');
};
```

```C [sol1-C]
char* largestNumber(int* cost, int costSize, int target) {
    int dp[10][target + 1];
    memset(dp, 0x80, sizeof(dp));
    dp[0][0] = 0;
    int from[10][target + 1];
    memset(from, 0, sizeof(from));
    for (int i = 0; i < 9; ++i) {
        int c = cost[i];
        for (int j = 0; j <= target; ++j) {
            if (j < c) {
                dp[i + 1][j] = dp[i][j];
                from[i + 1][j] = j;
            } else {
                if (dp[i][j] > dp[i + 1][j - c] + 1) {
                    dp[i + 1][j] = dp[i][j];
                    from[i + 1][j] = j;
                } else {
                    dp[i + 1][j] = dp[i + 1][j - c] + 1;
                    from[i + 1][j] = j - c;
                }
            }
        }
    }
    if (dp[9][target] < 0) {
        return "0";
    }
    char* ans = malloc(sizeof(char) * (target + 1));
    int ansSize = 0;
    int i = 9, j = target;
    while (i > 0) {
        if (j == from[i][j]) {
            --i;
        } else {
            ans[ansSize++] = '0' + i;
            j = from[i][j];
        }
    }
    ans[ansSize] = 0;
    return ans;
}
```

```Python [sol1-Python3]
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [[float("-inf")] * (target + 1) for _ in range(10)]
        where = [[0] * (target + 1) for _ in range(10)]
        dp[0][0] = 0

        for i, c in enumerate(cost):
            for j in range(target + 1):
                if j < c:
                    dp[i + 1][j] = dp[i][j]
                    where[i + 1][j] = j
                else:
                    if dp[i][j] > dp[i + 1][j - c] + 1:
                        dp[i + 1][j] = dp[i][j]
                        where[i + 1][j] = j
                    else:
                        dp[i + 1][j] = dp[i + 1][j - c] + 1
                        where[i + 1][j] = j - c
        
        if dp[9][target] < 0:
            return "0"
        
        ans = list()
        i, j = 9, target
        while i > 0:
            if j == where[i][j]:
                i -= 1
            else:
                ans.append(str(i))
                j = where[i][j]
        
        return "".join(ans)
```

上述代码有两处空间优化：

其一是滚动数组优化。由于 $\textit{dp}[i+1][]$ 每个元素值的计算只与 $\textit{dp}[i+1][]$ 和 $\textit{dp}[i][]$ 的元素值有关，因此可以使用滚动数组的方式，去掉 $\textit{dp}$ 的第一个维度。

其二是去掉 $\textit{from}$ 数组。在状态倒退时，直接根据 $\textit{dp}[j]$ 与 $\textit{dp}[j-\textit{cost}[i]]+1$ 是否相等来判断，若二者相等则说明是从 $\textit{dp}[j-\textit{cost}[i]]$ 转移而来，即选择了第 $i$ 个数位。

```C++ [sol2-C++]
class Solution {
public:
    string largestNumber(vector<int> &cost, int target) {
        vector<int> dp(target + 1, INT_MIN);
        dp[0] = 0;
        for (int c : cost) {
            for (int j = c; j <= target; ++j) {
                dp[j] = max(dp[j], dp[j - c] + 1);
            }
        }
        if (dp[target] < 0) {
            return "0";
        }
        string ans;
        for (int i = 8, j = target; i >= 0; i--) {
            for (int c = cost[i]; j >= c && dp[j] == dp[j - c] + 1; j -= c) {
                ans += '1' + i;
            }
        }
        return ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    public String largestNumber(int[] cost, int target) {
        int[] dp = new int[target + 1];
        Arrays.fill(dp, Integer.MIN_VALUE);
        dp[0] = 0;
        for (int c : cost) {
            for (int j = c; j <= target; ++j) {
                dp[j] = Math.max(dp[j], dp[j - c] + 1);
            }
        }
        if (dp[target] < 0) {
            return "0";
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 8, j = target; i >= 0; i--) {
            for (int c = cost[i]; j >= c && dp[j] == dp[j - c] + 1; j -= c) {
                sb.append(i + 1);
            }
        }
        return sb.toString();
    }
}
```

```C# [sol2-C#]
public class Solution {
    public string LargestNumber(int[] cost, int target) {
        int[] dp = new int[target + 1];
        Array.Fill(dp, int.MinValue);
        dp[0] = 0;
        foreach (int c in cost) {
            for (int j = c; j <= target; ++j) {
                dp[j] = Math.Max(dp[j], dp[j - c] + 1);
            }
        }
        if (dp[target] < 0) {
            return "0";
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 8, j = target; i >= 0; i--) {
            for (int c = cost[i]; j >= c && dp[j] == dp[j - c] + 1; j -= c) {
                sb.Append(i + 1);
            }
        }
        return sb.ToString();
    }
}
```

```go [sol2-Golang]
func largestNumber(cost []int, target int) string {
    dp := make([]int, target+1)
    for i := range dp {
        dp[i] = math.MinInt32
    }
    dp[0] = 0
    for _, c := range cost {
        for j := c; j <= target; j++ {
            dp[j] = max(dp[j], dp[j-c]+1)
        }
    }
    if dp[target] < 0 {
        return "0"
    }
    ans := make([]byte, 0, dp[target])
    for i, j := 8, target; i >= 0; i-- {
        for c := cost[i]; j >= c && dp[j] == dp[j-c]+1; j -= c {
            ans = append(ans, byte('1'+i))
        }
    }
    return string(ans)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```JavaScript [sol2-JavaScript]
var largestNumber = function(cost, target) {
    const dp = new Array(target + 1).fill(-Number.MAX_VALUE);
    dp[0] = 0;
    for (const c of cost) {
        for (let j = c; j <= target; ++j) {
            dp[j] = Math.max(dp[j], dp[j - c] + 1);
        }
    }
    if (dp[target] < 0) {
        return '0';
    }
    const ans = [];
    for (let i = 8, j = target; i >= 0; i--) {
        for (let c = cost[i]; j >= c && dp[j] === dp[j - c] + 1; j -= c) {
            ans.push(String.fromCharCode('1'.charCodeAt() + i));
        }
    }
    return ans.join('');
};
```

```C [sol2-C]
char* largestNumber(int* cost, int costSize, int target) {
    int dp[target + 1];
    memset(dp, 0x80, sizeof(dp));
    dp[0] = 0;
    for (int i = 0; i < costSize; ++i) {
        for (int j = cost[i]; j <= target; ++j) {
            dp[j] = fmax(dp[j], dp[j - cost[i]] + 1);
        }
    }
    if (dp[target] < 0) {
        return "0";
    }
    char* ans = malloc(sizeof(char) * (target + 1));
    int ansSize = 0;
    for (int i = 8, j = target; i >= 0; i--) {
        for (int c = cost[i]; j >= c && dp[j] == dp[j - c] + 1; j -= c) {
            ans[ansSize++] = '1' + i;
        }
    }
    ans[ansSize] = 0;
    return ans;
}
```

```Python [sol2-Python3]
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [float("-inf")] * (target + 1)
        dp[0] = 0

        for c in cost:
            for j in range(c, target + 1):
                dp[j] = max(dp[j], dp[j - c] + 1)
        
        if dp[target] < 0:
            return "0"
        
        ans = list()
        j = target
        for i in range(8, -1, -1):
            c = cost[i]
            while j >= c and dp[j] == dp[j - c] + 1:
                ans.append(str(i + 1))
                j -= c

        return "".join(ans)
```

**复杂度分析**

- 时间复杂度：$O(n\cdot\textit{target})$。其中 $n$ 是数组 $\textit{cost}$ 的长度。

- 空间复杂度：$O(\textit{target})$。