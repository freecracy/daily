# 2021年06月07日 code
<a href="https://toutiao.io/k/qnyxbs9">惊！这个 Go 开源项目号称「不改一行代码做秒杀」</a><br /><a href="https://toutiao.io/k/b9vlrcu">网络连接存在大量 time_wait 和 close_wait 的原因以及解决方法</a><br /><a href="https://toutiao.io/k/3ldiykv">ClickHouse 数据目录完全解析</a><br /><a href="https://toutiao.io/k/4v9vvbf">详解 Go 团队不建议用的 unsafe.Pointer</a><br /><a href="https://toutiao.io/k/0kk829x">信也容器云揭秘（四）：K8S 集群稳定性保障</a><br /><a href="https://toutiao.io/k/4v7pi9s">ACL 2021｜美团提出基于对比学习的文本表示模型，效果提升 8%</a><br /><a href="https://toutiao.io/k/7wen1tv">利用 V8 深入理解 JavaScript 设计</a><br /><a href="https://toutiao.io/k/rgdjl4x">Lucene 段的强制合并（二）</a><br /><a href="https://toutiao.io/k/4eehl9g">实践指南：网页生成 PDF</a><br /><a href="https://toutiao.io/k/xmk7n6w">函数的不定参数你是这样用吗？</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/z26byeu">[推荐] 25 张图，一万字，拆解 Linux 网络包发送过程</a><br /><a href="https://toutiao.io/k/d1m43ci">[推荐] 10 个解放双手实用在线工具，有些代码真的不用手写</a><br /><a href="https://toutiao.io/k/ybiw04u">[推荐] 高并发、高性能、高可用系统设计经验</a><br /><a href="https://toutiao.io/k/6tcdyp9">[推荐] Spring Boot 在 K8s 下实现优雅停机</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/5u1byn9">[推荐] 各厂三年 Go 面经，已入字节</a><br /><a href="https://toutiao.io/k/18gz8ap">[推荐] 百亿规模 API 网关服务 Shepherd 的设计与实现</a><br /><a href="https://toutiao.io/k/xha1t37">[推荐] 架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/te3l12o">[推荐] 人人都是架构师？？？谈何容易</a><br /><a href="https://toutiao.io/k/lq1k5bp">[推荐] [译] 您不想错过的 IntelliJ IDEA 十大插件</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/ngx4og0">[推荐] “三次握手，四次挥手” 这么讲，保证你忘不了</a><br /><a href="https://toutiao.io/k/3tudqnj">[推荐] 做一次黑客，入侵一次服务器</a><br /><hr /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Beta)</a><br /><a href="https://github.com/KranX/Perimeter"></a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/animate-css/animate.css">🍿 A cross-browser library of CSS animations. As easy to use as an easy thing.</a><br /><a href="https://github.com/login?return_to=%2Fdeepfakes%2Ffaceswap">Deepfakes Software For All</a><br /><a href="https://github.com/login?return_to=%2Filuwatar%2Fjava-design-patterns">Design patterns implemented in Java</a><br /><a href="https://github.com/kzl/decision-transformer">Official codebase for Decision Transformer: Reinforcement Learning via Sequence Modeling.</a><br /><a href="https://github.com/Awesome-HarmonyOS/HarmonyOS">A curated list of awesome things related to HarmonyOS. 华为鸿蒙操作系统。</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/thevinter/styli.sh">A CLI tool for easy wallpaper management and image fetching</a><br /><a href="https://github.com/luong-komorebi/Awesome-Linux-Software">A list of awesome applications, software, tools and other materials for Linux distros.</a><br /><a href="https://github.com/prisma/prisma">Next-generation ORM for Node.js & TypeScript | PostgreSQL, MySQL, MariaDB, SQL Server & SQLite</a><br /><a href="https://github.com/osintbrazuca/OSINT-Brazuca">Repositório criado com intuito de reunir informações, fontes(websites/portais) e tricks de OSINT dentro do contexto Brasil.</a><br /><a href="https://github.com/black7375/Firefox-UI-Fix">🦊 I respect proton UI and aim to improve it.</a><br /><a href="https://github.com/login?return_to=%2Fgeerlingguy%2Fmac-dev-playbook">Mac setup and configuration via Ansible.</a><br /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/rahuldkjain/github-profile-readme-generator">🚀 Generate GitHub profile README easily with the latest add-ons like visitors count, GitHub stats, etc using minimal UI.</a><br /><a href="https://github.com/home-assistant/core">🏡 Open source home automation that puts local control and privacy first</a><br /><a href="https://github.com/zooPanda/zoo">你我本是动物，我不该责怪你动物的本性，但请你给我足够的尊重，谢谢，共勉。</a><br /><a href="https://github.com/CSSEGISandData/COVID-19">Novel Coronavirus (COVID-19) Cases, provided by JHU CSSE</a><br /><a href="https://github.com/freefq/free">翻墙、免费翻墙、免费科学上网、免费节点、免费梯子、免费ss/ssr/v2ray/trojan节点、蓝灯、谷歌商店、翻墙梯子</a><br /><a href="https://github.com/electron/electron">Build cross-platform desktop apps with JavaScript, HTML, and CSS</a><br /><a href="https://github.com/jhu-ep-coursera/fullstack-course4">Example code for HTML, CSS, and Javascript for Web Developers Coursera Course</a><br /><hr />目标和<br /><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>

<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>

<ul>
	<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li>
</ul>

<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,1,1,1], target = 3
<strong>输出：</strong>5
<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1], target = 1
<strong>输出：</strong>1
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 20</code></li>
	<li><code>0 <= nums[i] <= 1000</code></li>
	<li><code>0 <= sum(nums[i]) <= 1000</code></li>
	<li><code>-1000 <= target <= 100</code></li>
</ul>
<br />#### 方法一：回溯

数组 $\textit{nums}$ 的每个元素都可以添加符号 $\texttt{+}$ 或 $\texttt{-}$，因此每个元素有 $2$ 种添加符号的方法，$n$ 个数共有 $2^n$ 种添加符号的方法，对应 $2^n$ 种不同的表达式。当 $n$ 个元素都添加符号之后，即得到一种表达式，如果表达式的结果等于目标数 $\textit{target}$，则该表达式即为符合要求的表达式。

可以使用回溯的方法遍历所有的表达式，回溯过程中维护一个计数器 $\textit{count}$，当遇到一种表达式的结果等于目标数 $\textit{target}$ 时，将 $\textit{count}$ 的值加 $1$。遍历完所有的表达式之后，即可得到结果等于目标数 $\textit{target}$ 的表达式的数目。

```Java [sol1-Java]
class Solution {
    int count = 0;

    public int findTargetSumWays(int[] nums, int target) {
        backtrack(nums, target, 0, 0);
        return count;
    }

    public void backtrack(int[] nums, int target, int index, int sum) {
        if (index == nums.length) {
            if (sum == target) {
                count++;
            }
        } else {
            backtrack(nums, target, index + 1, sum + nums[index]);
            backtrack(nums, target, index + 1, sum - nums[index]);
        }
    }
}
```

```C# [sol1-C#]
public class Solution {
    int count = 0;

    public int FindTargetSumWays(int[] nums, int target) {
        Backtrack(nums, target, 0, 0);
        return count;
    }

    public void Backtrack(int[] nums, int target, int index, int sum) {
        if (index == nums.Length) {
            if (sum == target) {
                count++;
            }
        } else {
            Backtrack(nums, target, index + 1, sum + nums[index]);
            Backtrack(nums, target, index + 1, sum - nums[index]);
        }
    }
}
```

```JavaScript [sol1-JavaScript]
var findTargetSumWays = function(nums, target) {
    let count = 0;
    const backtrack = (nums, target, index, sum) => {
        if (index === nums.length) {
            if (sum === target) {
                count++;
            }
        } else {
            backtrack(nums, target, index + 1, sum + nums[index]);
            backtrack(nums, target, index + 1, sum - nums[index]);
        }
    }
    
    backtrack(nums, target, 0, 0);
    return count;
};
```

```go [sol1-Golang]
func findTargetSumWays(nums []int, target int) (count int) {
    var backtrack func(int, int)
    backtrack = func(index, sum int) {
        if index == len(nums) {
            if sum == target {
                count++
            }
            return
        }
        backtrack(index+1, sum+nums[index])
        backtrack(index+1, sum-nums[index])
    }
    backtrack(0, 0)
    return
}
```

```C++ [sol1-C++]
class Solution {
public:
    int count = 0;

    int findTargetSumWays(vector<int>& nums, int target) {
        backtrack(nums, target, 0, 0);
        return count;
    }

    void backtrack(vector<int>& nums, int target, int index, int sum) {
        if (index == nums.size()) {
            if (sum == target) {
                count++;
            }
        } else {
            backtrack(nums, target, index + 1, sum + nums[index]);
            backtrack(nums, target, index + 1, sum - nums[index]);
        }
    }
};
```

```C [sol1-C]
int count;

int findTargetSumWays(int* nums, int numsSize, int target) {
    count = 0;
    backtrack(nums, numsSize, target, 0, 0);
    return count;
}

void backtrack(int* nums, int numSize, int target, int index, int sum) {
    if (index == numSize) {
        if (sum == target) {
            count++;
        }
    } else {
        backtrack(nums, numSize, target, index + 1, sum + nums[index]);
        backtrack(nums, numSize, target, index + 1, sum - nums[index]);
    }
}
```

**复杂度分析**

- 时间复杂度：$O(2^n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。回溯需要遍历所有不同的表达式，共有 $2^n$ 种不同的表达式，每种表达式计算结果需要 $O(1)$ 的时间，因此总时间复杂度是 $O(2^n)$。

- 空间复杂度：$O(n)$，其中 $n$ 是数组 $\textit{nums}$ 的长度。空间复杂度主要取决于递归调用的栈空间，栈的深度不超过 $n$。

#### 方法二：动态规划

记数组的元素和为 $\textit{sum}$，添加 $\texttt{-}$ 号的元素之和为 $\textit{neg}$，则其余添加 $\texttt{+}$ 的元素之和为 $\textit{sum}-\textit{neg}$，得到的表达式的结果为 

$$
(\textit{sum}-\textit{neg})-\textit{neg}=\textit{sum}-2\cdot\textit{neg}=\textit{target}
$$

即 

$$
\textit{neg}=\dfrac{\textit{sum}-\textit{target}}{2}
$$

由于数组 $\textit{nums}$ 中的元素都是非负整数，$\textit{neg}$ 也必须是非负整数，所以上式成立的前提是 $\textit{sum}-\textit{target}$ 是**非负偶数**。若不符合该条件可直接返回 $0$。

若上式成立，问题转化成在数组 $\textit{nums}$ 中选取若干元素，使得这些元素之和等于 $\textit{neg}$，计算选取元素的方案数。我们可以使用动态规划的方法求解。

定义二维数组 $\textit{dp}$，其中 $\textit{dp}[i][j]$ 表示在数组 $\textit{nums}$ 的前 $i$ 个数中选取元素，使得这些元素之和等于 $j$ 的方案数。假设数组 $\textit{nums}$ 的长度为 $n$，则最终答案为 $\textit{dp}[n][\textit{neg}]$。

当没有任何元素可以选取时，元素和只能是 $0$，对应的方案数是 $1$，因此动态规划的边界条件是：

$$
\textit{dp}[0][j]=\begin{cases}
1, & j=0 \\
0, & j \ge 1
\end{cases}
$$

当 $1 \le i \le n$ 时，对于数组 $\textit{nums}$ 中的第 $i$ 个元素 $\textit{num}$（$i$ 的计数从 $1$ 开始），遍历 $0 \le j \le \textit{neg}$，计算 $\textit{dp}[i][j]$ 的值：

- 如果 $j < \textit{num}$，则不能选 $\textit{num}$，此时有 $\textit{dp}[i][j] = \textit{dp}[i - 1][j]$；

- 如果 $j \ge \textit{num}$，则如果不选 $\textit{num}$，方案数是 $\textit{dp}[i - 1][j]$，如果选 $\textit{num}$，方案数是 $\textit{dp}[i - 1][j - \textit{num}]$，此时有 $\textit{dp}[i][j] = \textit{dp}[i - 1][j] + \textit{dp}[i - 1][j - \textit{num}]$。

因此状态转移方程如下：

$$
\textit{dp}[i][j]=\begin{cases}
\textit{dp}[i - 1][j], & j<\textit{nums}[i] \\
\textit{dp}[i - 1][j] + \textit{dp}[i - 1][j - \textit{nums}[i]], & j \ge \textit{nums}[i]
\end{cases}
$$

最终得到 $\textit{dp}[n][\textit{neg}]$ 的值即为答案。

由此可以得到空间复杂度为 $O(n \times \textit{neg})$ 的实现。

```Java [sol2-Java]
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int n = nums.length, neg = diff / 2;
        int[][] dp = new int[n + 1][neg + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = 0; j <= neg; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[n][neg];
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int FindTargetSumWays(int[] nums, int target) {
        int sum = 0;
        foreach (int num in nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int n = nums.Length, neg = diff / 2;
        int[,] dp = new int[n + 1, neg + 1];
        dp[0, 0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = 0; j <= neg; j++) {
                dp[i, j] = dp[i - 1, j];
                if (j >= num) {
                    dp[i, j] += dp[i - 1, j - num];
                }
            }
        }
        return dp[n, neg];
    }
}
```

```JavaScript [sol2-JavaScript]
var findTargetSumWays = function(nums, target) {
    let sum = 0;
    for (const num of nums) {
        sum += num;
    }
    const diff = sum - target;
    if (diff < 0 || diff % 2 !== 0) {
        return 0;
    }
    const n = nums.length, neg = diff / 2;
    const dp = new Array(n + 1).fill(0).map(() => new Array(neg + 1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= n; i++) {
        const num = nums[i - 1];
        for (let j = 0; j <= neg; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= num) {
                dp[i][j] += dp[i - 1][j - num];
            }
        }
    }
    return dp[n][neg];
};
```

```go [sol2-Golang]
func findTargetSumWays(nums []int, target int) int {
    sum := 0
    for _, v := range nums {
        sum += v
    }
    diff := sum - target
    if diff < 0 || diff%2 == 1 {
        return 0
    }
    n, neg := len(nums), diff/2
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, neg+1)
    }
    dp[0][0] = 1
    for i, num := range nums {
        for j := 0; j <= neg; j++ {
            dp[i+1][j] = dp[i][j]
            if j >= num {
                dp[i+1][j] += dp[i][j-num]
            }
        }
    }
    return dp[n][neg]
}
```

```C++ [sol2-C++]
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int& num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int n = nums.size(), neg = diff / 2;
        vector<vector<int>> dp(n + 1, vector<int>(neg + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = 0; j <= neg; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= num) {
                    dp[i][j] += dp[i - 1][j - num];
                }
            }
        }
        return dp[n][neg];
    }
};
```

```C [sol2-C]
int findTargetSumWays(int* nums, int numsSize, int target) {
    int sum = 0;
    for (int i = 0; i < numsSize; i++) {
        sum += nums[i];
    }
    int diff = sum - target;
    if (diff < 0 || diff % 2 != 0) {
        return 0;
    }
    int n = numsSize, neg = diff / 2;
    int dp[n + 1][neg + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        int num = nums[i - 1];
        for (int j = 0; j <= neg; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= num) {
                dp[i][j] += dp[i - 1][j - num];
            }
        }
    }
    return dp[n][neg];
}
```

由于 $\textit{dp}$ 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 $\textit{dp}$ 的第一个维度，将空间复杂度优化到 $O(\textit{neg})$。

实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 $\textit{dp}[i-1][]$ 中的元素值。

```Java [sol3-Java]
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int neg = diff / 2;
        int[] dp = new int[neg + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int j = neg; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```

```C# [sol3-C#]
public class Solution {
    public int FindTargetSumWays(int[] nums, int target) {
        int sum = 0;
        foreach (int num in nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int neg = diff / 2;
        int[] dp = new int[neg + 1];
        dp[0] = 1;
        foreach (int num in nums) {
            for (int j = neg; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
}
```

```JavaScript [sol3-JavaScript]
var findTargetSumWays = function(nums, target) {
    let sum = 0;
    for (const num of nums) {
        sum += num;
    }
    const diff = sum - target;
    if (diff < 0 || diff % 2 !== 0) {
        return 0;
    }
    const neg = Math.floor(diff / 2);
    const dp = new Array(neg + 1).fill(0);
    dp[0] = 1;
    for (const num of nums) {
        for (let j = neg; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[neg];
};
```

```go [sol3-Golang]
func findTargetSumWays(nums []int, target int) int {
    sum := 0
    for _, v := range nums {
        sum += v
    }
    diff := sum - target
    if diff < 0 || diff%2 == 1 {
        return 0
    }
    neg := diff / 2
    dp := make([]int, neg+1)
    dp[0] = 1
    for _, num := range nums {
        for j := neg; j >= num; j-- {
            dp[j] += dp[j-num]
        }
    }
    return dp[neg]
}
```

```C++ [sol3-C++]
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int& num : nums) {
            sum += num;
        }
        int diff = sum - target;
        if (diff < 0 || diff % 2 != 0) {
            return 0;
        }
        int neg = diff / 2;
        vector<int> dp(neg + 1);
        dp[0] = 1;
        for (int& num : nums) {
            for (int j = neg; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[neg];
    }
};
```

```C [sol3-C]
int findTargetSumWays(int* nums, int numsSize, int target) {
    int sum = 0;
    for (int i = 0; i < numsSize; i++) {
        sum += nums[i];
    }
    int diff = sum - target;
    if (diff < 0 || diff % 2 != 0) {
        return 0;
    }
    int neg = diff / 2;
    int dp[neg + 1];
    memset(dp, 0, sizeof(dp));
    dp[0] = 1;
    for (int i = 0; i < numsSize; i++) {
        int num = nums[i];
        for (int j = neg; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[neg];
}
```

**复杂度分析**

- 时间复杂度：$O(n \times (\textit{sum}-\textit{target}))$，其中 $n$ 是数组 $\textit{nums}$ 的长度，$\textit{sum}$ 是数组 $\textit{nums}$ 的元素和，$\textit{target}$ 是目标数。动态规划有 $(n+1) \times (\dfrac{\textit{sum}-\textit{target}}{2}+1)$ 个状态，需要计算每个状态的值。

- 空间复杂度：$O(\textit{sum}-\textit{target})$，其中 $\textit{sum}$ 是数组 $\textit{nums}$ 的元素和，$\textit{target}$ 是目标数。使用空间优化的实现，需要创建长度为 $\dfrac{\textit{sum}-\textit{target}}{2}+1$ 的数组 $\textit{dp}$。