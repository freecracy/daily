# 2021年06月05日 code
<a href="https://toutiao.io/k/2rcud9q">Redis 存储对象信息是用 Hash 还是 String</a><br /><a href="https://toutiao.io/k/tzdqnhc">终于明白什么是区块链了</a><br /><a href="https://toutiao.io/k/gfo3iba">一文理解 JVM 线程属于用户态还是内核态</a><br /><a href="https://toutiao.io/k/w9fekde">Presto 在腾讯资讯业务中的应用</a><br /><a href="https://toutiao.io/k/fgv9rqj">不要懒惰的重复自己</a><br /><a href="https://toutiao.io/k/kk111u2">深入浅出协程、线程和并发问题</a><br /><a href="https://toutiao.io/k/uc2mtkg">[译] Prisma：适用于 Node.js 和 TypeScript 的完整 ORM</a><br /><a href="https://toutiao.io/k/scdx7nm">浅谈分布式一致性：Raft 与 SOFAJRaft</a><br /><a href="https://toutiao.io/k/ow2rhiz">Linux 调度系统全景指南（终结篇）</a><br /><a href="https://toutiao.io/k/23djacg">从流量打标到机器打标：达达全链路压测探索与实战</a><br /><a href="https://toutiao.io/k/7ikzqin">Spring 优雅注册 Bean 的方式</a><br /><a href="https://toutiao.io/k/wl3klwr">数仓：谁说 ODS 层就是简单的数据同步？</a><br /><a href="https://toutiao.io/k/paz7lve">大概有 2/3 的娃会在将来从事目前尚未发明出来的工作</a><br /><a href="https://toutiao.io/k/1ijxf8f">优雅地处理错误真是一门学问啊</a><br /><a href="https://toutiao.io/k/xaji1dr">用 Python 写个贪吃蛇，保姆级教程</a><br /><a href="https://toutiao.io/k/ggqcm79">skynet debug console 使用</a><br /><a href="https://toutiao.io/k/cti2ec2">深入了解 Vue-i18n 是实现国际化功能的原理</a><br /><a href="https://toutiao.io/k/9cy2mki">Trip.com APP 启动优化实践</a><br /><a href="https://toutiao.io/k/61g4mqc">密码学基础（一）：常见密码算法分类</a><br /><a href="https://toutiao.io/k/atqhz8a">当端口扫描遇到防火墙</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/xha1t37">[推荐] 架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/t1o49fm">[推荐] 企业微信万亿级日志检索系统</a><br /><a href="https://toutiao.io/k/ybiw04u">[推荐] 高并发、高性能、高可用系统设计经验</a><br /><a href="https://toutiao.io/k/5u1byn9">[推荐] 各厂三年 Go 面经，已入字节</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/z26byeu">[推荐] 25 张图，一万字，拆解 Linux 网络包发送过程</a><br /><a href="https://toutiao.io/k/b70jpzu">[推荐] 10 问 10 答：你真的了解线程池吗？</a><br /><a href="https://toutiao.io/k/lq1k5bp">[推荐] [译] 您不想错过的 IntelliJ IDEA 十大插件</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/q62fiq2">[推荐] 如闪电划破雨夜，这些开源项目瞬间点亮了命令行</a><br /><a href="https://toutiao.io/k/5za3e5u">[推荐] Golang 内存管理分析</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/3tudqnj">[推荐] 做一次黑客，入侵一次服务器</a><br /><hr /><a href="https://github.com/black7375/Firefox-UI-Fix">🦊 I respect proton UI and aim to improve it.</a><br /><a href="https://github.com/GoogleChrome/lighthouse">Automated auditing, performance metrics, and best practices for the web.</a><br /><a href="https://github.com/TheAlgorithms/Java">All Algorithms implemented in Java</a><br /><a href="https://github.com/login?return_to=%2Frustdesk%2Frustdesk">An open source remote desktop client software</a><br /><a href="https://github.com/chinnkarahoi/jd_scripts">lxk0301/jd_scripts备份。不要star。不要fork。谢谢配合。</a><br /><a href="https://github.com/Awesome-HarmonyOS/HarmonyOS">A curated list of awesome things related to HarmonyOS. 华为鸿蒙操作系统。</a><br /><a href="https://github.com/files-community/Files">A modern file explorer that pushes the boundaries of the platform.</a><br /><a href="https://github.com/login?return_to=%2Fphotoprism%2Fphotoprism">Open-Source Photo Management powered by Go and Google TensorFlow</a><br /><a href="https://github.com/kzl/decision-transformer">Official codebase for Decision Transformer: Reinforcement Learning via Sequence Modeling.</a><br /><a href="https://github.com/pmndrs/racing-game">🏎 Open source racing game developed by everyone willing</a><br /><a href="https://github.com/dotnet/AspNetCore.Docs">Documentation for ASP.NET Core</a><br /><a href="https://github.com/leonardomso/33-js-concepts">📜 33 JavaScript concepts every developer should know.</a><br /><a href="https://github.com/PeiQi0/PeiQi-WIKI-POC">鹿不在侧，鲸不予游🐋</a><br /><a href="https://github.com/yangtingxiao/QuantumultX">脚本，自用</a><br /><a href="https://github.com/facebook/react-native">A framework for building native apps with React.</a><br /><a href="https://github.com/PrithivirajDamodaran/Gramformer">A framework for detecting, highlighting and correcting grammatical errors on natural language text.</a><br /><a href="https://github.com/juliocesarfort/public-pentesting-reports">Curated list of public penetration test reports released by several consulting firms and academic security groups</a><br /><a href="https://github.com/prisma/prisma">Next-generation ORM for Node.js & TypeScript | PostgreSQL, MySQL, MariaDB, SQL Server & SQLite</a><br /><a href="https://github.com/yqchilde/JDMemberCloseAccount">学习python操作selenium的一个🌰，用来 自动/半自动 退出加入的所有店铺会员</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/NielsRogge/Transformers-Tutorials">This repository contains demos I made with the Transformers library by HuggingFace.</a><br /><a href="https://github.com/rahuldkjain/github-profile-readme-generator">🚀 Generate GitHub profile README easily with the latest add-ons like visitors count, GitHub stats, etc using minimal UI.</a><br /><a href="https://github.com/helix-editor/helix">A post-modern modal text editor.</a><br /><a href="https://github.com/datasciencemasters/go">The Open Source Data Science Masters</a><br /><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">The repository for high quality TypeScript type definitions.</a><br /><hr />移除链表元素<br />给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。
<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" style="width: 500px; height: 142px;" />
<pre>
<strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6
<strong>输出：</strong>[1,2,3,4,5]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>head = [], val = 1
<strong>输出：</strong>[]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>head = [7,7,7,7], val = 7
<strong>输出：</strong>[]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>列表中的节点在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>
	<li><code>1 <= Node.val <= 50</code></li>
	<li><code>0 <= k <= 50</code></li>
</ul>
<br />#### 方法一：递归

链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。这道题要求删除链表中所有节点值等于特定值的节点，可以用递归实现。

对于给定的链表，首先对除了头节点 $\textit{head}$ 以外的节点进行删除操作，然后判断 $\textit{head}$ 的节点值是否等于给定的 $\textit{val}$。如果 $\textit{head}$ 的节点值等于 $\textit{val}$，则 $\textit{head}$ 需要被删除，因此删除操作后的头节点为 $\textit{head}.\textit{next}$；如果 $\textit{head}$ 的节点值不等于 $\textit{val}$，则 $\textit{head}$ 保留，因此删除操作后的头节点还是 $\textit{head}$。上述过程是一个递归的过程。

递归的终止条件是 $\textit{head}$ 为空，此时直接返回 $\textit{head}$。当 $\textit{head}$ 不为空时，递归地进行删除操作，然后判断 $\textit{head}$ 的节点值是否等于 $\textit{val}$ 并决定是否要删除 $\textit{head}$。

```Java [sol1-Java]
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public ListNode RemoveElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        head.next = RemoveElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
```

```JavaScript [sol1-JavaScript]
var removeElements = function(head, val) {
    if (head === null) {
            return head;
        }
        head.next = removeElements(head.next, val);
        return head.val === val ? head.next : head;
};
```

```go [sol1-Golang]
func removeElements(head *ListNode, val int) *ListNode {
    if head == nil {
        return head
    }
    head.Next = removeElements(head.Next, val)
    if head.Val == val {
        return head.Next
    }
    return head
}
```

```C++ [sol1-C++]
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == nullptr) {
            return head;
        }
        head->next = removeElements(head->next, val);
        return head->val == val ? head->next : head;
    }
};
```

```C [sol1-C]
struct ListNode* removeElements(struct ListNode* head, int val) {
    if (head == NULL) {
        return head;
    }
    head->next = removeElements(head->next, val);
    return head->val == val ? head->next : head;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是链表的长度。递归过程中需要遍历链表一次。

- 空间复杂度：$O(n)$，其中 $n$ 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 $n$ 层。

#### 方法二：迭代

也可以用迭代的方法删除链表中所有节点值等于特定值的节点。

用 $\textit{temp}$ 表示当前节点。如果 $\textit{temp}$ 的下一个节点不为空且下一个节点的节点值等于给定的 $\textit{val}$，则需要删除下一个节点。删除下一个节点可以通过以下做法实现：

$$
\textit{temp}.\textit{next} = \textit{temp}.\textit{next}.\textit{next}
$$

如果 $\textit{temp}$ 的下一个节点的节点值不等于给定的 $\textit{val}$，则保留下一个节点，将 $\textit{temp}$ 移动到下一个节点即可。

当 $\textit{temp}$ 的下一个节点为空时，链表遍历结束，此时所有节点值等于 $\textit{val}$ 的节点都被删除。

具体实现方面，由于链表的头节点 $\textit{head}$ 有可能需要被删除，因此创建哑节点 $\textit{dummyHead}$，令 $\textit{dummyHead}.\textit{next} = \textit{head}$，初始化 $\textit{temp}=\textit{dummyHead}$，然后遍历链表进行删除操作。最终返回 $\textit{dummyHead}.\textit{next}$ 即为删除操作后的头节点。

```Java [sol2-Java]
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode temp = dummyHead;
        while (temp.next != null) {
            if (temp.next.val == val) {
                temp.next = temp.next.next;
            } else {
                temp = temp.next;
            }
        }
        return dummyHead.next;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public ListNode RemoveElements(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode temp = dummyHead;
        while (temp.next != null) {
            if (temp.next.val == val) {
                temp.next = temp.next.next;
            } else {
                temp = temp.next;
            }
        }
        return dummyHead.next;
    }
}
```

```JavaScript [sol2-JavaScript]
var removeElements = function(head, val) {
    const dummyHead = new ListNode(0);
    dummyHead.next = head;
    let temp = dummyHead;
    while (temp.next !== null) {
        if (temp.next.val == val) {
            temp.next = temp.next.next;
        } else {
            temp = temp.next;
        }
    }
    return dummyHead.next;
};
```

```go [sol2-Golang]
func removeElements(head *ListNode, val int) *ListNode {
    dummyHead := &ListNode{Next: head}
    for tmp := dummyHead; tmp.Next != nil; {
        if tmp.Next.Val == val {
            tmp.Next = tmp.Next.Next
        } else {
            tmp = tmp.Next
        }
    }
    return dummyHead.Next
}
```

```C++ [sol1-C++]
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        struct ListNode* dummyHead = new ListNode(0, head);
        struct ListNode* temp = dummyHead;
        while (temp->next != NULL) {
            if (temp->next->val == val) {
                temp->next = temp->next->next;
            } else {
                temp = temp->next;
            }
        }
        return dummyHead->next;
    }
};
```

```C [sol1-C]
struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));
    dummyHead->next = head;
    struct ListNode* temp = dummyHead;
    while (temp->next != NULL) {
        if (temp->next->val == val) {
            temp->next = temp->next->next;
        } else {
            temp = temp->next;
        }
    }
    return dummyHead->next;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是链表的长度。需要遍历链表一次。

- 空间复杂度：$O(1)$。