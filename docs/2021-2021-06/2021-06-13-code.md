# 2021年06月13日 code
<a href="https://toutiao.io/k/aldjzoo">Flutter 电商项目最佳实践</a><br /><a href="https://toutiao.io/k/ndgl5lb">快速进行服务接口监控</a><br /><a href="https://toutiao.io/k/l2o49j6">数智时代，运维的出路在哪里？</a><br /><a href="https://toutiao.io/k/0ruh5co">重新思考错误处理（二）</a><br /><a href="https://toutiao.io/k/97ce002">如何确定图 (Graph) 里有没有环 (Cycle)？</a><br /><a href="https://toutiao.io/k/nvp0ljg">巧用模板模式和工厂模式简化开发工作</a><br /><a href="https://toutiao.io/k/j7va8p6">《漫画算法2》2021 全新进阶版来袭</a><br /><a href="https://toutiao.io/k/j73iidw">在 RecyclerView 中使用 header 快人一步</a><br /><a href="https://toutiao.io/k/y2jt2d4">Portable UDF：Facebook 工程师为了解决不同计算引擎 UDF 统一的项目</a><br /><a href="https://toutiao.io/k/ae2auhz">工具 | 一套腾讯广告自研的分布式编译系统</a><br /><a href="https://toutiao.io/k/xha1t37">[推荐] 架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/85kvlje">[推荐] 面试题：MySQL 一棵 B+ 树能存多少条数据？</a><br /><a href="https://toutiao.io/k/xjnx4kp">[推荐] 杭州某大厂：MySQL 连环问</a><br /><a href="https://toutiao.io/k/b9vlrcu">[推荐] 网络连接存在大量 time_wait 和 close_wait 的原因以及解决方法</a><br /><a href="https://toutiao.io/k/z26byeu">[推荐] 25 张图，一万字，拆解 Linux 网络包发送过程</a><br /><a href="https://toutiao.io/k/qnyxbs9">[推荐] 惊！这个 Go 开源项目号称「不改一行代码做秒杀」</a><br /><a href="https://toutiao.io/k/3xscqep">[推荐] 一文理解 Java 中的 SPI 机制</a><br /><a href="https://toutiao.io/k/2rcud9q">[推荐] Redis 存储对象信息是用 Hash 还是 String</a><br /><a href="https://toutiao.io/k/mr1knwm">[推荐] 微服务拆分之道</a><br /><a href="https://toutiao.io/k/b70jpzu">[推荐] 10 问 10 答：你真的了解线程池吗？</a><br /><a href="https://toutiao.io/k/d6e55fr">[推荐] 搜狗面试题：IO 多路复用之 select、poll、epoll 的区别</a><br /><a href="https://toutiao.io/k/ow2rhiz">[推荐] Linux 调度系统全景指南（终结篇）</a><br /><a href="https://toutiao.io/k/msg8jaf">[推荐] 2.3 万 Star！直追微软 Visio，这个简洁实用的在线绘图工具必须推荐给你</a><br /><a href="https://toutiao.io/k/d139zzl">[推荐] 有了这款运维自动化神器，可以抛弃 Ansible 了</a><br /><a href="https://toutiao.io/k/wwmsd4f">[推荐] 学会这 10 个设计原则，离架构师又进了一步</a><br /><hr /><a href="https://github.com/zzanehip/The-OldOS-Project">Recreating a fully functional version of iOS 4 in SwiftUI.</a><br /><a href="https://github.com/PaperMC/Paper">High performance Spigot fork that aims to fix gameplay and mechanics inconsistencies</a><br /><a href="https://github.com/madMAx43v3r/chia-plotter"></a><br /><a href="https://github.com/actions/virtual-environments">GitHub Actions virtual environments</a><br /><a href="https://github.com/pytorch/fairseq">Facebook AI Research Sequence-to-Sequence Toolkit written in Python.</a><br /><a href="https://github.com/actions/starter-workflows">Accelerating new GitHub Actions workflows</a><br /><a href="https://github.com/981011512/--">停车场系统源码，停车场小程序，智能停车，Parking system，【功能介绍】：①兼容市面上主流的多家相机，理论上兼容所有硬件，可灵活扩展，②相机识别后数据自动上传到云端并记录，校验相机唯一id和硬件序列号，防止非法数据录入，③用户手机查询停车记录详情可自主缴费(支持微信，支付宝，银行接口支付，支持每个停车场指定不同的商户进行收款)，支付后出场在免费时间内会自动抬杆。④支持app上查询附近停车场(导航，可用车位数，停车场费用，优惠券，评分，评论等)，可预约车位。⑤断电断网支持岗亭人员使用app可接管硬件进行停车记录的录入。 【技术架构】：后端开发语言java，框架oauth2+springboot2+dubble，数据库mysql/mongodb/redis，即时通讯底层框架net…</a><br /><a href="https://github.com/chrxh/alien">alien is a GPU-accelerated artificial life simulation program.</a><br /><a href="https://github.com/maziarraissi/Applied-Deep-Learning">Applied Deep Learning</a><br /><a href="https://github.com/yangtingxiao/QuantumultX">脚本，自用</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/peng-zhihui/XUAN-Bike"></a><br /><a href="https://github.com/microsoft/vscode">Visual Studio Code</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/liupan1890/aliyunpan">阿里云盘小白羊版 阿里云盘PC版</a><br /><a href="https://github.com/florinpop17/app-ideas">A Collection of application ideas which can be used to improve your coding skills.</a><br /><a href="https://github.com/whittlem/pycryptobot">Python Crypto Bot</a><br /><a href="https://github.com/danistefanovic/build-your-own-x">🤓 Build your own (insert technology here)</a><br /><a href="https://github.com/OAI/OpenAPI-Specification">The OpenAPI Specification Repository</a><br /><a href="https://github.com/Air14/HyperHide">Hypervisor based anti anti debug plugin for x64dbg</a><br /><a href="https://github.com/Charmve/computer-vision-in-action">《计算机视觉实战演练：算法与应用》中文电子书、源码、读者交流社区（更新中，可以先 star）</a><br /><a href="https://github.com/wuzhi04/MyActions"></a><br /><a href="https://github.com/tensorflow/tensorflow">An Open Source Machine Learning Framework for Everyone</a><br /><a href="https://github.com/kubeflow/pipelines">Machine Learning Pipelines for Kubeflow</a><br /><a href="https://github.com/spring-projects/spring-boot">Spring Boot</a><br /><hr />第一个错误的版本<br /><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>

<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>

<p>你可以通过调用&nbsp;<code>bool isBadVersion(version)</code>&nbsp;接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>

<p><strong>示例:</strong></p>

<pre>给定 n = 5，并且 version = 4 是第一个错误的版本。

<code>调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5)&nbsp;-&gt; true
调用 isBadVersion(4)&nbsp;-&gt; true

所以，4 是第一个错误的版本。&nbsp;</code></pre>
<br />#### 方法一：二分查找

**思路及算法**

因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。

注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。

具体地，将左右边界分别初始化为 $1$ 和 $n$，其中 $n$ 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。

这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 $O(\log n)$ 次。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
};
```

```Java [sol1-Java]
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
}
```

```C# [sol1-C#]
public class Solution : VersionControl {
    public int FirstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (IsBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
}
```

```go [sol1-Golang]
func firstBadVersion(n int) int {
    return sort.Search(n, func(version int) bool { return isBadVersion(version) })
}
```

```JavaScript [sol1-JavaScript]
var solution = function(isBadVersion) {
    return function(n) {
        let left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            const mid = Math.floor(left + (right - left) / 2); // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    };
};
```

```C [sol1-C]
int firstBadVersion(int n) {
    int left = 1, right = n;
    while (left < right) {  // 循环直至区间左右端点相同
        int mid = left + (right - left) / 2;  // 防止计算时溢出
        if (isBadVersion(mid)) {
            right = mid;  // 答案在区间 [left, mid] 中
        } else {
            left = mid + 1;  // 答案在区间 [mid+1, right] 中
        }
    }
    // 此时有 left == right，区间缩为一个点，即为答案
    return left;
}
```

**复杂度分析**

- 时间复杂度：$O(\log n)$，其中 $n$ 是给定版本的数量。

- 空间复杂度：$O(1)$。我们只需要常数的空间保存若干变量。