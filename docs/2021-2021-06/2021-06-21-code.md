# 2021年06月21日 code
<a href="https://toutiao.io/k/zsvnw8f">有了 RestTemplate 你还在手撕写 HttpClient？</a><br /><a href="https://toutiao.io/k/ttvrzlk">[译] React 状态管理的前世，今生和未来</a><br /><a href="https://toutiao.io/k/flosayk">彻底搞懂事件驱动模型：Reactor</a><br /><a href="https://toutiao.io/k/yne9bm6">ElasticSearch 双数据中心建设在新网银行的实践</a><br /><a href="https://toutiao.io/k/t5mzsjg">携程平台化常态化数据治理之路</a><br /><a href="https://toutiao.io/k/jk7v7v6">Android 的消息机制 ThreadLocal 工作原理全面掌握，够深入</a><br /><a href="https://toutiao.io/k/pz12wl0">JSBridge 原理解析：以 WebviewJavascriptBridge 实现方式为例</a><br /><a href="https://toutiao.io/k/ia59ago">Java 并发：乐观锁</a><br /><a href="https://toutiao.io/k/m0blzub">解析 Nebula Graph 子图设计及实践</a><br /><a href="https://toutiao.io/k/sb5lwiy">数据与广告（二十四）：效果广告后定向时代如何逆流而上</a><br /><a href="https://toutiao.io/k/a3gplbq">[推荐] 一文理解 Redis 底层数据结构</a><br /><a href="https://toutiao.io/k/pbwl6pl">[推荐] 95% 的算法都是基于这 6 种算法思想</a><br /><a href="https://toutiao.io/k/92nisj7">[推荐] 高吞吐、低延迟 Java 应用的 GC 优化实践</a><br /><a href="https://toutiao.io/k/kkc4ght">[推荐] 利用 Kubernetes 搭建便携式开发环境之 MySQL 和 Redis</a><br /><a href="https://toutiao.io/k/xjnx4kp">[推荐] 杭州某大厂：MySQL 连环问</a><br /><a href="https://toutiao.io/k/mr1knwm">[推荐] 微服务拆分之道</a><br /><a href="https://toutiao.io/k/85kvlje">[推荐] 面试题：MySQL 一棵 B+ 树能存多少条数据？</a><br /><a href="https://toutiao.io/k/a7bxrhs">[推荐] 有赞 TCP 网络编程最佳实践</a><br /><a href="https://toutiao.io/k/3kwp297">[推荐] 月薪两万程序员应该知道的编程模型</a><br /><a href="https://toutiao.io/k/3xscqep">[推荐] 一文理解 Java 中的 SPI 机制</a><br /><hr /><a href="https://github.com/programthink/zhao">【编程随想】整理的《太子党关系网络》，专门揭露赵国的权贵</a><br /><a href="https://github.com/AkashSingh3031/The-Complete-FAANG-Preparation">This repository contains all the DSA (Data-Structures, Algorithms, 450 DSA by Love Babbar Bhaiya, FAANG Questions), Technical Subjects (OS + DBMS + SQL + CN + OOPs) Theory+Questions, FAANG Interview questions, and Miscellaneous Stuff (Programming MCQs, Puzzles, Aptitude, Reasoning). The Programming languages used for demonstration are C++, Pytho…</a><br /><a href="https://github.com/CaffeineMC/sodium-fabric">A Fabric mod designed to improve frame rates and reduce micro-stutter</a><br /><a href="https://github.com/n8n-io/n8n">Free and open fair-code licensed node based Workflow Automation Tool. Easily automate tasks across different services.</a><br /><a href="https://github.com/facebookresearch/AugLy">A data augmentations library for audio, image, text, and video.</a><br /><a href="https://github.com/vxunderground/MalwareSourceCode">Collection of malware source code for a variety of platforms in an array of different programming languages.</a><br /><a href="https://github.com/abuanwar072/Flutter-Responsive-Admin-Panel-or-Dashboard">Responsive Admin Panel or Dashboard using Flutter</a><br /><a href="https://github.com/EssayKillerBrain/EssayKiller_V2">基于开源GPT2.0的初代创作型人工智能 | 可扩展、可进化</a><br /><a href="https://github.com/organicmaps/organicmaps">🍃 Organic Maps is a better fork of MAPS.ME, an Android & iOS offline maps app for travelers, tourists, hikers, and cyclists based on top of crowd-sourced OpenStreetMap data and curated with love by MAPS.ME founders. No ads, no tracking, no data collection, no crapware.</a><br /><a href="https://github.com/login?return_to=%2Frustdesk%2Frustdesk">Yet another remote desktop software</a><br /><a href="https://github.com/algorithm-visualizer/algorithm-visualizer">🎆Interactive Online Platform that Visualizes Algorithms from Code</a><br /><a href="https://github.com/academic/awesome-datascience">📝 An awesome Data Science repository to learn and apply for real world problems.</a><br /><a href="https://github.com/megaease/easegress">A Cloud Native traffic orchestration system</a><br /><a href="https://github.com/TheBobPony/getwindows11.tech">For the website</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/kwai/DouZero">[ICML 2021] DouZero: Mastering DouDizhu with Self-Play Deep Reinforcement Learning | 斗地主AI</a><br /><a href="https://github.com/programthink/opensource">【编程随想】收藏的开源项目清单</a><br /><a href="https://github.com/facebookresearch/xcit">Official code Cross-Covariance Image Transformer (XCiT)</a><br /><a href="https://github.com/githubdev03/RDP"></a><br /><a href="https://github.com/tailwindlabs/tailwindcss">A utility-first CSS framework for rapid UI development.</a><br /><a href="https://github.com/coqui-ai/TTS">🐸💬 - a deep learning toolkit for Text-to-Speech, battle-tested in research and production</a><br /><a href="https://github.com/v2fly/v2ray-core">A platform for building proxies to bypass network restrictions.</a><br /><a href="https://github.com/nothings/stb">stb single-file public domain libraries for C/C++</a><br /><a href="https://github.com/mltframework/shotcut">cross-platform (Qt), open-source (GPLv3) video editor</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><hr />二进制手表<br /><p>二进制手表顶部有 4 个 LED 代表<strong> 小时（0-11）</strong>，底部的 6 个 LED 代表<strong> 分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p>

<ul>
	<li>例如，下面的二进制手表读取 <code>"3:25"</code> 。</li>
</ul>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/29/binary_clock_samui_moon.jpg" style="height: 300px; width" /></p>

<p><small><em>（图源：<a href="https://commons.m.wikimedia.org/wiki/File:Binary_clock_samui_moon.jpg">WikiMedia - Binary clock samui moon.jpg</a> ，许可协议：<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> ）</em></small></p>

<p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>

<p>小时不会以零开头：</p>

<ul>
	<li>例如，<code>"01:00"</code> 是无效的时间，正确的写法应该是 <code>"1:00"</code> 。</li>
</ul>

<p>分钟必须由两位数组成，可能会以零开头：</p>

<ul>
	<li>例如，<code>"10:2"</code> 是无效的时间，正确的写法应该是 <code>"10:02"</code> 。</li>
</ul>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>turnedOn = 1
<strong>输出：</strong>["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>turnedOn = 9
<strong>输出：</strong>[]
</pre>

<p> </p>

<p><strong>解释：</strong></p>

<ul>
	<li><code>0 <= turnedOn <= 10</code></li>
</ul>
<br />#### 方法一：枚举时分

由题意可知，小时由 $4$ 个比特表示，分钟由 $6$ 个比特表示，比特位值为 $0$ 表示灯灭，为 $1$ 表示灯亮。

我们可以枚举小时的所有可能值 $[0,11]$，以及分钟的所有可能值 $[0,59]$，并计算二者的二进制中 $1$ 的个数之和，若为 $\textit{turnedOn}$，则将其加入到答案中。

```C++ [sol1-C++]
class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> ans;
        for (int h = 0; h < 12; ++h) {
            for (int m = 0; m < 60; ++m) {
                if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {
                    ans.push_back(to_string(h) + ":" + (m < 10 ? "0" : "") + to_string(m));
                }
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<String>();
        for (int h = 0; h < 12; ++h) {
            for (int m = 0; m < 60; ++m) {
                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                    ans.add(h + ":" + (m < 10 ? "0" : "") + m);
                }
            }
        }
        return ans;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public IList<string> ReadBinaryWatch(int turnedOn) {
        IList<String> ans = new List<String>();
        for (int h = 0; h < 12; ++h) {
            for (int m = 0; m < 60; ++m) {
                if (BitCount(h) + BitCount(m) == turnedOn) {
                    ans.Add(h + ":" + (m < 10 ? "0" : "") + m);
                }
            }
        }
        return ans;
    }

    private static int BitCount(int i) {
        i = i - ((i >> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
        i = (i + (i >> 4)) & 0x0f0f0f0f;
        i = i + (i >> 8);
        i = i + (i >> 16);
        return i & 0x3f;
    }
}
```

```go [sol1-Golang]
func readBinaryWatch(turnedOn int) (ans []string) {
    for h := uint8(0); h < 12; h++ {
        for m := uint8(0); m < 60; m++ {
            if bits.OnesCount8(h)+bits.OnesCount8(m) == turnedOn {
                ans = append(ans, fmt.Sprintf("%d:%02d", h, m))
            }
        }
    }
    return
}
```

```JavaScript [sol1-JavaScript]
var readBinaryWatch = function(turnedOn) {
    const ans = [];
    for (let h = 0; h < 12; ++h) {
        for (let m = 0; m < 60; ++m) {
            if (h.toString(2).split('0').join('').length + m.toString(2).split('0').join('').length === turnedOn) {
                ans.push(h + ":" + (m < 10 ? "0" : "") + m);
            }
        }
    }
    return ans;
};
```

```Python [sol1-Python3]
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = list()
        for h in range(12):
            for m in range(60):
                if bin(h).count("1") + bin(m).count("1") == turnedOn:
                    ans.append(f"{h}:{m:02d}")
        return ans
```

```C [sol1-C]
char** readBinaryWatch(int turnedOn, int* returnSize) {
    char** ans = malloc(sizeof(char*) * 12 * 60);
    *returnSize = 0;
    for (int h = 0; h < 12; ++h) {
        for (int m = 0; m < 60; ++m) {
            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {
                char* tmp = malloc(sizeof(char) * 6);
                sprintf(tmp, "%d:%02d", h, m);
                ans[(*returnSize)++] = tmp;
            }
        }
    }
    return ans;
}
```

**复杂度分析**

- 时间复杂度：$O(1)$。枚举的次数是一个与输入无关的定值。

- 空间复杂度：$O(1)$。仅使用了常数大小的空间。注意返回值不计入空间复杂度。

#### 方法二：二进制枚举

另一种枚举方法是枚举所有 $2^{10}=1024$ 种灯的开闭组合，即用一个二进制数表示灯的开闭，其高 $4$ 位为小时，低 $6$ 位为分钟。若小时和分钟的值均在合法范围内，且二进制中 $1$ 的个数为 $\textit{turnedOn}$，则将其加入到答案中。

```C++ [sol2-C++]
class Solution {
public:
    vector<string> readBinaryWatch(int turnedOn) {
        vector<string> ans;
        for (int i = 0; i < 1024; ++i) {
            int h = i >> 6, m = i & 63; // 用位运算取出高 4 位和低 6 位
            if (h < 12 && m < 60 && __builtin_popcount(i) == turnedOn) {
                ans.push_back(to_string(h) + ":" + (m < 10 ? "0" : "") + to_string(m));
            }
        }
        return ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> ans = new ArrayList<String>();
        for (int i = 0; i < 1024; ++i) {
            int h = i >> 6, m = i & 63; // 用位运算取出高 4 位和低 6 位
            if (h < 12 && m < 60 && Integer.bitCount(i) == turnedOn) {
                ans.add(h + ":" + (m < 10 ? "0" : "") + m);
            }
        }
        return ans;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public IList<string> ReadBinaryWatch(int turnedOn) {
        IList<String> ans = new List<String>();
        for (int i = 0; i < 1024; ++i) {
            int h = i >> 6, m = i & 63; // 用位运算取出高 4 位和低 6 位
            if (h < 12 && m < 60 && BitCount(i) == turnedOn) {
                ans.Add(h + ":" + (m < 10 ? "0" : "") + m);
            }
        }
        return ans;
    }

    private static int BitCount(int i) {
        i = i - ((i >> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
        i = (i + (i >> 4)) & 0x0f0f0f0f;
        i = i + (i >> 8);
        i = i + (i >> 16);
        return i & 0x3f;
    }
}
```

```go [sol2-Golang]
func readBinaryWatch(turnedOn int) (ans []string) {
    for i := 0; i < 1024; i++ {
        h, m := i>>6, i&63 // 用位运算取出高 4 位和低 6 位
        if h < 12 && m < 60 && bits.OnesCount(uint(i)) == turnedOn {
            ans = append(ans, fmt.Sprintf("%d:%02d", h, m))
        }
    }
    return
}
```

```JavaScript [sol2-JavaScript]
var readBinaryWatch = function(turnedOn) {
    const ans = [];
    for (let i = 0; i < 1024; ++i) {
        let h = i >> 6, m = i & 63; // 用位运算取出高 4 位和低 6 位
        if (h < 12 && m < 60 && i.toString(2).split('0').join('').length === turnedOn) {
            ans.push(h + ":" + (m < 10 ? "0" : "") + m);
        }
    }
    return ans;
};
```

```Python [sol2-Python3]
class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        ans = list()
        for i in range(1024):
            h, m = i >> 6, i & 0x3f   # 用位运算取出高 4 位和低 6 位
            if h < 12 and m < 60 and bin(i).count("1") == turnedOn:
                ans.append(f"{h}:{m:02d}")
        return ans
```

```C [sol2-C]
char** readBinaryWatch(int turnedOn, int* returnSize) {
    char** ans = malloc(sizeof(char*) * 12 * 60);
    *returnSize = 0;
    for (int i = 0; i < 1024; ++i) {
        int h = i >> 6, m = i & 63;  // 用位运算取出高 4 位和低 6 位
        if (h < 12 && m < 60 && __builtin_popcount(i) == turnedOn) {
            char* tmp = malloc(sizeof(char) * 6);
            sprintf(tmp, "%d:%02d", h, m);
            ans[(*returnSize)++] = tmp;
        }
    }

    return ans;
}
```

**复杂度分析**

- 时间复杂度：$O(1)$。枚举的次数是一个与输入无关的定值。

- 空间复杂度：$O(1)$。仅使用了常数大小的空间。注意返回值不计入空间复杂度。

本题还有利用位运算，枚举恰好有 $\textit{turnedOn}$ 个 $1$ 的二进制数的方法，但超出了这篇题解的范围，有兴趣的读者可自行查阅相关资料。