# 2021年06月02日 code
<a href="https://toutiao.io/k/xha1t37">架构师图谱（上篇）</a><br /><a href="https://toutiao.io/k/y3b2owg">Redis 集群 JedisCluster 的 pipeline 自定义实现</a><br /><a href="https://toutiao.io/k/szkr8sy">消息队列解耦是骗小孩儿的</a><br /><a href="https://toutiao.io/k/d6e55fr">搜狗面试题：IO 多路复用之 select、poll、epoll 的区别</a><br /><a href="https://toutiao.io/k/bv8je05">面试侃集合：SynchronousQueue 公平模式篇</a><br /><a href="https://toutiao.io/k/c08a0to">Google 大规模监控系统：Monarch</a><br /><a href="https://toutiao.io/k/b70jpzu">10 问 10 答：你真的了解线程池吗？</a><br /><a href="https://toutiao.io/k/jj02es0">拯救祭天的程序员：事件溯源模式</a><br /><a href="https://toutiao.io/k/2rxc164">数仓的元数据管理和上下游约定</a><br /><a href="https://toutiao.io/k/jawq9ra">JDK 动态代理：不仅要学会用，更要掌握其原理</a><br /><a href="https://toutiao.io/k/woena4v">使用 JavaScript 访问设备硬件的新标准</a><br /><a href="https://toutiao.io/k/0pukbi2">资深 DevOps 工程师揭秘：为什么你对于 DevOps 无从下手？（原则篇）</a><br /><a href="https://toutiao.io/k/vlf02z6">使用 .NET 5 自制编程语言</a><br /><a href="https://toutiao.io/k/i2afkgv">技术分享：手机推送原理剖析指南</a><br /><a href="https://toutiao.io/k/18mijcv">浅谈前端水印</a><br /><a href="https://toutiao.io/k/bmxr234">错误档案（二）：MySQL 8.0 连接 C3P0 的问题</a><br /><a href="https://toutiao.io/k/76ru5go">初探可编程网关 Pipy</a><br /><a href="https://toutiao.io/k/3y65u6s">工作五年反思</a><br /><a href="https://toutiao.io/k/v8tzj2u">58同城 Hadoop 2.6 升级 3.2 实践</a><br /><a href="https://toutiao.io/k/5qsk2x3">残影拖尾实现思路分析</a><br /><a href="https://toutiao.io/k/q62fiq2">[推荐] 如闪电划破雨夜，这些开源项目瞬间点亮了命令行</a><br /><a href="https://toutiao.io/k/cs2cbes">[推荐] 进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/18gz8ap">[推荐] 百亿规模 API 网关服务 Shepherd 的设计与实现</a><br /><a href="https://toutiao.io/k/ybiw04u">[推荐] 高并发、高性能、高可用系统设计经验</a><br /><a href="https://toutiao.io/k/sorcj5w">[推荐] 深入源码，深度解析 Java 线程池的实现原理</a><br /><a href="https://toutiao.io/k/5u1byn9">[推荐] 各厂三年 Go 面经，已入字节</a><br /><a href="https://toutiao.io/k/osge9c2">[推荐] 这款远程桌面软件开源了</a><br /><a href="https://toutiao.io/k/bzx7ri7">[推荐] Spring Boot 开发秘籍：集成参数校验及高阶技巧</a><br /><a href="https://toutiao.io/k/q8zmevp">[推荐] 高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/t1o49fm">[推荐] 企业微信万亿级日志检索系统</a><br /><a href="https://toutiao.io/k/obo72ks">[推荐] 听叔一句劝，消息队列的水太深，你把握不住</a><br /><a href="https://toutiao.io/k/s8xgae9">[推荐] 掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/pws2m3l">[推荐] 微软又一个数据可视化神器开源了！非常酷炫</a><br /><a href="https://toutiao.io/k/ep5e8sd">[推荐] 亿级系统的 Redis 缓存如何设计？</a><br /><a href="https://toutiao.io/k/5za3e5u">[推荐] Golang 内存管理分析</a><br /><hr /><a href="https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot">This is a fully functioning Binance trading bot that measures the volatility of every coin on Binance and places trades with the highest gaining coins If you like this project consider donating though the Brave browser to allow me to continuously improve the script.</a><br /><a href="https://github.com/login?return_to=%2Fbinji%2Fpokegb">A gameboy emulator that only plays Pokemon Blue, in ~70 lines of c++.</a><br /><a href="https://github.com/merry75/educative.io_courses">this is downloadings of all educative.io free student subscription courses as pdf from GitHub student pack</a><br /><a href="https://github.com/CyC2018/CS-Notes">📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</a><br /><a href="https://github.com/alibaba/PolarDB-for-PostgreSQL"></a><br /><a href="https://github.com/SerenityOS/serenity">The Serenity Operating System 🐞</a><br /><a href="https://github.com/CodingGay/BlackDex">BlackDex is an Android unpack(dexdump) tool, it supports Android 5.0~12 and need not rely to any environment. BlackDex can run on any Android mobile phones or emulators, you can unpack APK File in several seconds.</a><br /><a href="https://github.com/openwrt/openwrt">This repository is a mirror of https://git.openwrt.org/openwrt/openwrt.git It is for reference only and is not active for check-ins or for reporting issues. We will continue to accept Pull Requests here. They will be merged via staging trees then into openwrt.git. All issues should be reported at: https://bugs.openwrt.org</a><br /><a href="https://github.com/leecobaby/shortcuts">自动养猫|自动淘金币|自动欢乐造|抢购助手|快捷指令</a><br /><a href="https://github.com/microsoft/winget-pkgs">The Microsoft community Windows Package Manager manifest repository</a><br /><a href="https://github.com/apache/dubbo">Apache Dubbo is a high-performance, java based, open source RPC framework.</a><br /><a href="https://github.com/login?return_to=%2Fnocodb%2Fnocodb">🔥 🔥 The Open Source Airtable alternative</a><br /><a href="https://github.com/MonsterNone/tmall-miao">天猫618/双十一喵币/年货节芭芭农场任务一键完成（绕过淘宝检测，新版淘宝也能用）</a><br /><a href="https://github.com/521xueweihan/HelloGitHub">分享 GitHub 上有趣、入门级的开源项目</a><br /><a href="https://github.com/microsoft/winget-cli">Windows Package Manager CLI (aka winget)</a><br /><a href="https://github.com/Tencent/flare">Flare是广泛投产于腾讯广告后台的现代化C++开发框架，包含了基础库、RPC、各种客户端等。主要特点为易用性强、长尾延迟低。</a><br /><a href="https://github.com/beiliangshizi/China_House">中国买房相关资料和项目整理，方便查看，持续更新中...</a><br /><a href="https://github.com/koreader/koreader">An ebook reader application supporting PDF, DjVu, EPUB, FB2 and many more formats, running on Cervantes, Kindle, Kobo, PocketBook and Android devices</a><br /><a href="https://github.com/roseduan/rosedb">A simple k-v database in pure Golang, supports string, list, hash, set, sorted set. Go 语言实现的 k-v 数据库项目，简洁易懂，适合新手进阶，欢迎 Pr！</a><br /><a href="https://github.com/ytdl-org/youtube-dl">Command-line program to download videos from YouTube.com and other video sites</a><br /><a href="https://github.com/Rikj000/MoniGoMani">Isn't that what we all want? Our money to go many? Well that's what this strategy hopes to do for you! By giving you/HyperOpt a lot of signals to alter the weight from.</a><br /><a href="https://github.com/login?return_to=%2Filuwatar%2Fjava-design-patterns">Design patterns implemented in Java</a><br /><a href="https://github.com/login?return_to=%2Fdeepfakes%2Ffaceswap">Deepfakes Software For All</a><br /><a href="https://github.com/TheAlgorithms/Java">All Algorithms implemented in Java</a><br /><a href="https://github.com/Snailclimb/JavaGuide">「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！</a><br /><hr />连续的子数组和<br /><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>

<ul>
	<li>子数组大小 <strong>至少为 2</strong> ，且</li>
	<li>子数组元素总和为 <code>k</code> 的倍数。</li>
</ul>

<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [23<u>,2,4</u>,6,7], k = 6
<strong>输出：</strong>true
<strong>解释：</strong>[2,4] 是一个大小为 2 的子数组，并且和为 6 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [<u>23,2,6,4,7</u>], k = 6
<strong>输出：</strong>true
<strong>解释：</strong>[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [23,2,6,4,7], k = 13
<strong>输出：</strong>false
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>
	<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>
	<li><code>0 <= sum(nums[i]) <= 2<sup>31</sup> - 1</code></li>
	<li><code>1 <= k <= 2<sup>31</sup> - 1</code></li>
</ul>
<br />#### 方法一：前缀和 + 哈希表

朴素的思路是遍历数组 $\textit{nums}$ 的每个大小至少为 $2$ 的子数组并计算每个子数组的元素和，判断是否存在一个子数组的元素和为 $k$ 的倍数。当数组 $\textit{nums}$ 的长度为 $m$ 时，上述思路需要用 $O(m^2)$ 的时间遍历全部子数组，对于每个子数组需要 $O(m)$ 的时间计算元素和，因此时间复杂度是 $O(m^3)$，会超出时间限制，因此必须优化。

如果事先计算出数组 $\textit{nums}$ 的前缀和数组，则对于任意一个子数组，都可以在 $O(1)$ 的时间内得到其元素和。用 $\textit{prefixSums}[i]$ 表示数组 $\textit{nums}$ 从下标 $0$ 到下标 $i$ 的前缀和，则 $\textit{nums}$ 从下标 $p+1$ 到下标 $q$（其中 $p<q$）的子数组的长度为 $q-p$，该子数组的元素和为 $\textit{prefixSums}[q]-\textit{prefixSums}[p]$。

如果 $\textit{prefixSums}[q]-\textit{prefixSums}[p]$ 为 $k$ 的倍数，且 $q-p \ge 2$，则上述子数组即满足大小至少为 $2$ 且元素和为 $k$ 的倍数。

当 $\textit{prefixSums}[q]-\textit{prefixSums}[p]$ 为 $k$ 的倍数时，$\textit{prefixSums}[p]$ 和 $\textit{prefixSums}[q]$ 除以 $k$ 的余数相同。因此只需要计算每个下标对应的前缀和除以 $k$ 的余数即可，使用哈希表存储每个余数第一次出现的下标。

规定空的前缀的结束下标为 $-1$，由于空的前缀的元素和为 $0$，因此在哈希表中存入键值对 $(0,-1)$。对于 $0 \le i<m$，从小到大依次遍历每个 $i$，计算每个下标对应的前缀和除以 $k$ 的余数，并维护哈希表：

- 如果当前余数在哈希表中已经存在，则取出该余数在哈希表中对应的下标 $\textit{prevIndex}$，$\textit{nums}$ 从下标 $\textit{prevIndex}+1$ 到下标 $i$ 的子数组的长度为 $i-\textit{prevIndex}$，该子数组的元素和为 $k$ 的倍数，如果 $i-\textit{prevIndex} \ge 2$，则找到了一个大小至少为 $2$ 且元素和为 $k$ 的倍数的子数组，返回 $\text{true}$；

- 如果当前余数在哈希表中不存在，则将当前余数和当前下标 $i$ 的键值对存入哈希表中。

由于哈希表存储的是每个余数第一次出现的下标，因此当遇到重复的余数时，根据当前下标和哈希表中存储的下标计算得到的子数组长度是以当前下标结尾的子数组中满足元素和为 $k$ 的倍数的子数组长度中的最大值。只要最大长度至少为 $2$，即存在符合要求的子数组。

```Java [sol1-Java]
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int m = nums.length;
        if (m < 2) {
            return false;
        }
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(0, -1);
        int remainder = 0;
        for (int i = 0; i < m; i++) {
            remainder = (remainder + nums[i]) % k;
            if (map.containsKey(remainder)) {
                int prevIndex = map.get(remainder);
                if (i - prevIndex >= 2) {
                    return true;
                }
            } else {
                map.put(remainder, i);
            }
        }
        return false;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public bool CheckSubarraySum(int[] nums, int k) {
        int m = nums.Length;
        if (m < 2) {
            return false;
        }
        Dictionary<int, int> dictionary = new Dictionary<int, int>();
        dictionary.Add(0, -1);
        int remainder = 0;
        for (int i = 0; i < m; i++) {
            remainder = (remainder + nums[i]) % k;
            if (dictionary.ContainsKey(remainder)) {
                int prevIndex = dictionary[remainder];
                if (i - prevIndex >= 2) {
                    return true;
                }
            } else {
                dictionary.Add(remainder, i);
            }
        }
        return false;
    }
}
```

```JavaScript [sol1-JavaScript]
var checkSubarraySum = function(nums, k) {
    const m = nums.length;
    if (m < 2) {
        return false;
    }
    const map = new Map();
    map.set(0, -1);
    let remainder = 0;
    for (let i = 0; i < m; i++) {
        remainder = (remainder + nums[i]) % k;
        if (map.has(remainder)) {
            const prevIndex = map.get(remainder);
            if (i - prevIndex >= 2) {
                return true;
            }
        } else {
            map.set(remainder, i);
        }
    }
    return false;
};
```

```go [sol1-Golang]
func checkSubarraySum(nums []int, k int) bool {
    m := len(nums)
    if m < 2 {
        return false
    }
    mp := map[int]int{0: -1}
    remainder := 0
    for i, num := range nums {
        remainder = (remainder + num) % k
        if prevIndex, has := mp[remainder]; has {
            if i-prevIndex >= 2 {
                return true
            }
        } else {
            mp[remainder] = i
        }
    }
    return false
}
```

```C++ [sol1-C++]
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int m = nums.size();
        if (m < 2) {
            return false;
        }
        unordered_map<int, int> mp;
        mp[0] = -1;
        int remainder = 0;
        for (int i = 0; i < m; i++) {
            remainder = (remainder + nums[i]) % k;
            if (mp.count(remainder)) {
                int prevIndex = mp[remainder];
                if (i - prevIndex >= 2) {
                    return true;
                }
            } else {
                mp[remainder] = i;
            }
        }
        return false;
    }
};
```

```C [sol1-C]
struct HashTable {
    int key, val;
    UT_hash_handle hh;
};

bool checkSubarraySum(int* nums, int numsSize, int k) {
    int m = numsSize;
    if (m < 2) {
        return false;
    }
    struct HashTable* hashTable = NULL;
    struct HashTable* tmp = malloc(sizeof(struct HashTable));
    tmp->key = 0, tmp->val = -1;
    HASH_ADD_INT(hashTable, key, tmp);
    int remainder = 0;
    for (int i = 0; i < m; i++) {
        remainder = (remainder + nums[i]) % k;
        HASH_FIND_INT(hashTable, &remainder, tmp);
        if (tmp != NULL) {
            int prevIndex = tmp->val;
            if (i - prevIndex >= 2) {
                return true;
            }
        } else {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = remainder, tmp->val = i;
            HASH_ADD_INT(hashTable, key, tmp);
        }
    }
    return false;
}
```

**复杂度分析**

- 时间复杂度：$O(m)$，其中 $m$ 是数组 $\textit{nums}$ 的长度。需要遍历数组一次。

- 空间复杂度：$O(\min(m,k))$，其中 $m$ 是数组 $\textit{nums}$ 的长度。空间复杂度主要取决于哈希表，哈希表中存储每个余数第一次出现的下标，最多有 $\min(m,k)$ 个余数。