# 2021年05月05日 code
<a href="https://toutiao.io/k/ok4mp6n">五一假期不想人挤人？来这里！</a><br /><a href="https://toutiao.io/k/0jalngx">WebRTC 噪声抑制模块分析与实践</a><br /><a href="https://toutiao.io/k/veymhfk">一个新细节，Go 1.17 将允许切片转换为数组指针</a><br /><a href="https://toutiao.io/k/3zyt2c7">日访问过亿，办公 IM 及开放式平台在携程的实践</a><br /><a href="https://toutiao.io/k/e7r8hkj">Docker 实战：用 docker-compose 搭建 Laravel 开发环境</a><br /><a href="https://toutiao.io/k/b5bv4dl">特征工程方法总结</a><br /><a href="https://toutiao.io/k/4wrlkf7">聊聊因不恰当使用 alibaba sentinel 而踩到的坑</a><br /><a href="https://toutiao.io/k/4hok6wf">搞懂 JavaScript 类型转换</a><br /><a href="https://toutiao.io/k/6x3rb9r">聊天机器人真不是人，我放心了，不用担心隐私暴露</a><br /><a href="https://toutiao.io/k/7fuz48b">MCN 搭配评价模型论文笔记</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><a href="https://toutiao.io/k/90vs9kg">[推荐] ClickHouse 在 Bilibili 用户行为分析的实践</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/2aonyjp">[推荐] 把 Redis 当作队列来用，真的合适吗？</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/fwtxydd">[推荐] 架构模式之分层架构总结</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/0etokja">[推荐] Kafka：这次分享我只想把原理讲清楚</a><br /><hr /><a href="https://github.com/kartikey54/VaccineAvailabilityNotifier"></a><br /><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">Bootstrap Kubernetes the hard way on Google Cloud Platform. No scripts.</a><br /><a href="https://github.com/DIGITALCRIMINAL/OnlyFans">Scrape all the media from an OnlyFans account - Updated regularly</a><br /><a href="https://github.com/facebookresearch/dino">PyTorch code for Vision Transformers training with the Self-Supervised learning method DINO</a><br /><a href="https://github.com/github/docs">The open-source repo for docs.github.com</a><br /><a href="https://github.com/bhattbhavesh91/cowin-vaccination-slot-availability">Script to check the available slots for Covid-19 Vaccination Centers from CoWIN API in India</a><br /><a href="https://github.com/flashlight/flashlight">A C++ standalone library for machine learning</a><br /><a href="https://github.com/thedevdojo/wave">Wave - The Software as a Service Starter Kit, designed to help you build the SAAS of your dreams 🚀 💰</a><br /><a href="https://github.com/tldr-pages/tldr">📚 Collaborative cheatsheets for console commands</a><br /><a href="https://github.com/pballett/whatfreewords"></a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/nvbn/thefuck">Magnificent app which corrects your previous console command.</a><br /><a href="https://github.com/commaai/openpilot">openpilot is an open source driver assistance system. openpilot performs the functions of Automated Lane Centering and Adaptive Cruise Control for over 100 supported car makes and models.</a><br /><a href="https://github.com/labnol/covid19-vaccine-tracker">Covid-19 Vaccines Near me</a><br /><a href="https://github.com/vfat-tools/vfat-tools"></a><br /><a href="https://github.com/hsjoberg/fork-explorer">Check how a BIP9-like softfork signalling goes</a><br /><a href="https://github.com/jlevy/the-art-of-command-line">Master the command line, in one page</a><br /><a href="https://github.com/torvalds/linux">Linux kernel source tree</a><br /><a href="https://github.com/git-tips/tips">Most commonly used git tips and tricks.</a><br /><a href="https://github.com/login?return_to=%2Falecthomas%2Fchroma">A general purpose syntax highlighter in pure Go</a><br /><a href="https://github.com/aws-amplify/amplify-cli">The AWS Amplify CLI is a toolchain for simplifying serverless web and mobile development.</a><br /><a href="https://github.com/ethereum/solidity">Solidity, the Smart Contract Programming Language</a><br /><a href="https://github.com/projectdiscovery/interactsh">An OOB interaction gathering server and client library</a><br /><a href="https://github.com/ionic-team/ionic-framework">A powerful cross-platform UI toolkit for building native-quality iOS, Android, and Progressive Web Apps with HTML, CSS, and JavaScript.</a><br /><hr />删除并获得点数<br /><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p>

<p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除<strong>每个</strong>等于 <code>nums[i] - 1</code> 或 <code>nums[i] + 1</code> 的元素。</p>

<p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,4,2]
<strong>输出：</strong>6
<strong>解释：</strong>
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,2,3,3,3,4]
<strong>输出：</strong>9
<strong>解释：</strong>
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>
	<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>
</ul>
<br />#### 方法一：动态规划

**思路**

根据题意，在选择了元素 $x$ 后，该元素以及所有等于 $x-1$ 或 $x+1$ 的元素会从数组中删去。若还有多个值为 $x$ 的元素，由于所有等于 $x-1$ 或 $x+1$ 的元素已经被删除，我们可以直接删除 $x$ 并获得其点数。因此若选择了 $x$，所有等于 $x$ 的元素也应一同被选择，以尽可能多地获得点数。

记元素 $x$ 在数组中出现的次数为 $c_x$，我们可以用一个数组 $sum$ 记录数组 $\textit{nums}$ 中所有相同元素之和，即 $\textit{sum}[x]=x\cdot c_x$。若选择了 $x$，则可以获取 $\textit{sum}[x]$ 的点数，且无法再选择 $x-1$ 和 $x+1$。这与「[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)」是一样的，在统计出 $\textit{sum}$ 数组后，读者可参考「[198. 打家劫舍的官方题解](https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/)」中的动态规划过程计算出答案。

**代码**

```C++ [sol1-C++]
class Solution {
private:
    int rob(vector<int> &nums) {
        int size = nums.size();
        int first = nums[0], second = max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = max(first + nums[i], second);
            first = temp;
        }
        return second;
    }

public:
    int deleteAndEarn(vector<int> &nums) {
        int maxVal = 0;
        for (int val : nums) {
            maxVal = max(maxVal, val);
        }
        vector<int> sum(maxVal + 1);
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }
};
```

```Java [sol1-Java]
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = 0;
        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }
        int[] sum = new int[maxVal + 1];
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }

    public int rob(int[] nums) {
        int size = nums.length;
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int DeleteAndEarn(int[] nums) {
        int maxVal = 0;
        foreach (int val in nums) {
            maxVal = Math.Max(maxVal, val);
        }
        int[] sum = new int[maxVal + 1];
        foreach (int val in nums) {
            sum[val] += val;
        }
        return Rob(sum);
    }

    public int Rob(int[] nums) {
        int size = nums.Length;
        int first = nums[0], second = Math.Max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.Max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

```go [sol1-Golang]
func deleteAndEarn(nums []int) int {
    maxVal := 0
    for _, val := range nums {
        maxVal = max(maxVal, val)
    }
    sum := make([]int, maxVal+1)
    for _, val := range nums {
        sum[val] += val
    }
    return rob(sum)
}

func rob(nums []int) int {
    first, second := nums[0], max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        first, second = second, max(first+nums[i], second)
    }
    return second
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```Python [sol1-Python3]
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        maxVal = max(nums)
        total = [0] * (maxVal + 1)
        for val in nums:
            total[val] += val
        
        def rob(nums: List[int]) -> int:
            size = len(nums)
            first, second = nums[0], max(nums[0], nums[1])
            for i in range(2, size):
                first, second = second, max(first + nums[i], second)
            return second
        
        return rob(total)
```

```C [sol1-C]
int rob(int *nums, int numsSize) {
    int first = nums[0], second = fmax(nums[0], nums[1]);
    for (int i = 2; i < numsSize; i++) {
        int temp = second;
        second = fmax(first + nums[i], second);
        first = temp;
    }
    return second;
}

int deleteAndEarn(int *nums, int numsSize) {
    int maxVal = 0;
    for (int i = 0; i < numsSize; i++) {
        maxVal = fmax(maxVal, nums[i]);
    }
    int sum[maxVal + 1];
    memset(sum, 0, sizeof(sum));
    for (int i = 0; i < numsSize; i++) {
        sum[nums[i]] += nums[i];
    }
    return rob(sum, maxVal + 1);
}
```

```JavaScript [sol1-JavaScript]
var deleteAndEarn = function(nums) {
    let maxVal = 0;
    for (const val of nums) {
        maxVal = Math.max(maxVal, val);
    }
    const sum = new Array(maxVal + 1).fill(0);
    for (const val of nums) {
        sum[val] += val;
    }
    return rob(sum);
};

const rob = (nums) => {
    const size = nums.length;
    let first = nums[0], second = Math.max(nums[0], nums[1]);
    for (let i = 2; i < size; i++) {
        let temp = second;
        second = Math.max(first + nums[i], second);
        first = temp;
    }
    return second;
}
```

**复杂度分析**

- 时间复杂度：$O(N+M)$，其中 $N$ 是数组 $\textit{nums}$ 的长度，$M$ 是 $\textit{nums}$ 中元素的最大值。

- 空间复杂度：$O(M)$。

#### 方法二：排序 + 动态规划

注意到若 $\textit{nums}$ 中不存在某个元素 $x$，则选择任一小于 $x$ 的元素不会影响到大于 $x$ 的元素的选择。因此我们可以将 $\textit{nums}$ 排序后，将其划分成若干连续子数组，子数组内任意相邻元素之差不超过 $1$。对每个子数组按照方法一的动态规划过程计算出结果，累加所有结果即为答案。

**代码**

```C++ [sol2-C++]
class Solution {
private:
    int rob(vector<int> &nums) {
        int size = nums.size();
        if (size == 1) {
            return nums[0];
        }
        int first = nums[0], second = max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = max(first + nums[i], second);
            first = temp;
        }
        return second;
    }

public:
    int deleteAndEarn(vector<int> &nums) {
        int n = nums.size();
        int ans = 0;
        sort(nums.begin(), nums.end());
        vector<int> sum = {nums[0]};
        for (int i = 1; i < n; ++i) {
            int val = nums[i];
            if (val == nums[i - 1]) {
                sum.back() += val;
            } else if (val == nums[i - 1] + 1) {
                sum.push_back(val);
            } else {
                ans += rob(sum);
                sum = {val};
            }
        }
        ans += rob(sum);
        return ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    public int deleteAndEarn(int[] nums) {
        int n = nums.length;
        int ans = 0;
        Arrays.sort(nums);
        List<Integer> sum = new ArrayList<Integer>();
        sum.add(nums[0]);
        int size = 1;
        for (int i = 1; i < n; ++i) {
            int val = nums[i];
            if (val == nums[i - 1]) {
                sum.set(size - 1, sum.get(size - 1) + val);
            } else if (val == nums[i - 1] + 1) {
                sum.add(val);
                ++size;
            } else {
                ans += rob(sum);
                sum.clear();
                sum.add(val);
                size = 1;
            }
        }
        ans += rob(sum);
        return ans;
    }

    public int rob(List<Integer> nums) {
        int size = nums.size();
        if (size == 1) {
            return nums.get(0);
        }
        int first = nums.get(0), second = Math.max(nums.get(0), nums.get(1));
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums.get(i), second);
            first = temp;
        }
        return second;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int DeleteAndEarn(int[] nums) {
        int n = nums.Length;
        int ans = 0;
        Array.Sort(nums);
        IList<int> sum = new List<int>();
        sum.Add(nums[0]);
        int size = 1;
        for (int i = 1; i < n; ++i) {
            int val = nums[i];
            if (val == nums[i - 1]) {
                sum[size - 1] += val;
            } else if (val == nums[i - 1] + 1) {
                sum.Add(val);
                ++size;
            } else {
                ans += Rob(sum);
                sum.Clear();
                sum.Add(val);
                size = 1;
            }
        }
        ans += Rob(sum);
        return ans;
    }

    public int Rob(IList<int> nums) {
        int size = nums.Count;
        if (size == 1) {
            return nums[0];
        }
        int first = nums[0], second = Math.Max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.Max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

```go [sol2-Golang]
func deleteAndEarn(nums []int) (ans int) {
    sort.Ints(nums)
    sum := []int{nums[0]}
    for i := 1; i < len(nums); i++ {
        if val := nums[i]; val == nums[i-1] {
            sum[len(sum)-1] += val
        } else if val == nums[i-1]+1 {
            sum = append(sum, val)
        } else {
            ans += rob(sum)
            sum = []int{val}
        }
    }
    ans += rob(sum)
    return
}

func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    first, second := nums[0], max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        first, second = second, max(first+nums[i], second)
    }
    return second
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```Python [sol2-Python3]
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        def rob(nums: List[int]) -> int:
            size = len(nums)
            if size == 1:
                return nums[0]

            first, second = nums[0], max(nums[0], nums[1])
            for i in range(2, size):
                first, second = second, max(first + nums[i], second)
            return second
        
        n = len(nums)
        ans = 0
        nums.sort()
        total = [nums[0]]

        for i in range(1, n):
            val = nums[i]
            if val == nums[i - 1]:
                total[-1] += val
            elif val == nums[i - 1] + 1:
                total.append(val)
            else:
                ans += rob(total)
                total = [val]
        
        ans += rob(total)
        return ans
```

```C [sol2-C]
int rob(int *nums, int numsSize) {
    if (numsSize == 1) {
        return nums[0];
    }
    int first = nums[0], second = fmax(nums[0], nums[1]);
    for (int i = 2; i < numsSize; i++) {
        int temp = second;
        second = fmax(first + nums[i], second);
        first = temp;
    }
    return second;
}

int cmp(int *a, int *b) {
    return *a - *b;
}

int deleteAndEarn(int *nums, int numsSize) {
    int ans = 0;
    qsort(nums, numsSize, sizeof(int), cmp);
    int sum[numsSize], sumSize = 0;
    sum[sumSize++] = nums[0];
    for (int i = 1; i < numsSize; ++i) {
        int val = nums[i];
        if (val == nums[i - 1]) {
            sum[sumSize - 1] += val;
        } else if (val == nums[i - 1] + 1) {
            sum[sumSize++] = val;
        } else {
            ans += rob(sum, sumSize);
            sumSize = 0;
            sum[sumSize++] = val;
        }
    }
    ans += rob(sum, sumSize);
    return ans;
}
```

```JavaScript [sol2-JavaScript]
var deleteAndEarn = function(nums) {
    const rob = (nums) => {
        const size = nums.length;
        if (size === 1) {
            return nums[0];
        }

        let [first, second] = [nums[0], Math.max(nums[0], nums[1])];
        for (let i = 2; i < size; i++) {
            [first, second] = [second, Math.max(first + nums[i], second)];
        }
        return second;
    }

    const n = nums.length;
    let ans = 0;
    nums.sort((a, b) => a - b);
    total = [nums[0]];

    for (let i = 1; i < n; i++) {
        const val = nums[i];
        if (val === nums[i - 1]) {
            total[total.length - 1] += val;
        } else if (val === nums[i - 1] + 1) {
            total.push(val);
        } else {
            ans += rob(total);
            total = [val];
        }
    }
    ans += rob(total);
    return ans;
};
```

**复杂度分析**

- 时间复杂度：$O(N\log N)$，其中 $N$ 是数组 $\textit{nums}$ 的长度。对 $\textit{nums}$ 排序需要花费 $O(N\log N)$ 的时间，遍历计算需要花费 $O(N)$ 的时间，故总的时间复杂度为 $O(N\log N)$。

- 空间复杂度：$O(N)$。统计 $\textit{sum}$ 至多需要花费 $O(N)$ 的空间。