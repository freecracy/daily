# 2021年05月02日 code
<a href="https://toutiao.io/k/1nwsx5k">万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/mx661vn">Redis 破障之路（三）：Redis 单线程架构</a><br /><a href="https://toutiao.io/k/9qrsvdn">系统高可用之健康检查和健康度量那些事</a><br /><a href="https://toutiao.io/k/my7c6ad">如何更好使用多线程</a><br /><a href="https://toutiao.io/k/7e5tpja">并发编程：内存模型</a><br /><a href="https://toutiao.io/k/t9rxs07">Hive 千亿级数据倾斜解决方案</a><br /><a href="https://toutiao.io/k/acm9zuw">零故障上云全过程再现，PB 级数据迁移如何保障一致性？</a><br /><a href="https://toutiao.io/k/ok4mp6n">五一假期不想人挤人？来这里！</a><br /><a href="https://toutiao.io/k/t42ku89">记一次失败的发布过程</a><br /><a href="https://toutiao.io/k/aq1otgu">以太坊交互工具</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/90vs9kg">[推荐] ClickHouse 在 Bilibili 用户行为分析的实践</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/2aonyjp">[推荐] 把 Redis 当作队列来用，真的合适吗？</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><hr /><a href="https://github.com/login?return_to=%2Fsupabase%2Fsupabase">The open source Firebase alternative. Follow to stay updated about our public Beta.</a><br /><a href="https://github.com/Kotlin/kmm-production-sample"></a><br /><a href="https://github.com/commaai/openpilot">openpilot is an open source driver assistance system. openpilot performs the functions of Automated Lane Centering and Adaptive Cruise Control for over 100 supported car makes and models.</a><br /><a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a><br /><a href="https://github.com/raydium-io/raydium-ui"></a><br /><a href="https://github.com/twintproject/twint">An advanced Twitter scraping & OSINT tool written in Python that doesn't use Twitter's API, allowing you to scrape a user's followers, following, Tweets and more while evading most API limitations.</a><br /><a href="https://github.com/wisz2021/jd_docker">仅用查看文档</a><br /><a href="https://github.com/passerby-b/JDDJ">京东到家果园庄园脚本,电报群:https://t.me/joinchat/wH4Ks3mT6mxiMDg1</a><br /><a href="https://github.com/TritonHo/slides">it is a repository to store all slides used by Triton Ho's public presentation and course.</a><br /><a href="https://github.com/wuyouzhuguli/SpringAll">循序渐进，学习Spring Boot、Spring Boot & Shiro、Spring Batch、Spring Cloud、Spring Cloud Alibaba、Spring Security & Spring Security OAuth2，博客Spring系列源码：https://mrbird.cc</a><br /><a href="https://github.com/Developer-Y/cs-video-courses">List of Computer Science courses with video lectures.</a><br /><a href="https://github.com/androidmalware/android_hid">Use Android as Rubber Ducky against another Android device</a><br /><a href="https://github.com/doocs/leetcode">😏 LeetCode solutions in any programming language | 多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解</a><br /><a href="https://github.com/flashlight/flashlight">A C++ standalone library for machine learning</a><br /><a href="https://github.com/Datalux/Osintgram">Osintgram is a OSINT tool on Instagram. It offers an interactive shell to perform analysis on Instagram account of any users by its nickname</a><br /><a href="https://github.com/chrisleekr/binance-trading-bot">Automated Binance trading bot - Buy low/Sell high with stop loss limit/Trade multiple cryptocurrencies</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/nrwl/nx">Powerful, Extensible Dev Tools</a><br /><a href="https://github.com/nextapps-de/winbox">WinBox is a professional HTML5 window manager for the web: lightweight, outstanding performance, no dependencies, fully customizable, open source!</a><br /><a href="https://github.com/thedevdojo/wave">Wave - The Software as a Service Starter Kit, designed to help you build the SAAS of your dreams 🚀 💰</a><br /><a href="https://github.com/521xueweihan/HelloGitHub">分享 GitHub 上有趣、入门级的开源项目</a><br /><a href="https://github.com/PaddlePaddle/PaddleDetection">Object detection and instance segmentation toolkit based on PaddlePaddle.</a><br /><a href="https://github.com/yuk1ty/learning-systems-programming-in-rust">「Rustでもわかるシステムプログラミング」</a><br /><a href="https://github.com/terraform-providers/terraform-provider-azurerm">Terraform provider for Azure Resource Manager</a><br /><a href="https://github.com/OWASP/CheatSheetSeries">The OWASP Cheat Sheet Series was created to provide a concise collection of high value information on specific application security topics.</a><br /><hr />砖墙<br /><p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。</p>

<p>你现在要画一条 <strong>自顶向下 </strong>的、穿过 <strong>最少 </strong>砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>

<p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg" style="width: 493px; height: 577px;" />
<pre>
<strong>输入：</strong>wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
<strong>输出：</strong>2
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>wall = [[1],[1],[1]]
<strong>输出：</strong>3
</pre>
 

<p><strong>提示：</strong></p>

<ul>
	<li><code>n == wall.length</code></li>
	<li><code>1 <= n <= 10<sup>4</sup></code></li>
	<li><code>1 <= wall[i].length <= 10<sup>4</sup></code></li>
	<li><code>1 <= sum(wall[i].length) <= 2 * 10<sup>4</sup></code></li>
	<li>对于每一行 <code>i</code> ，<code>sum(wall[i])</code> 应当是相同的</li>
	<li><code>1 <= wall[i][j] <= 2<sup>31</sup> - 1</code></li>
</ul>
<br />#### 方法一：哈希表

**思路及算法**

由于砖墙是一面矩形，所以对于任意一条垂线，其穿过的砖块数量加上从边缘经过的砖块数量之和是一个定值，即砖墙的高度。

因此，问题可以转换成求「垂线穿过的砖块边缘数量的最大值」，用砖墙的高度减去该最大值即为答案。

虽然垂线在每行至多只能通过一个砖块边缘，但是每行的砖块边缘也各不相同，因此我们需要用哈希表统计所有符合要求的砖块边缘的数量。

注意到题目要求垂线不能通过砖墙的两个垂直边缘，所以砖墙两侧的边缘不应当被统计。因此，我们只需要统计每行砖块中除了最右侧的砖块以外的其他砖块的右边缘即可。

具体地，我们遍历砖墙的每一行，对于当前行，我们从左到右地扫描每一块砖，使用一个累加器记录当前砖的右侧边缘到砖墙的左边缘的距离，将除了最右侧的砖块以外的其他砖块的右边缘到砖墙的左边缘的距离加入到哈希表中。最后我们遍历该哈希表，找到出现次数最多的砖块边缘，这就是垂线经过的砖块边缘，而该垂线经过的砖块数量即为砖墙的高度减去该垂线经过的砖块边缘的数量。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        unordered_map<int, int> cnt;
        for (auto& widths : wall) {
            int n = widths.size();
            int sum = 0;
            for (int i = 0; i < n - 1; i++) {
                sum += widths[i];
                cnt[sum]++;
            }
        }
        int maxCnt = 0;
        for (auto& [_, c] : cnt) {
            maxCnt = max(maxCnt, c);
        }
        return wall.size() - maxCnt;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for (List<Integer> widths : wall) {
            int n = widths.size();
            int sum = 0;
            for (int i = 0; i < n - 1; i++) {
                sum += widths.get(i);
                cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
            }
        }
        int maxCnt = 0;
        for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {
            maxCnt = Math.max(maxCnt, entry.getValue());
        }
        return wall.size() - maxCnt;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int LeastBricks(IList<IList<int>> wall) {
        Dictionary<int, int> cnt = new Dictionary<int, int>();
        foreach (IList<int> widths in wall) {
            int n = widths.Count;
            int sum = 0;
            for (int i = 0; i < n - 1; i++) {
                sum += widths[i];
                if (!cnt.ContainsKey(sum)) {
                    cnt.Add(sum, 1);
                } else {
                    cnt[sum]++;
                }
            }
        }
        int maxCnt = 0;
        foreach (var entry in cnt) {
            maxCnt = Math.Max(maxCnt, entry.Value);
        }
        return wall.Count - maxCnt;
    }
}
```

```JavaScript [sol1-JavaScript]
var leastBricks = function(wall) {
    const cnt = new Map();
    for (const widths of wall) {
        const n = widths.length;
        let sum = 0;
        for (let i = 0; i < n - 1; i++) {
            sum += widths[i];
            cnt.set(sum, (cnt.get(sum) || 0) + 1);
        }
    }
    let maxCnt = 0;
    for (const [_, c] of cnt.entries()) {
        maxCnt = Math.max(maxCnt, c);
    }
    return wall.length - maxCnt;
};
```

```go [sol1-Golang]
func leastBricks(wall [][]int) int {
    cnt := map[int]int{}
    for _, widths := range wall {
        sum := 0
        for _, width := range widths[:len(widths)-1] {
            sum += width
            cnt[sum]++
        }
    }
    maxCnt := 0
    for _, c := range cnt {
        if c > maxCnt {
            maxCnt = c
        }
    }
    return len(wall) - maxCnt
}
```

```C [sol1-C]
struct HashTable {
    int key, val;
    UT_hash_handle hh;
};

int leastBricks(int** wall, int wallSize, int* wallColSize) {
    struct HashTable* cnt = NULL;
    for (int i = 0; i < wallSize; i++) {
        int n = wallColSize[i];
        int sum = 0;
        for (int j = 0; j < n - 1; j++) {
            sum += wall[i][j];
            struct HashTable* tmp;
            HASH_FIND_INT(cnt, &sum, tmp);
            if (tmp == NULL) {
                tmp = malloc(sizeof(struct HashTable));
                tmp->key = sum, tmp->val = 1;
                HASH_ADD_INT(cnt, key, tmp);
            } else {
                tmp->val++;
            }
        }
    }
    int maxCnt = 0;
    struct HashTable *iter, *tmp;
    HASH_ITER(hh, cnt, iter, tmp) {
        maxCnt = fmax(maxCnt, iter->val);
    }
    return wallSize - maxCnt;
}
```

**复杂度分析**

- 时间复杂度：$O(nm)$，其中 $n$ 是砖墙的高度，$m$ 是每行砖墙的砖的平均数量。我们需要遍历每行砖块中除了最右侧的砖块以外的每一块砖，将其右侧边缘到砖墙的左边缘的距离加入到哈希表中。

- 空间复杂度：$O(nm)$，其中 $n$ 是砖墙的高度，$m$ 是每行砖墙的砖的平均数量。我们需要将每行砖块中除了最右侧的砖块以外的每一块砖的右侧边缘到砖墙的左边缘的距离加入到哈希表中。