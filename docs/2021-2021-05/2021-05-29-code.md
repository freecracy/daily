# 2021年05月29日 code
<a href="https://toutiao.io/k/s8xgae9">掌门 MySQL 数据库规约落地及优化实战</a><br /><a href="https://toutiao.io/k/p77raxg">这可能是最容易理解的 Go Mutex 源码剖析</a><br /><a href="https://toutiao.io/k/cs2cbes">进程、线程与协程傻傻分不清？一文带你吃透</a><br /><a href="https://toutiao.io/k/q8zmevp">高性能万亿级消息吞吐 Pulsar 设计原理</a><br /><a href="https://toutiao.io/k/ybiw04u">高并发、高性能、高可用系统设计经验</a><br /><a href="https://toutiao.io/k/mbmdjm5">在 React Native 上使用 Agora 开发多频道音视频应用</a><br /><a href="https://toutiao.io/k/ijogl07">Java 并发编程专题系列之从底层分析 LockSupport 原理机制</a><br /><a href="https://toutiao.io/k/9lt21j7">Mesh 大规模落地后，下一站是？</a><br /><a href="https://toutiao.io/k/dei0ihq">.NET 程序崩溃了怎么抓 Dump ? 我总结了三种方案</a><br /><a href="https://toutiao.io/k/nf6f6dy">万字攻略：迅速蹿红的数据湖，你真的招架得住吗？</a><br /><a href="https://toutiao.io/k/o9lpsd5">又吵起来了，Go 是传值还是传引用？</a><br /><a href="https://toutiao.io/k/d6ibczk">基于 Web 引擎扩展技术的 RTC 混合开发框架实践</a><br /><a href="https://toutiao.io/k/04iwr1c">AI 入行那些事儿（十三）：人工智能的三类技术岗位</a><br /><a href="https://toutiao.io/k/2buvyqq">从 Netflix 到 Alibaba，Spring Cloud 更好了吗？</a><br /><a href="https://toutiao.io/k/55bjfc7">Flink jm、tm 启动过程和资源分配</a><br /><a href="https://toutiao.io/k/9sp3u68">[译] Android 隐私安全更新一览</a><br /><a href="https://toutiao.io/k/wp0paz6">AES 算法（一）：简介</a><br /><a href="https://toutiao.io/k/ghjdkxr">了不起的 Chrome 浏览器（三）：Chrome 91 支持 WebAssembly SIMD，加速 Web 在 AI 等领域的应用</a><br /><a href="https://toutiao.io/k/ni0zzo7">漫画：那些对程序员来说伤害性不高但是侮辱性极强的瞬间</a><br /><a href="https://toutiao.io/k/ny44udc">正经分析 iOS 包大小优化</a><br /><a href="https://toutiao.io/k/5u1byn9">[推荐] 各厂三年 Go 面经，已入字节</a><br /><a href="https://toutiao.io/k/0hjw87u">[推荐] 日订单量达到 100 万单后，我们做了订单中心重构</a><br /><a href="https://toutiao.io/k/pws2m3l">[推荐] 微软又一个数据可视化神器开源了！非常酷炫</a><br /><a href="https://toutiao.io/k/wa52n1g">[推荐] 高并发，我把握不住啊</a><br /><a href="https://toutiao.io/k/18gz8ap">[推荐] 百亿规模 API 网关服务 Shepherd 的设计与实现</a><br /><a href="https://toutiao.io/k/a3frc3i">[推荐] 聊一聊 Linux 的五种 IO 模型</a><br /><a href="https://toutiao.io/k/9yex08q">[推荐] 我把这个软件，推荐给了总监</a><br /><a href="https://toutiao.io/k/5za3e5u">[推荐] Golang 内存管理分析</a><br /><a href="https://toutiao.io/k/ep5e8sd">[推荐] 亿级系统的 Redis 缓存如何设计？</a><br /><a href="https://toutiao.io/k/ngx4og0">[推荐] “三次握手，四次挥手” 这么讲，保证你忘不了</a><br /><a href="https://toutiao.io/k/osge9c2">[推荐] 这款远程桌面软件开源了</a><br /><a href="https://toutiao.io/k/jt9e5bq">[推荐] 动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a><br /><a href="https://toutiao.io/k/t1o49fm">[推荐] 企业微信万亿级日志检索系统</a><br /><a href="https://toutiao.io/k/r3kppel">[推荐] WebRTC 的前世今生</a><br /><a href="https://toutiao.io/k/bzx7ri7">[推荐] Spring Boot 开发秘籍：集成参数校验及高阶技巧</a><br /><hr /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/wuyouzhuguli/SpringAll">循序渐进，学习Spring Boot、Spring Boot & Shiro、Spring Batch、Spring Cloud、Spring Cloud Alibaba、Spring Security & Spring Security OAuth2，博客Spring系列源码：https://mrbird.cc</a><br /><a href="https://github.com/inoyna11/jd28"></a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/microsoft/winget-pkgs">The Microsoft community Windows Package Manager manifest repository</a><br /><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</a><br /><a href="https://github.com/pluja/awesome-privacy">Awesome Privacy - A curated list of services and alternatives that respect your privacy because PRIVACY MATTERS.</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/CodingGay/BlackDex">BlackDex is an Android unpack tool, it supports Android 5.0~12 and need not rely to any environment. BlackDex can run on any Android mobile phones or emulators, you can unpack APK File in several seconds.</a><br /><a href="https://github.com/ascoders/weekly">前端精读周刊。帮你理解最前沿、实用的技术。</a><br /><a href="https://github.com/doocs/leetcode">😏 LeetCode solutions in any programming language | 多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解</a><br /><a href="https://github.com/login?return_to=%2Fbee-san%2FpyWhat">🐸 Identify anything. pyWhat easily lets you identify emails, IP addresses, and more. Feed it a .pcap file or some text and it'll tell you what it is! 🧙‍♀️</a><br /><a href="https://github.com/Tencent/secguide">面向开发人员梳理的代码安全指南</a><br /><a href="https://github.com/imarvinle/awesome-cs-books">经典编程书籍大全，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试等</a><br /><a href="https://github.com/saadeghi/daisyui">⭐️ ⭐️ ⭐️ ⭐️ ⭐️  Tailwind Components</a><br /><a href="https://github.com/ossu/computer-science">🎓 Path to a free self-taught education in Computer Science!</a><br /><a href="https://github.com/AMAI-GmbH/AI-Expert-Roadmap">Roadmap to becoming an Artificial Intelligence Expert in 2021</a><br /><a href="https://github.com/microsoft/winget-cli">Windows Package Manager CLI (aka winget)</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/davidortinau/WeatherTwentyOne"></a><br /><a href="https://github.com/wilsonfreitas/awesome-quant">A curated list of insanely awesome libraries, packages and resources for Quants (Quantitative Finance)</a><br /><a href="https://github.com/login?return_to=%2Fgiswqs%2Fleafmap">A Python package for geospatial analysis and interactive mapping with minimal coding in a Jupyter environment</a><br /><a href="https://github.com/bradtraversy/design-resources-for-developers">Curated list of design and UI resources from stock photos, web templates, CSS frameworks, UI libraries, tools and much more</a><br /><a href="https://github.com/amazon-research/siam-mot">SiamMOT: Siamese Multi-Object Tracking</a><br /><a href="https://github.com/FiloSottile/mkcert">A simple zero-config tool to make locally trusted development certificates with any names you'd like.</a><br /><hr />元素和为目标值的子矩阵数量<br /><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>

<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 <= x <= x2</code> 且 <code>y1 <= y <= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>

<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1', y1', x2', y2')</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1'</code>），那么这两个子矩阵也不同。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" style="width: 242px; height: 242px;" /></p>

<pre>
<strong>输入：</strong>matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
<strong>输出：</strong>4
<strong>解释：</strong>四个只含 0 的 1x1 子矩阵。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>matrix = [[1,-1],[-1,1]], target = 0
<strong>输出：</strong>5
<strong>解释：</strong>两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>matrix = [[904]], target = 0
<strong>输出：</strong>0
</pre>

<p> </p>

<p><strong><strong>提示：</strong></strong></p>

<ul>
	<li><code>1 <= matrix.length <= 100</code></li>
	<li><code>1 <= matrix[0].length <= 100</code></li>
	<li><code>-1000 <= matrix[i] <= 1000</code></li>
	<li><code>-10^8 <= target <= 10^8</code></li>
</ul>
<br />#### 方法一：前缀和 + 哈希表

我们枚举子矩阵的上下边界，并计算出该边界内每列的元素和，则原问题转换成了如下一维问题：

> 给定一个整数数组和一个整数 $\textit{target}$，计算该数组中子数组和等于 $\textit{target}$ 的子数组个数。

力扣上已有该问题：[560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)，读者可以参考其[官方题解](https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/)，并掌握使用前缀和+哈希表的线性做法。

对于每列的元素和 $\textit{sum}$ 的计算，我们在枚举子矩阵上边界 $i$ 时，初始下边界 $j$ 为 $i$，此时 $\textit{sum}$ 就是矩阵第 $i$ 行的元素。每次向下延长下边界 $j$ 时，我们可以将矩阵第 $j$ 行的元素累加到 $\textit{sum}$ 中。

```C++ [sol1-C++]
class Solution {
private:
    int subarraySum(vector<int> &nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto &x:nums) {
            pre += x;
            if (mp.find(pre - k) != mp.end()) {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }

public:
    int numSubmatrixSumTarget(vector<vector<int>> &matrix, int target) {
        int ans = 0;
        int m = matrix.size(), n = matrix[0].size();
        for (int i = 0; i < m; ++i) { // 枚举上边界
            vector<int> sum(n);
            for (int j = i; j < m; ++j) { // 枚举下边界
                for (int c = 0; c < n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                ans += subarraySum(sum, target);
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int ans = 0;
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i < m; ++i) { // 枚举上边界
            int[] sum = new int[n];
            for (int j = i; j < m; ++j) { // 枚举下边界
                for (int c = 0; c < n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                ans += subarraySum(sum, target);
            }
        }
        return ans;
    }

    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(0, 1);
        int count = 0, pre = 0;
        for (int x : nums) {
            pre += x;
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int NumSubmatrixSumTarget(int[][] matrix, int target) {

        int ans = 0;
        int m = matrix.Length, n = matrix[0].Length;
        for (int i = 0; i < m; ++i) { // 枚举上边界
            int[] sum = new int[n];
            for (int j = i; j < m; ++j) { // 枚举下边界
                for (int c = 0; c < n; ++c) {
                    sum[c] += matrix[j][c]; // 更新每列的元素和
                }
                ans += SubarraySum(sum, target);
            }
        }
        return ans;
    }

    public int SubarraySum(int[] nums, int k) {
        Dictionary<int, int> dictionary = new Dictionary<int, int>();
        dictionary.Add(0, 1);
        int count = 0, pre = 0;
        foreach (int x in nums) {
            pre += x;
            if (dictionary.ContainsKey(pre - k)) {
                count += dictionary[pre - k];
            }
            if (!dictionary.ContainsKey(pre)) {
                dictionary.Add(pre, 1);
            } else {
                ++dictionary[pre];
            }
        }
        return count;
    }
}
```

```go [sol1-Golang]
func subarraySum(nums []int, k int) (ans int) {
    mp := map[int]int{0: 1}
    for i, pre := 0, 0; i < len(nums); i++ {
        pre += nums[i]
        if _, ok := mp[pre-k]; ok {
            ans += mp[pre-k]
        }
        mp[pre]++
    }
    return
}

func numSubmatrixSumTarget(matrix [][]int, target int) (ans int) {
    for i := range matrix { // 枚举上边界
        sum := make([]int, len(matrix[0]))
        for _, row := range matrix[i:] { // 枚举下边界
            for c, v := range row {
                sum[c] += v // 更新每列的元素和
            }
            ans += subarraySum(sum, target)
        }
    }
    return
}
```

```Python [sol1-Python3]
class Solution:
    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
        def subarraySum(nums: List[int], k: int) -> int:
            mp = Counter([0])
            count = pre = 0
            for x in nums:
                pre += x
                if pre - k in mp:
                    count += mp[pre - k]
                mp[pre] += 1
            return count
        
        m, n = len(matrix), len(matrix[0])
        ans = 0
        # 枚举上边界
        for i in range(m):
            total = [0] * n
            # 枚举下边界
            for j in range(i, m):
                for c in range(n):
                    # 更新每列的元素和
                    total[c] += matrix[j][c]
                ans += subarraySum(total, target)
        
        return ans
```

```C [sol1-C]
struct HashTable {
    int key, val;
    UT_hash_handle hh;
};

int subarraySum(int* nums, int numsSize, int k) {
    struct HashTable* hashTable = NULL;
    struct HashTable* tmp = malloc(sizeof(struct HashTable));
    tmp->key = 0, tmp->val = 1;
    HASH_ADD_INT(hashTable, key, tmp);
    int count = 0, pre = 0;
    for (int i = 0; i < numsSize; i++) {
        pre += nums[i];
        int x = pre - k;
        HASH_FIND_INT(hashTable, &x, tmp);
        if (tmp != NULL) {
            count += tmp->val;
        }
        HASH_FIND_INT(hashTable, &pre, tmp);
        if (tmp != NULL) {
            tmp->val++;
        } else {
            tmp = malloc(sizeof(struct HashTable));
            tmp->key = pre, tmp->val = 1;
            HASH_ADD_INT(hashTable, key, tmp);
        }
    }
    return count;
}

int numSubmatrixSumTarget(int** matrix, int matrixSize, int* matrixColSize, int target) {
    int ans = 0;
    int m = matrixSize, n = matrixColSize[0];
    for (int i = 0; i < m; ++i) {  // 枚举上边界
        int sum[n];
        memset(sum, 0, sizeof(sum));
        for (int j = i; j < m; ++j) {  // 枚举下边界
            for (int c = 0; c < n; ++c) {
                sum[c] += matrix[j][c];  // 更新每列的元素和
            }
            ans += subarraySum(sum, n, target);
        }
    }
    return ans;
}
```

```JavaScript [sol1-JavaScript]
var numSubmatrixSumTarget = function(matrix, target) {
    let ans = 0;
    const m = matrix.length, n = matrix[0].length;
    for (let i = 0; i < m; ++i) { // 枚举上边界
        const sum = new Array(n).fill(0);
        for (let j = i; j < m; ++j) { // 枚举下边界
            for (let c = 0; c < n; ++c) {
                sum[c] += matrix[j][c]; // 更新每列的元素和
            }
            ans += subarraySum(sum, target);
        }
    }
    return ans;
}

const subarraySum = (nums, k) => {
    const map = new Map();
    map.set(0, 1);
    let count = 0, pre = 0;
    for (const x of nums) {
        pre += x;
        if (map.has(pre - k)) {
            count += map.get(pre - k);
        }
        map.set(pre, (map.get(pre) || 0) + 1);
    }
    return count;
}
```

**复杂度分析**

- 时间复杂度：$O(m^2\cdot n)$。其中 $m$ 和 $n$ 分别是矩阵 $\textit{matrix}$ 的行数和列数。

- 空间复杂度：$O(n)$。

**优化**

若行数大于列数，枚举矩形的左右边界更优，对应的时间复杂度为 $O(n^2\cdot m)$。

总之，根据 $m$ 和 $n$ 的大小来细化枚举策略，我们可以做到 $O(\min(m,n)^2\cdot\max(m,n))$ 的时间复杂度。

---
## ✨扣友帮帮团 - 互动答疑

[![讨论.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)


即日起 - 5 月 30 日，点击 [这里](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/) 前往「[扣友帮帮团](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)」活动页，把你遇到的问题大胆地提出来，让扣友为你解答～

### 🎁 奖励规则
被采纳数量排名 1～3 名：「力扣极客套装」 *1 并将获得「力扣神秘应援团」内测资格
被采纳数量排名 4～10 名：「力扣鼠标垫」 *1 并将获得「力扣神秘应援团」内测资格
「诲人不倦」：活动期间「解惑者」只要有 1 个回答被采纳，即可获得 20 LeetCoins 奖励！
「求知若渴」：活动期间「求知者」在活动页发起一次符合要求的疑问帖并至少采纳一次「解惑者」的回答，即可获得 20 LeetCoins 奖励！

活动详情猛戳链接了解更多：[🐞 你有 BUG 我来帮 - 力扣互动答疑季](https://leetcode-cn.com/circle/discuss/xtliW6/)