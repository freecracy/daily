# 2021年05月14日 code
<a href="https://toutiao.io/k/8fsz3uu">低代码核心：代码生成还是模型解释？</a><br /><a href="https://toutiao.io/k/73pqk57">Plan9 assembly 完全解析</a><br /><a href="https://toutiao.io/k/qaw4y76">优化技术专题（一）：Java 虚拟机优化案例系列</a><br /><a href="https://toutiao.io/k/uqgr3dg">大促突围：京东到家基于 Canal 的数据异构设计</a><br /><a href="https://toutiao.io/k/uce1j3m">附近的人？你 zao 吗？</a><br /><a href="https://toutiao.io/k/5wfld6l">如何用迭代法《中序遍历二叉树》</a><br /><a href="https://toutiao.io/k/t9cq6j3">一文从 0 到 1 掌握用户画像知识体系</a><br /><a href="https://toutiao.io/k/lxdh3td">字节跳动社招一面 2021.04.23</a><br /><a href="https://toutiao.io/k/4j54bjs">gRPC 的反射机制（一）</a><br /><a href="https://toutiao.io/k/nqz2hvf">[北京] 好未来前端开发工程师</a><br /><a href="https://toutiao.io/k/zxujh0m">架构设计笔记（十七）：关键模式_安全架构</a><br /><a href="https://toutiao.io/k/prpo5xg">RocketMQ 优雅停机往事</a><br /><a href="https://toutiao.io/k/peszwpp">Go 数组比切片好在哪？</a><br /><a href="https://toutiao.io/k/8mi106z">干货解读数据中台产品 “模块化” 设计思路 </a><br /><a href="https://toutiao.io/k/bt3qaxe">漫画：如何向外行解释你为什么想打产品经理？</a><br /><a href="https://toutiao.io/k/3wigv9h">为什么TCP 建连接要 3 次，断连接却要 4 次呢？</a><br /><a href="https://toutiao.io/k/vf01pj4">论文：一种基于 Embedding 和 Mapping 的跨域推荐方法</a><br /><a href="https://toutiao.io/k/zi1ae0q">如何打造一款标准的 JS SDK ？</a><br /><a href="https://toutiao.io/k/kfvgqzo">React 新特性为啥产出这么慢？江郎才尽啦？</a><br /><a href="https://toutiao.io/k/l7ywtht">ClickHouse Join 分布式表不走 localjoin 问题解析</a><br /><a href="https://toutiao.io/k/4fpatsr">[推荐] [译] Linux 系统安全强化指南</a><br /><a href="https://toutiao.io/k/6mzds1m">[推荐] 系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/nkx9rki">[推荐] 我认为最优美的数据结构</a><br /><a href="https://toutiao.io/k/4sywkcm">[推荐] 微服务设计原则</a><br /><a href="https://toutiao.io/k/xdsox3x">[推荐] 撸代码前，写下设计方案</a><br /><a href="https://toutiao.io/k/gc13z71">[推荐] 数据分析十年，我只推荐这些书</a><br /><a href="https://toutiao.io/k/7v2gnx6">[推荐] 程序员必备基础：10 种常见安全漏洞浅析</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/ss8h91v">[推荐] 架构师必看：架构设计的四大思维支柱</a><br /><hr /><a href="https://github.com/fpv-wtf/voc-poc">A PoC for USB video out from the DJI FPV Goggles, inspired by The Video Out Club</a><br /><a href="https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot">This is a fully functioning Binance trading bot that measures the volatility of every coin on Binance and places trades with the highest gaining coins If you like this project consider donating though the Brave browser to allow me to continuously improve the script.</a><br /><a href="https://github.com/trustwallet/assets">A comprehensive, up-to-date collection of information about several thousands (!) of crypto tokens.</a><br /><a href="https://github.com/symfony/symfony">The Symfony PHP framework</a><br /><a href="https://github.com/monk-coder/dust">繁华 不过一掬细沙</a><br /><a href="https://github.com/IBM/Project_CodeNet">This repository is to support contributions for tools for the Project CodeNet dataset hosted in DAX</a><br /><a href="https://github.com/zo0r/react-native-push-notification">React Native Local and Remote Notifications</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/login?return_to=%2Fqarmin%2Fczkawka">Multi functional app to find duplicates, empty folders, similar images etc.</a><br /><a href="https://github.com/pallets/flask">The Python micro framework for building web applications.</a><br /><a href="https://github.com/TheAlgorithms/C-Plus-Plus">Collection of various algorithms in mathematics, machine learning, computer science and physics implemented in C++ for educational purposes.</a><br /><a href="https://github.com/dromara/sa-token">这可能是史上功能最全的Java权限认证框架！目前已集成——登录认证、权限认证、分布式Session会话、微服务网关鉴权、单点登录、OAuth2.0、踢人下线、Redis集成、前后台分离、记住我模式、模拟他人账号、临时身份切换、账号封禁、多账号认证体系、注解式鉴权、路由拦截式鉴权、花式token生成、自动续签、同端互斥登录、会话治理、密码加密、jwt集成、Spring集成、WebFlux集成...</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/CyC2018/CS-Notes">📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</a><br /><a href="https://github.com/ossrs/srs">SRS is a simple, high efficiency and realtime video server, supports RTMP/WebRTC/HLS/HTTP-FLV/SRT/GB28181.</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/tevador/RandomX">Proof of work algorithm based on random code execution</a><br /><a href="https://github.com/Snailclimb/JavaGuide">「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！</a><br /><a href="https://github.com/goldbergyoni/nodebestpractices">✅ The Node.js best practices list (May 2021)</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">🔗 Some useful websites for programmers.</a><br /><a href="https://github.com/AllThingsSmitty/css-protips">A collection of tips to help take your CSS skills pro</a><br /><a href="https://github.com/chakra-ui/chakra-ui">⚡️ Simple, Modular & Accessible UI Components for your React Applications</a><br /><a href="https://github.com/IntelRealSense/realsense-ros">Intel(R) RealSense(TM) ROS Wrapper for D400 series, SR300 Camera and T265 Tracking Module</a><br /><hr />整数转罗马数字<br /><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>

<pre>
<strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>

<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>

<ul>
	<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
	<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
	<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>

<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> 3
<strong>输出:</strong> "III"</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> 4
<strong>输出:</strong> "IV"</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> 9
<strong>输出:</strong> "IX"</pre>

<p><strong>示例 4:</strong></p>

<pre>
<strong>输入:</strong> 58
<strong>输出:</strong> "LVIII"
<strong>解释:</strong> L = 50, V = 5, III = 3.
</pre>

<p><strong>示例 5:</strong></p>

<pre>
<strong>输入:</strong> 1994
<strong>输出:</strong> "MCMXCIV"
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= num <= 3999</code></li>
</ul>
<br />#### 前言

**罗马数字符号**

罗马数字由 $7$ 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 $6$ 个复合符号。这给了我们总共 $13$ 个独特的符号（每个符号由 $1$ 个或 $2$ 个字母组成），如下图所示。

![fig1](https://assets.leetcode-cn.com/solution-static/12/1.png)

**罗马数字的唯一表示法**

让我们从一个例子入手。考虑 $140$ 的罗马数字表示，下面哪一个是正确的？

![fig2](https://assets.leetcode-cn.com/solution-static/12/2.png)

我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 $140$，最大可以选择的符号值为 $\texttt{C}=100$。接下来，对于剩余的数字 $40$，最大可以选择的符号值为 $\texttt{XL}=40$。因此，$140$ 的对应的罗马数字为 $\texttt{C}+\texttt{XL}=\texttt{CXL}$。

#### 方法一：模拟

**思路**

根据罗马数字的唯一表示法，为了表示一个给定的整数 $\textit{num}$，我们寻找不超过 $\textit{num}$ 的最大符号值，将 $\textit{num}$ 减去该符号值，然后继续寻找不超过 $\textit{num}$ 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 $\textit{num}$ 为 $0$。最后得到的字符串即为 $\textit{num}$ 的罗马数字表示。

编程时，可以建立一个数值-符号对的列表 $\textit{valueSymbols}$，按数值从大到小排列。遍历 $\textit{valueSymbols}$ 中的每个数值-符号对，若当前数值 $\textit{value}$ 不超过 $\textit{num}$，则从 $\textit{num}$ 中不断减去 $\textit{value}$，直至 $\textit{num}$ 小于 $\textit{value}$，然后遍历下一个数值-符号对。若遍历中 $\textit{num}$ 为 $0$ 则跳出循环。

**代码**

```C++ [sol1-C++]
const pair<int, string> valueSymbols[] = {
    {1000, "M"},
    {900,  "CM"},
    {500,  "D"},
    {400,  "CD"},
    {100,  "C"},
    {90,   "XC"},
    {50,   "L"},
    {40,   "XL"},
    {10,   "X"},
    {9,    "IX"},
    {5,    "V"},
    {4,    "IV"},
    {1,    "I"},
};

class Solution {
public:
    string intToRoman(int num) {
        string roman;
        for (const auto &[value, symbol] : valueSymbols) {
            while (num >= value) {
                num -= value;
                roman += symbol;
            }
            if (num == 0) {
                break;
            }
        }
        return roman;
    }
};
```

```Java [sol1-Java]
class Solution {
    int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    public String intToRoman(int num) {
        StringBuffer roman = new StringBuffer();
        for (int i = 0; i < values.length; ++i) {
            int value = values[i];
            String symbol = symbols[i];
            while (num >= value) {
                num -= value;
                roman.append(symbol);
            }
            if (num == 0) {
                break;
            }
        }
        return roman.toString();
    }
}
```

```C# [sol1-C#]
public class Solution {
    readonly Tuple<int, string>[] valueSymbols = {
        new Tuple<int, string>(1000, "M"),
        new Tuple<int, string>(900, "CM"),
        new Tuple<int, string>(500, "D"),
        new Tuple<int, string>(400, "CD"),
        new Tuple<int, string>(100, "C"),
        new Tuple<int, string>(90, "XC"),
        new Tuple<int, string>(50, "L"),
        new Tuple<int, string>(40, "XL"),
        new Tuple<int, string>(10, "X"),
        new Tuple<int, string>(9, "IX"),
        new Tuple<int, string>(5, "V"),
        new Tuple<int, string>(4, "IV"),
        new Tuple<int, string>(1, "I")
    };

    public string IntToRoman(int num) {
        StringBuilder roman = new StringBuilder();
        foreach (Tuple<int, string> tuple in valueSymbols) {
            int value = tuple.Item1;
            string symbol = tuple.Item2;
            while (num >= value) {
                num -= value;
                roman.Append(symbol);
            }
            if (num == 0) {
                break;
            }
        }
        return roman.ToString();
    }
}
```

```go [sol1-Golang]
var valueSymbols = []struct {
    value  int
    symbol string
}{
    {1000, "M"},
    {900, "CM"},
    {500, "D"},
    {400, "CD"},
    {100, "C"},
    {90, "XC"},
    {50, "L"},
    {40, "XL"},
    {10, "X"},
    {9, "IX"},
    {5, "V"},
    {4, "IV"},
    {1, "I"},
}

func intToRoman(num int) string {
    roman := []byte{}
    for _, vs := range valueSymbols {
        for num >= vs.value {
            num -= vs.value
            roman = append(roman, vs.symbol...)
        }
        if num == 0 {
            break
        }
    }
    return string(roman)
}
```

```JavaScript [sol1-JavaScript]
var intToRoman = function(num) {
    const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    const valueSymbols = new Map();
    valueSymbols.set(1000, "M");
    valueSymbols.set(900, "CM");
    valueSymbols.set(500, "D");
    valueSymbols.set(400, "CD");
    valueSymbols.set(100, "C");
    valueSymbols.set(90, "XC");
    valueSymbols.set(50, "L");
    valueSymbols.set(40, "XL");
    valueSymbols.set(10, "X");
    valueSymbols.set(9, "IX");
    valueSymbols.set(5, "V");
    valueSymbols.set(4, "IV");
    valueSymbols.set(1, "I");
    const roman = [];
    for (const value of values) {
        const symbol = valueSymbols.get(value);
        while (num >= value) {
            num -= value;
            roman.push(symbol);
        }
        if (num == 0) {
            break;
        }
    }
    return roman.join('');
};
```

```Python [sol1-Python3]
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]

    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                num -= value
                roman.append(symbol)
            if num == 0:
                break
        return "".join(roman)
```

```C [sol1-C]
const int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
const char* symbols[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

char* intToRoman(int num) {
    char* roman = malloc(sizeof(char) * 16);
    roman[0] = '\0';
    for (int i = 0; i < 13; i++) {
        while (num >= values[i]) {
            num -= values[i];
            strcpy(roman + strlen(roman), symbols[i]);
        }
        if (num == 0) {
            break;
        }
    }
    return roman;
}
```

**复杂度分析**

- 时间复杂度：$O(1)$。由于 $\textit{valueSymbols}$ 长度是固定的，且这 $13$ 字符中的每个字符的出现次数均不会超过 $3$，因此循环次数有一个确定的上限。对于本题给出的数据范围，循环次数不会超过 $15$ 次。

- 空间复杂度：$O(1)$。

#### 方法二：硬编码数字

**思路**

![fig3](https://assets.leetcode-cn.com/solution-static/12/1.png)

回顾前言中列出的这 $13$ 个符号，可以发现：

- 千位数字只能由 $\texttt{M}$ 表示；
- 百位数字只能由 $\texttt{C}$，$\texttt{CD}$，$\texttt{D}$ 和 $\texttt{CM}$ 表示；
- 十位数字只能由 $\texttt{X}$，$\texttt{XL}$，$\texttt{L}$ 和 $\texttt{XC}$ 表示；
- 个位数字只能由 $\texttt{I}$，$\texttt{IV}$，$\texttt{V}$ 和 $\texttt{IX}$ 表示。

这恰好把这 $13$ 个符号分为四组，且组与组之间没有公共的符号。因此，整数 $\textit{num}$ 的十进制表示中的每一个数字都是可以单独处理的。

进一步地，我们可以计算出每个数字在每个位上的表示形式，整理成一张硬编码表。如下图所示，其中 $0$ 对应的是空字符串。

![fig4](https://assets.leetcode-cn.com/solution-static/12/3.png)

利用模运算和除法运算，我们可以得到 $\textit{num}$ 每个位上的数字：

```
thousands_digit = num / 1000
hundreds_digit = (num % 1000) / 100
tens_digit = (num % 100) / 10
ones_digit = num % 10
```

最后，根据 $\textit{num}$ 每个位上的数字，在硬编码表中查找对应的罗马字符，并将结果拼接在一起，即为 $\textit{num}$ 对应的罗马数字。

**代码**

```C++ [sol2-C++]
const string thousands[] = {"", "M", "MM", "MMM"};
const string hundreds[]  = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
const string tens[]      = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
const string ones[]      = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

class Solution {
public:
    string intToRoman(int num) {
        return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];
    }
};
```

```Java [sol2-Java]
class Solution {
    String[] thousands = {"", "M", "MM", "MMM"};
    String[] hundreds  = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    String[] tens      = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    String[] ones      = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

    public String intToRoman(int num) {
        StringBuffer roman = new StringBuffer();
        roman.append(thousands[num / 1000]);
        roman.append(hundreds[num % 1000 / 100]);
        roman.append(tens[num % 100 / 10]);
        roman.append(ones[num % 10]);
        return roman.toString();
    }
}
```

```C# [sol2-C#]
public class Solution {
    readonly string[] thousands = {"", "M", "MM", "MMM"};
    readonly string[] hundreds  = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    readonly string[] tens      = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    readonly string[] ones      = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

    public string IntToRoman(int num) {
        StringBuilder roman = new StringBuilder();
        roman.Append(thousands[num / 1000]);
        roman.Append(hundreds[num % 1000 / 100]);
        roman.Append(tens[num % 100 / 10]);
        roman.Append(ones[num % 10]);
        return roman.ToString();
    }
}
```

```go [sol2-Golang]
var (
    thousands = []string{"", "M", "MM", "MMM"}
    hundreds  = []string{"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"}
    tens      = []string{"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"}
    ones      = []string{"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"}
)

func intToRoman(num int) string {
    return thousands[num/1000] + hundreds[num%1000/100] + tens[num%100/10] + ones[num%10]
}
```

```JavaScript [sol2-JavaScript]
var intToRoman = function(num) {
    const thousands = ["", "M", "MM", "MMM"];
    const hundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
    const tens     = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
    const ones     = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];

    const roman = [];
    roman.push(thousands[Math.floor(num / 1000)]);
    roman.push(hundreds[Math.floor(num % 1000 / 100)]);
    roman.push(tens[Math.floor(num % 100 / 10)]);
    roman.push(ones[num % 10]);
    return roman.join('');
};
```

```Python [sol2-Python3]
class Solution:

    THOUSANDS = ["", "M", "MM", "MMM"]
    HUNDREDS = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"]
    TENS = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"]
    ONES = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"]

    def intToRoman(self, num: int) -> str:
        return Solution.THOUSANDS[num // 1000] + \
            Solution.HUNDREDS[num % 1000 // 100] + \
            Solution.TENS[num % 100 // 10] + \
            Solution.ONES[num % 10]
```

```C [sol2-C]
const char* thousands[] = {"", "M", "MM", "MMM"};
const char* hundreds[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
const char* tens[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
const char* ones[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

char* intToRoman(int num) {
    char* roman = malloc(sizeof(char) * 16);
    roman[0] = '\0';
    strcpy(roman + strlen(roman), thousands[num / 1000]);
    strcpy(roman + strlen(roman), hundreds[num % 1000 / 100]);
    strcpy(roman + strlen(roman), tens[num % 100 / 10]);
    strcpy(roman + strlen(roman), ones[num % 10]);
    return roman;
}
```

**复杂度分析**

- 时间复杂度：$O(1)$。计算量与输入数字的大小无关。

- 空间复杂度：$O(1)$。