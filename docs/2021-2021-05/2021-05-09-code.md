# 2021年05月09日 code
<a href="https://toutiao.io/k/kw76t1v">细说 Kafka Partition 分区</a><br /><a href="https://toutiao.io/k/5xw6p4n">还不会使用分布式锁？从零开始基于 etcd 实现分布式锁</a><br /><a href="https://toutiao.io/k/cip5d5f">民族工业软件之殇</a><br /><a href="https://toutiao.io/k/22smd1p">全方位深度解读 Elasticsearch 分页查询</a><br /><a href="https://toutiao.io/k/qqqjn8a">某小公司：MySQL 连环问</a><br /><a href="https://toutiao.io/k/und62pa">卷积神经网络可视化，真的很像神经元（上篇）</a><br /><a href="https://toutiao.io/k/kfyndb9">在 GitHub 学习，成长为自己想要的样子（HelloGitHub 访谈）</a><br /><a href="https://toutiao.io/k/bjcghco">Kind：如何快速搭建本地 K8s 开发环境？</a><br /><a href="https://toutiao.io/k/nahnki6">漫画：辞职前与老板的最后一次谈话有哪些禁忌？</a><br /><a href="https://toutiao.io/k/4aw6p85">程序员五一被拉去相亲，结果彻底搞懂了 HTTP 常用状态码</a><br /><a href="https://toutiao.io/k/gxdq7u3">Neo4j 图形数据库入门</a><br /><a href="https://toutiao.io/k/gz2naq8">[译] 造就 Rust 的无名英雄</a><br /><a href="https://toutiao.io/k/oq8if3i">MQ 的那些破事儿，你不好奇吗？</a><br /><a href="https://toutiao.io/k/1glhcyw">Java 并发（同步容器篇）</a><br /><a href="https://toutiao.io/k/a3cemt9">数栈技术分享：详解 FlinkX 中的断点续传和实时采集</a><br /><a href="https://toutiao.io/k/jtcnrrd">创意视频/ GIF 实验</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/0etokja">[推荐] Kafka：这次分享我只想把原理讲清楚</a><br /><a href="https://toutiao.io/k/6mzds1m">[推荐] 系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/xdsox3x">[推荐] 撸代码前，写下设计方案</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/lvyzxo8">[推荐] 图解 Kafka</a><br /><hr /><a href="https://github.com/abuanwar072/Flutter-Responsive-Admin-Panel-or-Dashboard">Responsive Admin Panel or Dashboard using Flutter</a><br /><a href="https://github.com/pyston/pyston">A faster and highly-compatible implementation of the Python programming language.</a><br /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Public Beta 🎉)</a><br /><a href="https://github.com/pallupz/covid-vaccine-booking">This very basic script can be used to automate some steps on Co-WIN Platform.</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道题目详细刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/milvus-io/milvus">An open source embedding vector similarity search engine powered by Faiss, NMSLIB and Annoy</a><br /><a href="https://github.com/Haixiang6123/one-day-one-npm-lib">这本小书会带你造 10 个非常实用的 npm 库 📦</a><br /><a href="https://github.com/aurasphere/gomorra-sql">SQL made uagliò.</a><br /><a href="https://github.com/audacity/audacity">Audio Editor</a><br /><a href="https://github.com/trimstray/the-book-of-secret-knowledge">A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more.</a><br /><a href="https://github.com/pbatard/rufus">The Reliable USB Formatting Utility</a><br /><a href="https://github.com/login?return_to=%2Fstreamich%2Freact-use">React Hooks — 👍</a><br /><a href="https://github.com/PharkMillups/beautiful-docs">Pointers to useful, well-written, and otherwise beautiful documentation.</a><br /><a href="https://github.com/LeCoupa/awesome-cheatsheets">👩‍💻👨‍💻 Awesome cheatsheets for popular programming languages, frameworks and development tools. They include everything you should know in one single file.</a><br /><a href="https://github.com/alacritty/alacritty">A cross-platform, OpenGL terminal emulator.</a><br /><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">🔗 Some useful websites for programmers.</a><br /><a href="https://github.com/alibaba/Sentinel">A powerful flow control component enabling reliability, resilience and monitoring for microservices. (面向云原生微服务的高可用流控防护组件)</a><br /><a href="https://github.com/jlevy/the-art-of-command-line">Master the command line, in one page</a><br /><a href="https://github.com/dromara/shenyu">High-Performance Java API Gateway</a><br /><a href="https://github.com/ruanyf/weekly">科技爱好者周刊，每周五发布</a><br /><a href="https://github.com/alibaba/canal">阿里巴巴 MySQL binlog 增量订阅&消费组件</a><br /><a href="https://github.com/nextapps-de/winbox">WinBox is a professional HTML5 window manager for the web: lightweight, outstanding performance, no dependencies, fully customizable, open source!</a><br /><a href="https://github.com/kelseyhightower/nocode">The best way to write secure and reliable applications. Write nothing; deploy nowhere.</a><br /><a href="https://github.com/kcp-dev/kcp">kcp is a prototype of a Kubernetes API server that is not a Kubernetes cluster - a place to create, update, and maintain Kube-like APis with controllers above or without clusters.</a><br /><a href="https://github.com/apache/iceberg">Apache Iceberg</a><br /><hr />制作 m 束花所需的最少天数<br /><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>

<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>

<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>

<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 1
<strong>输出：</strong>3
<strong>解释：</strong>让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
现在需要制作 3 束花，每束只需要 1 朵。
1 天后：[x, _, _, _, _]   // 只能制作 1 束花
2 天后：[x, _, _, _, x]   // 只能制作 2 束花
3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 2
<strong>输出：</strong>-1
<strong>解释：</strong>要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
<strong>输出：</strong>12
<strong>解释：</strong>要制作 2 束花，每束需要 3 朵。
花园在 7 天后和 12 天后的情况如下：
7 天后：[x, x, x, x, _, x, x]
可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
12 天后：[x, x, x, x, x, x, x]
显然，我们可以用不同的方式制作两束花。
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>bloomDay = [1000000000,1000000000], m = 1, k = 1
<strong>输出：</strong>1000000000
<strong>解释：</strong>需要等 1000000000 天才能采到花来制作花束
</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
<strong>输出：</strong>9
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>bloomDay.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10^5</code></li>
	<li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>
	<li><code>1 &lt;= m &lt;= 10^6</code></li>
	<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<br />#### 方法一：二分查找

每束花需要 $k$ 朵花，需要制作 $m$ 束花，因此一共需要 $k \times m$ 朵花。如果花园中的花朵数量少于 $k \times m$，即数组 $\textit{bloomDay}$ 的长度小于 $k \times m$，则无法制作出指定数量的花束，返回 $-1$。如果数组 $\textit{bloomDay}$ 的长度大于或等于 $k \times m$，则一定可以制作出指定数量的花束。

为了计算制作出指定数量的花束的最少天数，首先需要实现一个辅助函数用于判断在给定的天数内能否制作出指定数量的花束，辅助函数的参数除了 $\textit{bloomDay}$、$m$ 和 $k$ 之外，还有一个参数 $\textit{days}$ 表示指定天数。例如，当 $\textit{bloomDay}=[1,10,3,10,2]$、$m=3$、$k=1$ 时，如果 $\textit{days}=3$ 则辅助函数返回 $\text{true}$，如果 $\textit{days}=2$ 则辅助函数返回 $\text{false}$。

对于辅助函数的实现，可以遍历数组 $\textit{bloomDay}$，计算其中的长度为 $k$ 且最大元素不超过 $\textit{days}$ 的不重合的连续子数组的数量，如果符合要求的不重合的连续子数组的数量大于或等于 $m$ 则返回 $\text{true}$，否则返回 $\text{false}$。

当 $\textit{days}$ 很小的时候，辅助函数总是返回 $\text{false}$，因为天数太少不能收齐 $m$ 个花束；当 $\textit{days}$ 很大的时候，辅助函数总是返回 $\text{true}$，如果给定序列可以制作出 $m$ 个花束。在 $\textit{days}$ 慢慢变大的过程中，辅助函数的返回值会从 $\text{false}$ 变成 $\text{true}$，所以我们可以认为这个辅助函数是关于 $\textit{days}$ 递增的，于是可以通过二分查找得到最少天数。在确保可以制作出指定数量的花束的情况下，所需的最少天数一定不会超过数组 $\textit{bloomDay}$ 中的最大值，因此二分查找的初始值是 $\textit{low}$ 等于 $1$，$\textit{high}$ 等于数组 $\textit{bloomDay}$ 中的最大值。

当 $\textit{low}$ 和 $\textit{high}$ 的值相等时，二分查找结束，此时 $\textit{low}$ 的值即为最少天数。

```Java [sol1-Java]
class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        if (k * m > bloomDay.length) {
            return -1;
        }
        int low = 1, high = 1;
        int length = bloomDay.length;
        for (int i = 0; i < length; i++) {
            high = Math.max(high, bloomDay[i]);
        }
        while (low < high) {
            int days = (high - low) / 2 + low;
            if (canMake(bloomDay, days, m, k)) {
                high = days;
            } else {
                low = days + 1;
            }
        }
        return low;
    }

    public boolean canMake(int[] bloomDay, int days, int m, int k) {
        int bouquets = 0;
        int flowers = 0;
        int length = bloomDay.length;
        for (int i = 0; i < length && bouquets < m; i++) {
            if (bloomDay[i] <= days) {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            } else {
                flowers = 0;
            }
        }
        return bouquets >= m;
    }
}
```

```C++ [sol1-C++]
class Solution {
public:
    int minDays(vector<int>& bloomDay, int m, int k) {
        if (k * m > bloomDay.size()) {
            return -1;
        }
        int low = 1, high = 1;
        int length = bloomDay.size();
        for (int i = 0; i < length; i++) {
            high = max(high, bloomDay[i]);
        }
        while (low < high) {
            int days = (high - low) / 2 + low;
            if (canMake(bloomDay, days, m, k)) {
                high = days;
            } else {
                low = days + 1;
            }
        }
        return low;
    }

    bool canMake(vector<int>& bloomDay, int days, int m, int k) {
        int bouquets = 0;
        int flowers = 0;
        int length = bloomDay.size();
        for (int i = 0; i < length && bouquets < m; i++) {
            if (bloomDay[i] <= days) {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            } else {
                flowers = 0;
            }
        }
        return bouquets >= m;
    }
};
```

```C# [sol1-C#]
public class Solution {
    public int MinDays(int[] bloomDay, int m, int k) {
        if (k * m > bloomDay.Length) {
            return -1;
        }
        int low = 1, high = 1;
        int length = bloomDay.Length;
        for (int i = 0; i < length; i++) {
            high = Math.Max(high, bloomDay[i]);
        }
        while (low < high) {
            int days = (high - low) / 2 + low;
            if (CanMake(bloomDay, days, m, k)) {
                high = days;
            } else {
                low = days + 1;
            }
        }
        return low;
    }

    public bool CanMake(int[] bloomDay, int days, int m, int k) {
        int bouquets = 0;
        int flowers = 0;
        int length = bloomDay.Length;
        for (int i = 0; i < length && bouquets < m; i++) {
            if (bloomDay[i] <= days) {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            } else {
                flowers = 0;
            }
        }
        return bouquets >= m;
    }
}
```

```JavaScript [sol1-JavaScript]
var minDays = function(bloomDay, m, k) {
    if (k * m > bloomDay.length) {
        return -1;
    }
    let low = 1, high = 1;
    const length = bloomDay.length;
    for (let i = 0; i < length; i++) {
        high = Math.max(high, bloomDay[i]);
    }
    while (low < high) {
        const days = Math.floor((high - low) / 2) + low;
        if (canMake(bloomDay, days, m, k)) {
            high = days;
        } else {
            low = days + 1;
        }
    }
    return low;
};

const canMake = (bloomDay, days, m, k) => {
    let bouquets = 0;
    let flowers = 0;
    const length = bloomDay.length;
    for (let i = 0; i < length && bouquets < m; i++) {
        if (bloomDay[i] <= days) {
            flowers++;
            if (flowers == k) {
                bouquets++;
                flowers = 0;
            }
        } else {
            flowers = 0;
        }
    }
    return bouquets >= m;
}
```

```go [sol1-Golang]
func minDays(bloomDay []int, m, k int) int {
    if k*m > len(bloomDay) {
        return -1
    }
    maxDay := 0
    for _, day := range bloomDay {
        if day > maxDay {
            maxDay = day
        }
    }
    return sort.Search(maxDay, func(days int) bool {
        flowers, bouquets := 0, 0
        for _, d := range bloomDay {
            if d > days {
                flowers = 0
            } else {
                flowers++
                if flowers == k {
                    bouquets++
                    flowers = 0
                }
            }
        }
        return bouquets >= m
    })
}
```

```Python [sol1-Python3]
class Solution:
    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
        if k * m > len(bloomDay):
            return -1
        
        def canMake(days: int) -> bool:
            bouquets = flowers = 0
            for i, bloom in enumerate(bloomDay):
                if bloomDay[i] <= days:
                    flowers += 1
                    if flowers == k:
                        bouquets += 1
                        if bouquets == m:
                            break
                        flowers = 0
                else:
                    flowers = 0
            return bouquets == m
        
        low, high = 1, max(bloomDay)
        while low < high:
            days = (low + high) // 2
            if canMake(days):
                high = days
            else:
                low = days + 1
        return low
```

```C [sol1-C]
bool canMake(int* bloomDay, int bloomDaySize, int days, int m, int k) {
    int bouquets = 0;
    int flowers = 0;
    int length = bloomDaySize;
    for (int i = 0; i < length && bouquets < m; i++) {
        if (bloomDay[i] <= days) {
            flowers++;
            if (flowers == k) {
                bouquets++;
                flowers = 0;
            }
        } else {
            flowers = 0;
        }
    }
    return bouquets >= m;
}

int minDays(int* bloomDay, int bloomDaySize, int m, int k) {
    if (k * m > bloomDaySize) {
        return -1;
    }
    int low = 1, high = 1;
    int length = bloomDaySize;
    for (int i = 0; i < length; i++) {
        high = fmax(high, bloomDay[i]);
    }
    while (low < high) {
        int days = (high - low) / 2 + low;
        if (canMake(bloomDay, bloomDaySize, days, m, k)) {
            high = days;
        } else {
            low = days + 1;
        }
    }
    return low;
}
```

**复杂度分析**

- 时间复杂度：$O(n \log h)$，其中 $n$ 是数组 $\textit{bloomDay}$ 的长度，$h$ 是数组 $\textit{bloomDay}$ 中的最大值。
  需要遍历数组 $\textit{bloomDay}$ 得到其中的最大值 $h$，遍历的时间复杂度是 $O(n)$。
  得到最大值 $h$ 之后，二分查找的迭代次数是 $O(\log h)$，每次判断是否能制作规定数量的花束的时间复杂度是 $O(n)$，因此二分查找的总时间复杂度是 $O(n \log h)$。
  整个算法的时间复杂度是 $O(n)+O(n \log h)=O(n \log h)$。

- 空间复杂度：$O(1)$。