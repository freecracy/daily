# 2021å¹´05æœˆ17æ—¥ code
<a href="https://toutiao.io/k/jt9e5bq">åŠ¨å›¾å›¾è§£ï¼æ—¢ç„¶ IP å±‚ä¼šåˆ†ç‰‡ï¼Œä¸ºä»€ä¹ˆ TCP å±‚ä¹Ÿè¿˜è¦åˆ†æ®µï¼Ÿ</a><br /><a href="https://toutiao.io/k/wa52n1g">é«˜å¹¶å‘ï¼Œæˆ‘æŠŠæ¡ä¸ä½å•Š</a><br /><a href="https://toutiao.io/k/7yfzhc1">åˆ†åŒºå–æ¨¡åˆ†åº“åˆ†è¡¨ç­–ç•¥ï¼šå¤šè¡¨äº‹åŠ¡åˆ†åº“å†…é—­ç¯è§£å†³æ–¹æ¡ˆ</a><br /><a href="https://toutiao.io/k/hcpeepo">å·¥å…· | Google å¼€æºçš„ï¼Œæ›´æ–¹ä¾¿ã€æ›´å‹å¥½åœ°å¸®åŠ©å¼€å‘è€…ç¼–å†™è„šæœ¬çš„å·¥å…·</a><br /><a href="https://toutiao.io/k/byr4l3l">æ¶æ„æ¨¡å¼ CQRS</a><br /><a href="https://toutiao.io/k/a0rzc4w">èŠèŠå‰ç«¯çš„é”™è¯¯æ—¥å¿—å’Œç›‘æ§</a><br /><a href="https://toutiao.io/k/aeu9gvf">Wavve è¿™ä¸ªäº§å“æ˜¯å¦‚ä½•å–äº†å‡ ç™¾ä¸‡ç¾é‡‘çš„ï¼Ÿ</a><br /><a href="https://toutiao.io/k/hq8mcsw">Apache Flink åœ¨ bilibili çš„å¤šå…ƒåŒ–æ¢ç´¢ä¸å®è·µ</a><br /><a href="https://toutiao.io/k/prv92im">pypy çœŸçš„èƒ½è®© Python æ¯” C è¿˜å¿«ä¹ˆï¼Ÿ</a><br /><a href="https://toutiao.io/k/h0opsan">å‰ç«¯æ™ºèƒ½åŒ–ï¼šå›¾å±‚æŠ½è±¡ä¸ä¼˜åŒ–</a><br /><a href="https://toutiao.io/k/bjis3t4">[æ¨è] 36 å¼ å›¾è¯¦è§£ç½‘ç»œåŸºç¡€çŸ¥è¯†</a><br /><a href="https://toutiao.io/k/nkx9rki">[æ¨è] æˆ‘è®¤ä¸ºæœ€ä¼˜ç¾çš„æ•°æ®ç»“æ„</a><br /><a href="https://toutiao.io/k/4fpatsr">[æ¨è] [è¯‘] Linux ç³»ç»Ÿå®‰å…¨å¼ºåŒ–æŒ‡å—</a><br /><a href="https://toutiao.io/k/gc13z71">[æ¨è] æ•°æ®åˆ†æåå¹´ï¼Œæˆ‘åªæ¨èè¿™äº›ä¹¦</a><br /><a href="https://toutiao.io/k/ca8fe6d">[æ¨è] åŠç‚¸å¤©çš„ Docker å›¾å½¢åŒ–å·¥å…· Portainerï¼Œå¿…é¡»æ¨èç»™ä½ </a><br /><a href="https://toutiao.io/k/4sywkcm">[æ¨è] å¾®æœåŠ¡è®¾è®¡åŸåˆ™</a><br /><a href="https://toutiao.io/k/6mzds1m">[æ¨è] ç³»ç»Ÿè®¾è®¡ä¹‹è·¯ï¼šå¦‚ä½•è®¾è®¡ä¸€ä¸ª URL çŸ­é“¾æœåŠ¡</a><br /><a href="https://toutiao.io/k/ss8h91v">[æ¨è] æ¶æ„å¸ˆå¿…çœ‹ï¼šæ¶æ„è®¾è®¡çš„å››å¤§æ€ç»´æ”¯æŸ±</a><br /><a href="https://toutiao.io/k/k1o0w99">[æ¨è] å“ˆå•°åœ¨åˆ†å¸ƒå¼æ¶ˆæ¯æ²»ç†å’Œå¾®æœåŠ¡æ²»ç†ä¸­çš„å®è·µ</a><br /><a href="https://toutiao.io/k/gs6z30z">[æ¨è] è½»è½»æ¾æ¾æ‰“å°ç½‘é¡µå¹¶ç”Ÿæˆ pdf æ–‡æ¡£</a><br /><a href="https://toutiao.io/k/2tnj5np">[æ¨è] RabbitMQã€Kafkaã€RocketMQ æ˜¯å¦‚ä½•å®ç°é«˜å¯ç”¨çš„ï¼Ÿ</a><br /><a href="https://toutiao.io/k/7v2gnx6">[æ¨è] ç¨‹åºå‘˜å¿…å¤‡åŸºç¡€ï¼š10 ç§å¸¸è§å®‰å…¨æ¼æ´æµ…æ</a><br /><hr /><a href="https://github.com/privacybot-berkeley/privacybot"></a><br /><a href="https://github.com/login?return_to=%2Fswar%2FSwar-Chia-Plot-Manager">This is a Cross-Platform Plot Manager for Chia Plotting that is simple, easy-to-use, and reliable.</a><br /><a href="https://github.com/h5bp/html5-boilerplate">A professional front-end template for building fast, robust, and adaptable web apps or sites.</a><br /><a href="https://github.com/login?return_to=%2Fsyncthing%2Fsyncthing">Open Source Continuous File Synchronization</a><br /><a href="https://github.com/trustwallet/assets">A comprehensive, up-to-date collection of information about several thousands (!) of crypto tokens.</a><br /><a href="https://github.com/AkihiroSuda/lima">Lima: Linux-on-Mac ("macOS subsystem for Linux", "containerd for Mac")</a><br /><a href="https://github.com/ec-/Quake3e">Improved Quake III Arena engine</a><br /><a href="https://github.com/cnzbpy/simplepy">These are some simple projects written in Python.</a><br /><a href="https://github.com/JanVanRyswyck/awesome-talks">Awesome online talks and screencasts</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">ğŸ—‚ The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/jklepatch/eattheblocks">Source code for Eat The Blocks, a screencast for Ethereum Dapp Developers</a><br /><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">ğŸ”— Some useful websites for programmers.</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">ğŸ˜ Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/data-science-on-aws/workshop">AI and Machine Learning with Kubeflow, Amazon EKS, and SageMaker</a><br /><a href="https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh">ç¨‹åºå‘˜åº”è¯¥è®¿é—®çš„æœ€ä½³ç½‘ç«™ä¸­æ–‡ç‰ˆ</a><br /><a href="https://github.com/positive-security/send-my">Upload arbitrary data via Apple's Find My network.</a><br /><a href="https://github.com/intel-isl/PhotorealismEnhancement">Code & Data for Enhancing Photorealism Enhancement</a><br /><a href="https://github.com/goldbergyoni/nodebestpractices">âœ… The Node.js best practices list (May 2021)</a><br /><a href="https://github.com/9emin1/charlotte">c++ fully undetected shellcode launcher ;)</a><br /><a href="https://github.com/https-deeplearning-ai/MLEP-public">Public repo for DeepLearning.AI MLEP Specialization</a><br /><a href="https://github.com/bepronetwork/bepro-js">The repository contains a comprehensive documentation of the bepro.network ecosystem as a javascript framework. If you are new to BEPRO, you might want to check out the Website Overview or our public "Start Building" Page.</a><br /><a href="https://github.com/cypress-io/cypress">Fast, easy and reliable testing for anything that runs in a browser.</a><br /><a href="https://github.com/login?return_to=%2Fkamranahmedse%2Fdeveloper-roadmap">Roadmap to becoming a web developer in 2021</a><br /><hr />äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹<br /><p>åœ¨äºŒå‰æ ‘ä¸­ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ·±åº¦ <code>0</code> å¤„ï¼Œæ¯ä¸ªæ·±åº¦ä¸º <code>k</code> çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä½äºæ·±åº¦ <code>k+1</code> å¤„ã€‚</p>

<p>å¦‚æœäºŒå‰æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œä½†<strong> çˆ¶èŠ‚ç‚¹ä¸åŒ</strong> ï¼Œåˆ™å®ƒä»¬æ˜¯ä¸€å¯¹<em>å ‚å…„å¼ŸèŠ‚ç‚¹</em>ã€‚</p>

<p>æˆ‘ä»¬ç»™å‡ºäº†å…·æœ‰å”¯ä¸€å€¼çš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ <code>root</code> ï¼Œä»¥åŠæ ‘ä¸­ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„å€¼ <code>x</code> å’Œ <code>y</code> ã€‚</p>

<p>åªæœ‰ä¸å€¼ <code>x</code> å’Œ <code>y</code> å¯¹åº”çš„èŠ‚ç‚¹æ˜¯å ‚å…„å¼ŸèŠ‚ç‚¹æ—¶ï¼Œæ‰è¿”å› <code>true</code> ã€‚å¦åˆ™ï¼Œè¿”å› <code>false</code>ã€‚</p>

<p>Â </p>

<p><strong>ç¤ºä¾‹ 1ï¼š<br />
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" style="height: 160px; width: 180px;" /></strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root = [1,2,3,4], x = 4, y = 3
<strong>è¾“å‡ºï¼š</strong>false
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š<br />
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" style="height: 160px; width: 201px;" /></strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4
<strong>è¾“å‡ºï¼š</strong>true
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" style="height: 160px; width: 156px;" /></strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>root = [1,2,3,null,4], x = 2, y = 3
<strong>è¾“å‡ºï¼š</strong>false</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li>äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ä»‹äºÂ <code>2</code> åˆ°Â <code>100</code>Â ä¹‹é—´ã€‚</li>
	<li>æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯å”¯ä¸€çš„ã€èŒƒå›´ä¸ºÂ <code>1</code> åˆ°Â <code>100</code>Â çš„æ•´æ•°ã€‚</li>
</ul>

<p>Â </p>
<br />#### å‰è¨€

è¦æƒ³åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹ $x$ å’Œ $y$ æ˜¯å¦ä¸ºå ‚å…„å¼ŸèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±éœ€è¦æ±‚å‡ºè¿™ä¸¤ä¸ªèŠ‚ç‚¹åˆ†åˆ«çš„ã€Œæ·±åº¦ã€ä»¥åŠã€Œçˆ¶èŠ‚ç‚¹ã€ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå¯¹æ ‘è¿›è¡Œä¸€æ¬¡éå†ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ç»´æŠ¤ã€Œæ·±åº¦ã€ä»¥åŠã€Œçˆ¶èŠ‚ç‚¹ã€è¿™ä¸¤ä¸ªä¿¡æ¯ã€‚å½“æˆ‘ä»¬éå†åˆ° $x$ æˆ– $y$ èŠ‚ç‚¹æ—¶ï¼Œå°±å°†ä¿¡æ¯è®°å½•ä¸‹æ¥ï¼›å½“è¿™ä¸¤ä¸ªèŠ‚ç‚¹éƒ½éå†å®Œæˆäº†ä»¥åï¼Œæˆ‘ä»¬å°±å¯ä»¥é€€å‡ºéå†çš„è¿‡ç¨‹ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦ä¸ºå ‚å…„å¼ŸèŠ‚ç‚¹äº†ã€‚

å¸¸è§çš„éå†æ–¹æ³•æœ‰ä¸¤ç§ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚

#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢

**æ€è·¯ä¸ç®—æ³•**

æˆ‘ä»¬åªéœ€è¦åœ¨æ·±åº¦ä¼˜å…ˆæœç´¢çš„é€’å½’å‡½æ•°ä¸­å¢åŠ è¡¨ç¤ºã€Œæ·±åº¦ã€ä»¥åŠã€Œçˆ¶èŠ‚ç‚¹ã€çš„ä¸¤ä¸ªå‚æ•°å³å¯ã€‚

**ä»£ç **

```C++ [sol1-C++]
class Solution {
private:
    // x çš„ä¿¡æ¯
    int x;
    TreeNode* x_parent;
    int x_depth;
    bool x_found = false;

    // y çš„ä¿¡æ¯
    int y;
    TreeNode* y_parent;
    int y_depth;
    bool y_found = false;

public:
    void dfs(TreeNode* node, int depth, TreeNode* parent) {
        if (!node) {
            return;
        }

        if (node->val == x) {
            tie(x_parent, x_depth, x_found) = tuple{parent, depth, true};
        }
        else if (node->val == y) {
            tie(y_parent, y_depth, y_found) = tuple{parent, depth, true};
        }

        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
        if (x_found && y_found) {
            return;
        }

        dfs(node->left, depth + 1, node);

        if (x_found && y_found) {
            return;
        }

        dfs(node->right, depth + 1, node);
    }

    bool isCousins(TreeNode* root, int x, int y) {
        this->x = x;
        this->y = y;
        dfs(root, 0, nullptr);
        return x_depth == y_depth && x_parent != y_parent;
    }
};
```

```Java [sol1-Java]
class Solution {
    // x çš„ä¿¡æ¯
    int x;
    TreeNode xParent;
    int xDepth;
    boolean xFound = false;

    // y çš„ä¿¡æ¯
    int y;
    TreeNode yParent;
    int yDepth;
    boolean yFound = false;

    public boolean isCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;
        dfs(root, 0, null);
        return xDepth == yDepth && xParent != yParent;
    }

    public void dfs(TreeNode node, int depth, TreeNode parent) {
        if (node == null) {
            return;
        }

        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }

        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
        if (xFound && yFound) {
            return;
        }

        dfs(node.left, depth + 1, node);

        if (xFound && yFound) {
            return;
        }

        dfs(node.right, depth + 1, node);
    }
}
```

```C# [sol1-C#]
public class Solution {
    // x çš„ä¿¡æ¯
    int x;
    TreeNode xParent;
    int xDepth;
    bool xFound = false;

    // y çš„ä¿¡æ¯
    int y;
    TreeNode yParent;
    int yDepth;
    bool yFound = false;

    public bool IsCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;
        DFS(root, 0, null);
        return xDepth == yDepth && xParent != yParent;
    }

    public void DFS(TreeNode node, int depth, TreeNode parent) {
        if (node == null) {
            return;
        }

        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }

        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
        if (xFound && yFound) {
            return;
        }

        DFS(node.left, depth + 1, node);

        if (xFound && yFound) {
            return;
        }

        DFS(node.right, depth + 1, node);
    }
}
```

```Python [sol1-Python3]
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        # x çš„ä¿¡æ¯
        x_parent, x_depth, x_found = None, None, False
        # y çš„ä¿¡æ¯
        y_parent, y_depth, y_found = None, None, False
        
        def dfs(node: TreeNode, depth: int, parent: TreeNode):
            if not node:
                return
            
            nonlocal x_parent, y_parent, x_depth, y_depth, x_found, y_found
            
            if node.val == x:
                x_parent, x_depth, x_found = parent, depth, True
            elif node.val == y:
                y_parent, y_depth, y_found = parent, depth, True

            # å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
            # å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
            if x_found and y_found:
                return

            dfs(node.left, depth + 1, node)

            if x_found and y_found:
                return

            dfs(node.right, depth + 1, node)

        dfs(root, 0, None)
        return x_depth == y_depth and x_parent != y_parent
```

```JavaScript [sol1-JavaScript]
var isCousins = function(root, x, y) {
    // x çš„ä¿¡æ¯
    let x_parent = null, x_depth = null, x_found = false;
    // y çš„ä¿¡æ¯
    let y_parent = null, y_depth = null, y_found = false;
    
    const dfs = (node, depth, parent) => {
        if (!node) {
            return;
        }
        if (node.val === x) {
            [x_parent, x_depth, x_found] = [parent, depth, true];
        } else if (node.val === y) {
            [y_parent, y_depth, y_found] = [parent, depth, true];
        }

        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
        if (x_found && y_found) {
            return;
        }

        dfs(node.left, depth + 1, node);

        if (x_found && y_found) {
            return;
        }

        dfs(node.right, depth + 1, node);
    }
    dfs(root, 0, null);
    return x_depth === y_depth && x_parent !== y_parent;
};
```

```go [sol1-Golang]
func isCousins(root *TreeNode, x, y int) bool {
    var xParent, yParent *TreeNode
    var xDepth, yDepth int
    var xFound, yFound bool

    var dfs func(node, parent *TreeNode, depth int)
    dfs = func(node, parent *TreeNode, depth int) {
        if node == nil {
            return
        }

        if node.Val == x {
            xParent, xDepth, xFound = parent, depth, true
        } else if node.Val == y {
            yParent, yDepth, yFound = parent, depth, true
        }

        // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
        // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
        if xFound && yFound {
            return
        }

        dfs(node.Left, node, depth+1)

        if xFound && yFound {
            return
        }

        dfs(node.Right, node, depth+1)
    }
    dfs(root, nil, 0)

    return xDepth == yDepth && xParent != yParent
}
```

```C [sol1-C]
// x çš„ä¿¡æ¯
int x_target;
struct TreeNode* x_parent;
int x_depth;
bool x_found;

// y çš„ä¿¡æ¯
int y_target;
struct TreeNode* y_parent;
int y_depth;
bool y_found;

void dfs(struct TreeNode* node, int depth, struct TreeNode* parent) {
    if (!node) {
        return;
    }

    if (node->val == x_target) {
        x_parent = parent;
        x_depth = depth;
        x_found = true;
    } else if (node->val == y_target) {
        y_parent = parent;
        y_depth = depth;
        y_found = true;
    }

    // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ‰¾åˆ°äº†ï¼Œå°±å¯ä»¥æå‰é€€å‡ºéå†
    // å³ä½¿ä¸æå‰é€€å‡ºï¼Œå¯¹æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ä¼šæœ‰å½±å“
    if (x_found && y_found) {
        return;
    }

    dfs(node->left, depth + 1, node);

    if (x_found && y_found) {
        return;
    }

    dfs(node->right, depth + 1, node);
}

bool isCousins(struct TreeNode* root, int x, int y) {
    x_target = x;
    y_target = y;
    x_found = false;
    y_found = false;
    dfs(root, 0, NULL);
    return x_depth == y_depth && x_parent != y_parent;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ‘ä¸­çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦éå†æ•´æ£µæ ‘ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºæ·±åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­éœ€è¦ä½¿ç”¨çš„æ ˆç©ºé—´ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæ ‘å‘ˆç°é“¾çŠ¶ç»“æ„ï¼Œé€’å½’çš„æ·±åº¦ä¸º $O(n)$ã€‚

#### æ–¹æ³•äºŒï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢

**æ€è·¯ä¸ç®—æ³•**

åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæ¯å½“æˆ‘ä»¬ä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒå°±ä¼šä½œä¸ºã€Œçˆ¶èŠ‚ç‚¹ã€ï¼Œå°†æœ€å¤šä¸¤ä¸ªå­èŠ‚ç‚¹æ”¾å…¥é˜Ÿå°¾ã€‚å› æ­¤ï¼Œé™¤äº†èŠ‚ç‚¹ä»¥å¤–ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨é˜Ÿåˆ—ä¸­é¢å¤–å­˜å‚¨ã€Œæ·±åº¦ã€çš„ä¿¡æ¯å³å¯ã€‚

**ä»£ç **

```C++ [sol2-C++]
class Solution {
private:
    // x çš„ä¿¡æ¯
    int x;
    TreeNode* x_parent;
    int x_depth;
    bool x_found = false;

    // y çš„ä¿¡æ¯
    int y;
    TreeNode* y_parent;
    int y_depth;
    bool y_found = false;

public:
    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
    void update(TreeNode* node, TreeNode* parent, int depth) {
        if (node->val == x) {
            tie(x_parent, x_depth, x_found) = tuple{parent, depth, true};
        }
        else if (node->val == y) {
            tie(y_parent, y_depth, y_found) = tuple{parent, depth, true};
        }
    }

    bool isCousins(TreeNode* root, int x, int y) {
        this->x = x;
        this->y = y;
        queue<pair<TreeNode*, int>> q;
        q.emplace(root, 0);
        update(root, nullptr, 0);

        while (!q.empty()) {
            auto&& [node, depth] = q.front();
            if (node->left) {
                q.emplace(node->left, depth + 1);
                update(node->left, node, depth + 1);
            }
            if (node->right) {
                q.emplace(node->right, depth + 1);
                update(node->right, node, depth + 1);
            }
            if (x_found && y_found) {
                break;
            }
            q.pop();
        }

        return x_depth == y_depth && x_parent != y_parent;
    }
};
```

```Java [sol2-Java]
class Solution {
    // x çš„ä¿¡æ¯
    int x;
    TreeNode xParent;
    int xDepth;
    boolean xFound = false;

    // y çš„ä¿¡æ¯
    int y;
    TreeNode yParent;
    int yDepth;
    boolean yFound = false;

    public boolean isCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;

        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();
        Queue<Integer> depthQueue = new LinkedList<Integer>();
        nodeQueue.offer(root);
        depthQueue.offer(0);
        update(root, null, 0);

        while (!nodeQueue.isEmpty()) {
            TreeNode node = nodeQueue.poll();
            int depth = depthQueue.poll();
            if (node.left != null) {
                nodeQueue.offer(node.left);
                depthQueue.offer(depth + 1);
                update(node.left, node, depth + 1);
            }
            if (node.right != null) {
                nodeQueue.offer(node.right);
                depthQueue.offer(depth + 1);
                update(node.right, node, depth + 1);
            }
            if (xFound && yFound) {
                break;
            }
        }

        return xDepth == yDepth && xParent != yParent;
    }

    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
    public void update(TreeNode node, TreeNode parent, int depth) {
        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }
    }
}
```

```C# [sol2-C#]
public class Solution {
    // x çš„ä¿¡æ¯
    int x;
    TreeNode xParent;
    int xDepth;
    bool xFound = false;

    // y çš„ä¿¡æ¯
    int y;
    TreeNode yParent;
    int yDepth;
    bool yFound = false;

    public bool IsCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;

        Queue<Tuple<TreeNode, int>> queue = new Queue<Tuple<TreeNode, int>>();
        queue.Enqueue(new Tuple<TreeNode, int>(root, 0));
        Update(root, null, 0);

        while (queue.Count > 0) {
            Tuple<TreeNode, int> tuple = queue.Dequeue();
            TreeNode node = tuple.Item1;
            int depth = tuple.Item2;
            if (node.left != null) {
                queue.Enqueue(new Tuple<TreeNode, int>(node.left, depth + 1));
                Update(node.left, node, depth + 1);
            }
            if (node.right != null) {
                queue.Enqueue(new Tuple<TreeNode, int>(node.right, depth + 1));
                Update(node.right, node, depth + 1);
            }
            if (xFound && yFound) {
                break;
            }
        }

        return xDepth == yDepth && xParent != yParent;
    }

    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
    public void Update(TreeNode node, TreeNode parent, int depth) {
        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }
    }
}
```

```Python [sol2-Python3]
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        # x çš„ä¿¡æ¯
        x_parent, x_depth, x_found = None, None, False
        # y çš„ä¿¡æ¯
        y_parent, y_depth, y_found = None, None, False
        
        # ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
        def update(node: TreeNode, parent: TreeNode, depth: int):
            if node.val == x:
                nonlocal x_parent, x_depth, x_found
                x_parent, x_depth, x_found = parent, depth, True
            elif node.val == y:
                nonlocal y_parent, y_depth, y_found
                y_parent, y_depth, y_found = parent, depth, True

        q = collections.deque([(root, 0)])
        update(root, None, 0)

        while q:
            node, depth = q.popleft()
            if node.left:
                q.append((node.left, depth + 1))
                update(node.left, node, depth + 1)
            if node.right:
                q.append((node.right, depth + 1))
                update(node.right, node, depth + 1)
            
            if x_found and y_found:
                break

        return x_depth == y_depth and x_parent != y_parent
```

```JavaScript [sol2-JavaScript]
var isCousins = function(root, x, y) {
    // x çš„ä¿¡æ¯
    let x_parent = null, x_depth = null, x_found = false;
    // y çš„ä¿¡æ¯
    let y_parent = null, y_depth = null, y_found = false;
    
    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
    const update = (node, parent, depth) => {
        if (node.val === x) {
            [x_parent, x_depth, x_found] = [parent, depth, true];
        } else if (node.val === y) {
            [y_parent, y_depth, y_found] = [parent, depth, true];
        }
    }

    q = [[root, 0]];
    update(root, null, 0);

    while (q.length) {
        const [node, depth] = q.shift()
        if (node.left){
            q.push([node.left, depth + 1]);
            update(node.left, node, depth + 1);
        }
        if (node.right) {
            q.push([node.right, depth + 1]);
            update(node.right, node, depth + 1);
        }
        
        if (x_found && y_found) {
            break;
        }
    }

    return x_depth === y_depth && x_parent !== y_parent;
};
```

```go [sol2-Golang]
func isCousins(root *TreeNode, x, y int) bool {
    var xParent, yParent *TreeNode
    var xDepth, yDepth int
    var xFound, yFound bool

    // ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
    update := func(node, parent *TreeNode, depth int) {
        if node.Val == x {
            xParent, xDepth, xFound = parent, depth, true
        } else if node.Val == y {
            yParent, yDepth, yFound = parent, depth, true
        }
    }

    type pair struct {
        node  *TreeNode
        depth int
    }
    q := []pair{{root, 0}}
    update(root, nil, 0)
    for len(q) > 0 && (!xFound || !yFound) {
        node, depth := q[0].node, q[0].depth
        q = q[1:]
        if node.Left != nil {
            q = append(q, pair{node.Left, depth + 1})
            update(node.Left, node, depth+1)
        }
        if node.Right != nil {
            q = append(q, pair{node.Right, depth + 1})
            update(node.Right, node, depth+1)
        }
    }

    return xDepth == yDepth && xParent != yParent
}
```

```C [sol2-C]
// x çš„ä¿¡æ¯
int x_target;
struct TreeNode* x_parent;
int x_depth;
bool x_found;

// y çš„ä¿¡æ¯
int y_target;
struct TreeNode* y_parent;
int y_depth;
bool y_found;

// ç”¨æ¥åˆ¤æ–­æ˜¯å¦éå†åˆ° x æˆ– y çš„è¾…åŠ©å‡½æ•°
void update(struct TreeNode* node, struct TreeNode* parent, int depth) {
    if (node->val == x_target) {
        x_parent = parent;
        x_depth = depth;
        x_found = true;
    } else if (node->val == y_target) {
        y_parent = parent;
        y_depth = depth;
        y_found = true;
    }
}

struct Node {
    struct TreeNode* node;
    int depth;
};

bool isCousins(struct TreeNode* root, int x, int y) {
    x_target = x;
    y_target = y;
    x_found = false;
    y_found = false;

    struct Node q[100];
    int left = 0, right = 0;
    q[right++] = (struct Node){root, 0};
    update(root, NULL, 0);

    while (left < right) {
        if (q[left].node->left) {
            q[right++] = (struct Node){q[left].node->left, q[left].depth + 1};
            update(q[left].node->left, q[left].node, q[left].depth + 1);
        }
        if (q[left].node->right) {
            q[right++] = (struct Node){q[left].node->right, q[left].depth + 1};
            update(q[left].node->right, q[left].node, q[left].depth + 1);
        }
        if (x_found && y_found) {
            break;
        }
        left++;
    }

    return x_depth == y_depth && x_parent != y_parent;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ‘ä¸­çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦éå†æ•´æ£µæ ‘ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºå¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ä¸­éœ€è¦ä½¿ç”¨çš„é˜Ÿåˆ—ç©ºé—´ã€‚