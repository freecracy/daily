# 2021年05月17日 code
<a href="https://toutiao.io/k/jt9e5bq">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a><br /><a href="https://toutiao.io/k/wa52n1g">高并发，我把握不住啊</a><br /><a href="https://toutiao.io/k/7yfzhc1">分区取模分库分表策略：多表事务分库内闭环解决方案</a><br /><a href="https://toutiao.io/k/hcpeepo">工具 | Google 开源的，更方便、更友好地帮助开发者编写脚本的工具</a><br /><a href="https://toutiao.io/k/byr4l3l">架构模式 CQRS</a><br /><a href="https://toutiao.io/k/a0rzc4w">聊聊前端的错误日志和监控</a><br /><a href="https://toutiao.io/k/aeu9gvf">Wavve 这个产品是如何卖了几百万美金的？</a><br /><a href="https://toutiao.io/k/hq8mcsw">Apache Flink 在 bilibili 的多元化探索与实践</a><br /><a href="https://toutiao.io/k/prv92im">pypy 真的能让 Python 比 C 还快么？</a><br /><a href="https://toutiao.io/k/h0opsan">前端智能化：图层抽象与优化</a><br /><a href="https://toutiao.io/k/bjis3t4">[推荐] 36 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/nkx9rki">[推荐] 我认为最优美的数据结构</a><br /><a href="https://toutiao.io/k/4fpatsr">[推荐] [译] Linux 系统安全强化指南</a><br /><a href="https://toutiao.io/k/gc13z71">[推荐] 数据分析十年，我只推荐这些书</a><br /><a href="https://toutiao.io/k/ca8fe6d">[推荐] 吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</a><br /><a href="https://toutiao.io/k/4sywkcm">[推荐] 微服务设计原则</a><br /><a href="https://toutiao.io/k/6mzds1m">[推荐] 系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/ss8h91v">[推荐] 架构师必看：架构设计的四大思维支柱</a><br /><a href="https://toutiao.io/k/k1o0w99">[推荐] 哈啰在分布式消息治理和微服务治理中的实践</a><br /><a href="https://toutiao.io/k/gs6z30z">[推荐] 轻轻松松打印网页并生成 pdf 文档</a><br /><a href="https://toutiao.io/k/2tnj5np">[推荐] RabbitMQ、Kafka、RocketMQ 是如何实现高可用的？</a><br /><a href="https://toutiao.io/k/7v2gnx6">[推荐] 程序员必备基础：10 种常见安全漏洞浅析</a><br /><hr /><a href="https://github.com/privacybot-berkeley/privacybot"></a><br /><a href="https://github.com/login?return_to=%2Fswar%2FSwar-Chia-Plot-Manager">This is a Cross-Platform Plot Manager for Chia Plotting that is simple, easy-to-use, and reliable.</a><br /><a href="https://github.com/h5bp/html5-boilerplate">A professional front-end template for building fast, robust, and adaptable web apps or sites.</a><br /><a href="https://github.com/login?return_to=%2Fsyncthing%2Fsyncthing">Open Source Continuous File Synchronization</a><br /><a href="https://github.com/trustwallet/assets">A comprehensive, up-to-date collection of information about several thousands (!) of crypto tokens.</a><br /><a href="https://github.com/AkihiroSuda/lima">Lima: Linux-on-Mac ("macOS subsystem for Linux", "containerd for Mac")</a><br /><a href="https://github.com/ec-/Quake3e">Improved Quake III Arena engine</a><br /><a href="https://github.com/cnzbpy/simplepy">These are some simple projects written in Python.</a><br /><a href="https://github.com/JanVanRyswyck/awesome-talks">Awesome online talks and screencasts</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/jklepatch/eattheblocks">Source code for Eat The Blocks, a screencast for Ethereum Dapp Developers</a><br /><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">🔗 Some useful websites for programmers.</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/login?return_to=%2Fsindresorhus%2Fawesome">😎 Awesome lists about all kinds of interesting topics</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/data-science-on-aws/workshop">AI and Machine Learning with Kubeflow, Amazon EKS, and SageMaker</a><br /><a href="https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh">程序员应该访问的最佳网站中文版</a><br /><a href="https://github.com/positive-security/send-my">Upload arbitrary data via Apple's Find My network.</a><br /><a href="https://github.com/intel-isl/PhotorealismEnhancement">Code & Data for Enhancing Photorealism Enhancement</a><br /><a href="https://github.com/goldbergyoni/nodebestpractices">✅ The Node.js best practices list (May 2021)</a><br /><a href="https://github.com/9emin1/charlotte">c++ fully undetected shellcode launcher ;)</a><br /><a href="https://github.com/https-deeplearning-ai/MLEP-public">Public repo for DeepLearning.AI MLEP Specialization</a><br /><a href="https://github.com/bepronetwork/bepro-js">The repository contains a comprehensive documentation of the bepro.network ecosystem as a javascript framework. If you are new to BEPRO, you might want to check out the Website Overview or our public "Start Building" Page.</a><br /><a href="https://github.com/cypress-io/cypress">Fast, easy and reliable testing for anything that runs in a browser.</a><br /><a href="https://github.com/login?return_to=%2Fkamranahmedse%2Fdeveloper-roadmap">Roadmap to becoming a web developer in 2021</a><br /><hr />二叉树的堂兄弟节点<br /><p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>

<p>如果二叉树的两个节点深度相同，但<strong> 父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>

<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>

<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>

<p> </p>

<p><strong>示例 1：<br />
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" style="height: 160px; width: 180px;" /></strong></p>

<pre>
<strong>输入：</strong>root = [1,2,3,4], x = 4, y = 3
<strong>输出：</strong>false
</pre>

<p><strong>示例 2：<br />
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" style="height: 160px; width: 201px;" /></strong></p>

<pre>
<strong>输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4
<strong>输出：</strong>true
</pre>

<p><strong>示例 3：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png" style="height: 160px; width: 156px;" /></strong></p>

<pre>
<strong>输入：</strong>root = [1,2,3,null,4], x = 2, y = 3
<strong>输出：</strong>false</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>
	<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>
</ul>

<p> </p>
<br />#### 前言

要想判断两个节点 $x$ 和 $y$ 是否为堂兄弟节点，我们就需要求出这两个节点分别的「深度」以及「父节点」。

因此，我们可以从根节点开始，对树进行一次遍历，在遍历的过程中维护「深度」以及「父节点」这两个信息。当我们遍历到 $x$ 或 $y$ 节点时，就将信息记录下来；当这两个节点都遍历完成了以后，我们就可以退出遍历的过程，判断它们是否为堂兄弟节点了。

常见的遍历方法有两种：深度优先搜索和广度优先搜索。

#### 方法一：深度优先搜索

**思路与算法**

我们只需要在深度优先搜索的递归函数中增加表示「深度」以及「父节点」的两个参数即可。

**代码**

```C++ [sol1-C++]
class Solution {
private:
    // x 的信息
    int x;
    TreeNode* x_parent;
    int x_depth;
    bool x_found = false;

    // y 的信息
    int y;
    TreeNode* y_parent;
    int y_depth;
    bool y_found = false;

public:
    void dfs(TreeNode* node, int depth, TreeNode* parent) {
        if (!node) {
            return;
        }

        if (node->val == x) {
            tie(x_parent, x_depth, x_found) = tuple{parent, depth, true};
        }
        else if (node->val == y) {
            tie(y_parent, y_depth, y_found) = tuple{parent, depth, true};
        }

        // 如果两个节点都找到了，就可以提前退出遍历
        // 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
        if (x_found && y_found) {
            return;
        }

        dfs(node->left, depth + 1, node);

        if (x_found && y_found) {
            return;
        }

        dfs(node->right, depth + 1, node);
    }

    bool isCousins(TreeNode* root, int x, int y) {
        this->x = x;
        this->y = y;
        dfs(root, 0, nullptr);
        return x_depth == y_depth && x_parent != y_parent;
    }
};
```

```Java [sol1-Java]
class Solution {
    // x 的信息
    int x;
    TreeNode xParent;
    int xDepth;
    boolean xFound = false;

    // y 的信息
    int y;
    TreeNode yParent;
    int yDepth;
    boolean yFound = false;

    public boolean isCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;
        dfs(root, 0, null);
        return xDepth == yDepth && xParent != yParent;
    }

    public void dfs(TreeNode node, int depth, TreeNode parent) {
        if (node == null) {
            return;
        }

        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }

        // 如果两个节点都找到了，就可以提前退出遍历
        // 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
        if (xFound && yFound) {
            return;
        }

        dfs(node.left, depth + 1, node);

        if (xFound && yFound) {
            return;
        }

        dfs(node.right, depth + 1, node);
    }
}
```

```C# [sol1-C#]
public class Solution {
    // x 的信息
    int x;
    TreeNode xParent;
    int xDepth;
    bool xFound = false;

    // y 的信息
    int y;
    TreeNode yParent;
    int yDepth;
    bool yFound = false;

    public bool IsCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;
        DFS(root, 0, null);
        return xDepth == yDepth && xParent != yParent;
    }

    public void DFS(TreeNode node, int depth, TreeNode parent) {
        if (node == null) {
            return;
        }

        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }

        // 如果两个节点都找到了，就可以提前退出遍历
        // 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
        if (xFound && yFound) {
            return;
        }

        DFS(node.left, depth + 1, node);

        if (xFound && yFound) {
            return;
        }

        DFS(node.right, depth + 1, node);
    }
}
```

```Python [sol1-Python3]
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        # x 的信息
        x_parent, x_depth, x_found = None, None, False
        # y 的信息
        y_parent, y_depth, y_found = None, None, False
        
        def dfs(node: TreeNode, depth: int, parent: TreeNode):
            if not node:
                return
            
            nonlocal x_parent, y_parent, x_depth, y_depth, x_found, y_found
            
            if node.val == x:
                x_parent, x_depth, x_found = parent, depth, True
            elif node.val == y:
                y_parent, y_depth, y_found = parent, depth, True

            # 如果两个节点都找到了，就可以提前退出遍历
            # 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
            if x_found and y_found:
                return

            dfs(node.left, depth + 1, node)

            if x_found and y_found:
                return

            dfs(node.right, depth + 1, node)

        dfs(root, 0, None)
        return x_depth == y_depth and x_parent != y_parent
```

```JavaScript [sol1-JavaScript]
var isCousins = function(root, x, y) {
    // x 的信息
    let x_parent = null, x_depth = null, x_found = false;
    // y 的信息
    let y_parent = null, y_depth = null, y_found = false;
    
    const dfs = (node, depth, parent) => {
        if (!node) {
            return;
        }
        if (node.val === x) {
            [x_parent, x_depth, x_found] = [parent, depth, true];
        } else if (node.val === y) {
            [y_parent, y_depth, y_found] = [parent, depth, true];
        }

        // 如果两个节点都找到了，就可以提前退出遍历
        // 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
        if (x_found && y_found) {
            return;
        }

        dfs(node.left, depth + 1, node);

        if (x_found && y_found) {
            return;
        }

        dfs(node.right, depth + 1, node);
    }
    dfs(root, 0, null);
    return x_depth === y_depth && x_parent !== y_parent;
};
```

```go [sol1-Golang]
func isCousins(root *TreeNode, x, y int) bool {
    var xParent, yParent *TreeNode
    var xDepth, yDepth int
    var xFound, yFound bool

    var dfs func(node, parent *TreeNode, depth int)
    dfs = func(node, parent *TreeNode, depth int) {
        if node == nil {
            return
        }

        if node.Val == x {
            xParent, xDepth, xFound = parent, depth, true
        } else if node.Val == y {
            yParent, yDepth, yFound = parent, depth, true
        }

        // 如果两个节点都找到了，就可以提前退出遍历
        // 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
        if xFound && yFound {
            return
        }

        dfs(node.Left, node, depth+1)

        if xFound && yFound {
            return
        }

        dfs(node.Right, node, depth+1)
    }
    dfs(root, nil, 0)

    return xDepth == yDepth && xParent != yParent
}
```

```C [sol1-C]
// x 的信息
int x_target;
struct TreeNode* x_parent;
int x_depth;
bool x_found;

// y 的信息
int y_target;
struct TreeNode* y_parent;
int y_depth;
bool y_found;

void dfs(struct TreeNode* node, int depth, struct TreeNode* parent) {
    if (!node) {
        return;
    }

    if (node->val == x_target) {
        x_parent = parent;
        x_depth = depth;
        x_found = true;
    } else if (node->val == y_target) {
        y_parent = parent;
        y_depth = depth;
        y_found = true;
    }

    // 如果两个节点都找到了，就可以提前退出遍历
    // 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
    if (x_found && y_found) {
        return;
    }

    dfs(node->left, depth + 1, node);

    if (x_found && y_found) {
        return;
    }

    dfs(node->right, depth + 1, node);
}

bool isCousins(struct TreeNode* root, int x, int y) {
    x_target = x;
    y_target = y;
    x_found = false;
    y_found = false;
    dfs(root, 0, NULL);
    return x_depth == y_depth && x_parent != y_parent;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是树中的节点个数。在最坏情况下，我们需要遍历整棵树，时间复杂度为 $O(n)$。

- 空间复杂度：$O(n)$，即为深度优先搜索的过程中需要使用的栈空间。在最坏情况下，树呈现链状结构，递归的深度为 $O(n)$。

#### 方法二：广度优先搜索

**思路与算法**

在广度优先搜索的过程中，每当我们从队首取出一个节点，它就会作为「父节点」，将最多两个子节点放入队尾。因此，除了节点以外，我们只需要在队列中额外存储「深度」的信息即可。

**代码**

```C++ [sol2-C++]
class Solution {
private:
    // x 的信息
    int x;
    TreeNode* x_parent;
    int x_depth;
    bool x_found = false;

    // y 的信息
    int y;
    TreeNode* y_parent;
    int y_depth;
    bool y_found = false;

public:
    // 用来判断是否遍历到 x 或 y 的辅助函数
    void update(TreeNode* node, TreeNode* parent, int depth) {
        if (node->val == x) {
            tie(x_parent, x_depth, x_found) = tuple{parent, depth, true};
        }
        else if (node->val == y) {
            tie(y_parent, y_depth, y_found) = tuple{parent, depth, true};
        }
    }

    bool isCousins(TreeNode* root, int x, int y) {
        this->x = x;
        this->y = y;
        queue<pair<TreeNode*, int>> q;
        q.emplace(root, 0);
        update(root, nullptr, 0);

        while (!q.empty()) {
            auto&& [node, depth] = q.front();
            if (node->left) {
                q.emplace(node->left, depth + 1);
                update(node->left, node, depth + 1);
            }
            if (node->right) {
                q.emplace(node->right, depth + 1);
                update(node->right, node, depth + 1);
            }
            if (x_found && y_found) {
                break;
            }
            q.pop();
        }

        return x_depth == y_depth && x_parent != y_parent;
    }
};
```

```Java [sol2-Java]
class Solution {
    // x 的信息
    int x;
    TreeNode xParent;
    int xDepth;
    boolean xFound = false;

    // y 的信息
    int y;
    TreeNode yParent;
    int yDepth;
    boolean yFound = false;

    public boolean isCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;

        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();
        Queue<Integer> depthQueue = new LinkedList<Integer>();
        nodeQueue.offer(root);
        depthQueue.offer(0);
        update(root, null, 0);

        while (!nodeQueue.isEmpty()) {
            TreeNode node = nodeQueue.poll();
            int depth = depthQueue.poll();
            if (node.left != null) {
                nodeQueue.offer(node.left);
                depthQueue.offer(depth + 1);
                update(node.left, node, depth + 1);
            }
            if (node.right != null) {
                nodeQueue.offer(node.right);
                depthQueue.offer(depth + 1);
                update(node.right, node, depth + 1);
            }
            if (xFound && yFound) {
                break;
            }
        }

        return xDepth == yDepth && xParent != yParent;
    }

    // 用来判断是否遍历到 x 或 y 的辅助函数
    public void update(TreeNode node, TreeNode parent, int depth) {
        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }
    }
}
```

```C# [sol2-C#]
public class Solution {
    // x 的信息
    int x;
    TreeNode xParent;
    int xDepth;
    bool xFound = false;

    // y 的信息
    int y;
    TreeNode yParent;
    int yDepth;
    bool yFound = false;

    public bool IsCousins(TreeNode root, int x, int y) {
        this.x = x;
        this.y = y;

        Queue<Tuple<TreeNode, int>> queue = new Queue<Tuple<TreeNode, int>>();
        queue.Enqueue(new Tuple<TreeNode, int>(root, 0));
        Update(root, null, 0);

        while (queue.Count > 0) {
            Tuple<TreeNode, int> tuple = queue.Dequeue();
            TreeNode node = tuple.Item1;
            int depth = tuple.Item2;
            if (node.left != null) {
                queue.Enqueue(new Tuple<TreeNode, int>(node.left, depth + 1));
                Update(node.left, node, depth + 1);
            }
            if (node.right != null) {
                queue.Enqueue(new Tuple<TreeNode, int>(node.right, depth + 1));
                Update(node.right, node, depth + 1);
            }
            if (xFound && yFound) {
                break;
            }
        }

        return xDepth == yDepth && xParent != yParent;
    }

    // 用来判断是否遍历到 x 或 y 的辅助函数
    public void Update(TreeNode node, TreeNode parent, int depth) {
        if (node.val == x) {
            xParent = parent;
            xDepth = depth;
            xFound = true;
        } else if (node.val == y) {
            yParent = parent;
            yDepth = depth;
            yFound = true;
        }
    }
}
```

```Python [sol2-Python3]
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        # x 的信息
        x_parent, x_depth, x_found = None, None, False
        # y 的信息
        y_parent, y_depth, y_found = None, None, False
        
        # 用来判断是否遍历到 x 或 y 的辅助函数
        def update(node: TreeNode, parent: TreeNode, depth: int):
            if node.val == x:
                nonlocal x_parent, x_depth, x_found
                x_parent, x_depth, x_found = parent, depth, True
            elif node.val == y:
                nonlocal y_parent, y_depth, y_found
                y_parent, y_depth, y_found = parent, depth, True

        q = collections.deque([(root, 0)])
        update(root, None, 0)

        while q:
            node, depth = q.popleft()
            if node.left:
                q.append((node.left, depth + 1))
                update(node.left, node, depth + 1)
            if node.right:
                q.append((node.right, depth + 1))
                update(node.right, node, depth + 1)
            
            if x_found and y_found:
                break

        return x_depth == y_depth and x_parent != y_parent
```

```JavaScript [sol2-JavaScript]
var isCousins = function(root, x, y) {
    // x 的信息
    let x_parent = null, x_depth = null, x_found = false;
    // y 的信息
    let y_parent = null, y_depth = null, y_found = false;
    
    // 用来判断是否遍历到 x 或 y 的辅助函数
    const update = (node, parent, depth) => {
        if (node.val === x) {
            [x_parent, x_depth, x_found] = [parent, depth, true];
        } else if (node.val === y) {
            [y_parent, y_depth, y_found] = [parent, depth, true];
        }
    }

    q = [[root, 0]];
    update(root, null, 0);

    while (q.length) {
        const [node, depth] = q.shift()
        if (node.left){
            q.push([node.left, depth + 1]);
            update(node.left, node, depth + 1);
        }
        if (node.right) {
            q.push([node.right, depth + 1]);
            update(node.right, node, depth + 1);
        }
        
        if (x_found && y_found) {
            break;
        }
    }

    return x_depth === y_depth && x_parent !== y_parent;
};
```

```go [sol2-Golang]
func isCousins(root *TreeNode, x, y int) bool {
    var xParent, yParent *TreeNode
    var xDepth, yDepth int
    var xFound, yFound bool

    // 用来判断是否遍历到 x 或 y 的辅助函数
    update := func(node, parent *TreeNode, depth int) {
        if node.Val == x {
            xParent, xDepth, xFound = parent, depth, true
        } else if node.Val == y {
            yParent, yDepth, yFound = parent, depth, true
        }
    }

    type pair struct {
        node  *TreeNode
        depth int
    }
    q := []pair{{root, 0}}
    update(root, nil, 0)
    for len(q) > 0 && (!xFound || !yFound) {
        node, depth := q[0].node, q[0].depth
        q = q[1:]
        if node.Left != nil {
            q = append(q, pair{node.Left, depth + 1})
            update(node.Left, node, depth+1)
        }
        if node.Right != nil {
            q = append(q, pair{node.Right, depth + 1})
            update(node.Right, node, depth+1)
        }
    }

    return xDepth == yDepth && xParent != yParent
}
```

```C [sol2-C]
// x 的信息
int x_target;
struct TreeNode* x_parent;
int x_depth;
bool x_found;

// y 的信息
int y_target;
struct TreeNode* y_parent;
int y_depth;
bool y_found;

// 用来判断是否遍历到 x 或 y 的辅助函数
void update(struct TreeNode* node, struct TreeNode* parent, int depth) {
    if (node->val == x_target) {
        x_parent = parent;
        x_depth = depth;
        x_found = true;
    } else if (node->val == y_target) {
        y_parent = parent;
        y_depth = depth;
        y_found = true;
    }
}

struct Node {
    struct TreeNode* node;
    int depth;
};

bool isCousins(struct TreeNode* root, int x, int y) {
    x_target = x;
    y_target = y;
    x_found = false;
    y_found = false;

    struct Node q[100];
    int left = 0, right = 0;
    q[right++] = (struct Node){root, 0};
    update(root, NULL, 0);

    while (left < right) {
        if (q[left].node->left) {
            q[right++] = (struct Node){q[left].node->left, q[left].depth + 1};
            update(q[left].node->left, q[left].node, q[left].depth + 1);
        }
        if (q[left].node->right) {
            q[right++] = (struct Node){q[left].node->right, q[left].depth + 1};
            update(q[left].node->right, q[left].node, q[left].depth + 1);
        }
        if (x_found && y_found) {
            break;
        }
        left++;
    }

    return x_depth == y_depth && x_parent != y_parent;
}
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是树中的节点个数。在最坏情况下，我们需要遍历整棵树，时间复杂度为 $O(n)$。

- 空间复杂度：$O(n)$，即为广度优先搜索的过程中需要使用的队列空间。