# 2021年05月01日 code
<a href="https://toutiao.io/k/a5s1rfh">前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/07t0av0">Spring 内存木马检测思路</a><br /><a href="https://toutiao.io/k/iwkig90">殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/4x0e8oq">关于中台，聊聊我认为相对客观的三点认知</a><br /><a href="https://toutiao.io/k/frzkkqc">千亿级公司低代码平台的测试体系介绍</a><br /><a href="https://toutiao.io/k/3l7z9ff">《深度学习推荐系统》笔记（三）：被玩坏了的模型，我们要做减法</a><br /><a href="https://toutiao.io/k/oqww1ni">牛逼！Elasticsearch 集群更换节点角色有了更快的方式</a><br /><a href="https://toutiao.io/k/ok4mp6n">五一假期不想人挤人？来这里！</a><br /><a href="https://toutiao.io/k/rk2skj2">在 Kotlin 序列化中使用 DataStore</a><br /><a href="https://toutiao.io/k/7e4momt">WebSocket 使用</a><br /><a href="https://toutiao.io/k/oept9z6">移动 App 隐私合规检测解决方案初探</a><br /><a href="https://toutiao.io/k/4oforsb">CSS 的 :placeholder-shown 伪类有什么用？</a><br /><a href="https://toutiao.io/k/mk4w0mv">Xcode 编译疾如风（三）：浅谈 dwarf 和 dSYM</a><br /><a href="https://toutiao.io/k/rr8i9ed">Flink on RocksDB 参数调优指南</a><br /><a href="https://toutiao.io/k/h7gv9vt">漫画：没有一个程序员能拒绝这样的女朋友</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/2aonyjp">[推荐] 把 Redis 当作队列来用，真的合适吗？</a><br /><a href="https://toutiao.io/k/90vs9kg">[推荐] ClickHouse 在 Bilibili 用户行为分析的实践</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/syxnrph">[推荐] OpenResty 实现限流</a><br /><a href="https://toutiao.io/k/czntgsa">[推荐] 这 11 款 Chrome 神器，用起来爽到爆</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><hr /><a href="https://github.com/login?return_to=%2Fsupabase%2Fsupabase">The open source Firebase alternative. Follow to stay updated about our public Beta.</a><br /><a href="https://github.com/livewire/livewire">A full-stack framework for Laravel that takes the pain out of building dynamic UIs.</a><br /><a href="https://github.com/johnBuffer/NoCol">Trajectories finder</a><br /><a href="https://github.com/521xueweihan/HelloGitHub">分享 GitHub 上有趣、入门级的开源项目</a><br /><a href="https://github.com/Developer-Y/cs-video-courses">List of Computer Science courses with video lectures.</a><br /><a href="https://github.com/PaddlePaddle/PaddleDetection">Object detection and instance segmentation toolkit based on PaddlePaddle.</a><br /><a href="https://github.com/nextapps-de/winbox">WinBox is a professional HTML5 window manager for the web: lightweight, outstanding performance, no dependencies, fully customizable, open source!</a><br /><a href="https://github.com/UnityTechnologies/open-project-1">Unity Open Project #1: Chop Chop</a><br /><a href="https://github.com/flashlight/flashlight">A C++ standalone library for machine learning</a><br /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/login?return_to=%2Fdani-garcia%2Fvaultwarden">Unofficial Bitwarden compatible server written in Rust, formerly known as bitwarden_rs</a><br /><a href="https://github.com/nvbn/thefuck">Magnificent app which corrects your previous console command.</a><br /><a href="https://github.com/login?return_to=%2Ftrekhleb%2Fjavascript-algorithms">📝 Algorithms and data structures implemented in JavaScript with explanations and links to further readings</a><br /><a href="https://github.com/doocs/leetcode">😏 LeetCode solutions in any programming language | 多种编程语言实现 LeetCode、《剑指 Offer（第 2 版）》、《程序员面试金典（第 6 版）》题解</a><br /><a href="https://github.com/mlflow/mlflow">Open source platform for the machine learning lifecycle</a><br /><a href="https://github.com/xinliangnote/go-gin-api">基于 Gin 进行模块化设计的 API 框架，封装了常用功能，使用简单，致力于进行快速的业务研发。比如，支持 cors 跨域、jwt 签名验证、zap 日志收集、panic 异常捕获、trace 链路追踪、prometheus 监控指标、swagger 文档生成、viper 配置文件解析、gorm 数据库组件、gormgen 代码生成工具、graphql 查询语言、errno 统一定义错误码、gRPC 的使用 等等。</a><br /><a href="https://github.com/gitflai/Semana-do-Iniciante-em-Data-Science"></a><br /><a href="https://github.com/tensorflow/tensorboard">TensorFlow's Visualization Toolkit</a><br /><a href="https://github.com/SagerNet/SagerNet">The universal proxy toolchain for Android.</a><br /><a href="https://github.com/commaai/openpilot">openpilot is an open source driver assistance system. openpilot performs the functions of Automated Lane Centering and Adaptive Cruise Control for over 100 supported car makes and models.</a><br /><a href="https://github.com/chrisleekr/binance-trading-bot">Automated Binance trading bot - Buy low/Sell high with stop loss limit/Trade multiple cryptocurrencies</a><br /><a href="https://github.com/storj/drpc">drpc is a lightweight, drop-in replacement for gRPC</a><br /><a href="https://github.com/airbnb/lottie-ios">An iOS library to natively render After Effects vector animations</a><br /><a href="https://github.com/seek-oss/vanilla-extract">Zero-runtime Stylesheets-in-TypeScript</a><br /><a href="https://github.com/huggingface/datasets">🤗 The largest hub of ready-to-use NLP datasets for ML models with fast, easy-to-use and efficient data manipulation tools</a><br /><hr />员工的重要性<br /><p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id </strong>，<strong>重要度 </strong>和 <strong>直系下属的 id </strong>。</p>

<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p>

<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>

<p> </p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
<strong>输出：</strong>11
<strong>解释：</strong>
员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li>一个员工最多有一个<strong> 直系 </strong>领导，但是可以有多个 <strong>直系 </strong>下属</li>
	<li>员工数量不超过 2000 。</li>
</ul>
<br />#### 前言

由于一个员工最多有一个直系领导，可以有零个或若干个直系下属，因此员工之间的领导和下属关系构成树的结构。给定一个员工编号，要求计算这个员工及其所有下属的重要性之和，即为找到以该员工为根节点的子树的结构中，每个员工的重要性之和。

对于树结构的问题，可以使用深度优先搜索或广度优先搜索的方法解决。

#### 方法一：深度优先搜索

深度优先搜索的做法非常直观。根据给定的员工编号找到员工，从该员工开始遍历，对于每个员工，将其重要性加到总和中，然后对该员工的每个直系下属继续遍历，直到所有下属遍历完毕，此时的总和即为给定的员工及其所有下属的重要性之和。

实现方面，由于给定的是员工编号，且每个员工的编号都不相同，因此可以使用哈希表存储每个员工编号和对应的员工，即可通过员工编号得到对应的员工。

```Java [sol1-Java]
class Solution {
    Map<Integer, Employee> map = new HashMap<Integer, Employee>();

    public int getImportance(List<Employee> employees, int id) {
        for (Employee employee : employees) {
            map.put(employee.id, employee);
        }
        return dfs(id);
    }

    public int dfs(int id) {
        Employee employee = map.get(id);
        int total = employee.importance;
        List<Integer> subordinates = employee.subordinates;
        for (int subId : subordinates) {
            total += dfs(subId);
        }
        return total;
    }
}
```

```C# [sol1-C#]
class Solution {
    Dictionary<int, Employee> dictionary = new Dictionary<int, Employee>();

    public int GetImportance(IList<Employee> employees, int id) {
        foreach (Employee employee in employees) {
            dictionary.Add(employee.id, employee);
        }
        return DFS(id);
    }

    public int DFS(int id) {
        Employee employee = dictionary[id];
        int total = employee.importance;
        IList<int> subordinates = employee.subordinates;
        foreach (int subId in subordinates) {
            total += DFS(subId);
        }
        return total;
    }
}
```

```JavaScript [sol1-JavaScript]
var GetImportance = function(employees, id) {
    const map = new Map();
    for (const employee of employees) {
        map.set(employee.id, employee);
    }
    const dfs = (id) => {
        const employee = map.get(id);
        let total = employee.importance;
        const subordinates = employee.subordinates;
        for (const subId of subordinates) {
            total += dfs(subId);
        }
        return total;
        
    }

    return dfs(id);
};
```

```go [sol1-Golang]
func getImportance(employees []*Employee, id int) (total int) {
    mp := map[int]*Employee{}
    for _, employee := range employees {
        mp[employee.Id] = employee
    }

    var dfs func(int)
    dfs = func(id int) {
        employee := mp[id]
        total += employee.Importance
        for _, subId := range employee.Subordinates {
            dfs(subId)
        }
    }
    dfs(id)
    return
}
```

```C++ [sol1-C++]
class Solution {
public:
    unordered_map<int, Employee *> mp;

    int dfs(int id) {
        Employee *employee = mp[id];
        int total = employee->importance;
        for (int subId : employee->subordinates) {
            total += dfs(subId);
        }
        return total;
    }

    int getImportance(vector<Employee *> employees, int id) {
        for (auto &employee : employees) {
            mp[employee->id] = employee;
        }
        return dfs(id);
    }
};
```

```Python [sol1-Python3]
class Solution:
    def getImportance(self, employees: List['Employee'], idx: int) -> int:
        mp = {employee.id: employee for employee in employees}

        def dfs(idx: int) -> int:
            employee = mp[idx]
            total = employee.importance + sum(dfs(subIdx) for subIdx in employee.subordinates)
            return total
        
        return dfs(idx)
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是员工数量。需要遍历所有员工，在哈希表中存储员工编号和员工的对应关系，深度优先搜索对每个员工遍历一次。

- 空间复杂度：$O(n)$，其中 $n$ 是员工数量。空间复杂度主要取决于哈希表的空间和递归调用栈的空间，哈希表的大小为 $n$，栈的深度不超过 $n$。

#### 方法二：广度优先搜索

也可以使用广度优先搜索的做法。

和深度优先搜索一样，使用哈希表存储每个员工编号和对应的员工，即可通过员工编号得到对应的员工。根据给定的员工编号找到员工，从该员工开始广度优先搜索，对于每个遍历到的员工，将其重要性加到总和中，最终得到的总和即为给定的员工及其所有下属的重要性之和。

```Java [sol2-Java]
class Solution {
    public int getImportance(List<Employee> employees, int id) {
        Map<Integer, Employee> map = new HashMap<Integer, Employee>();
        for (Employee employee : employees) {
            map.put(employee.id, employee);
        }
        int total = 0;
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.offer(id);
        while (!queue.isEmpty()) {
            int curId = queue.poll();
            Employee employee = map.get(curId);
            total += employee.importance;
            List<Integer> subordinates = employee.subordinates;
            for (int subId : subordinates) {
                queue.offer(subId);
            }
        }
        return total;
    }
}
```

```C# [sol2-C#]
class Solution {
    public int GetImportance(IList<Employee> employees, int id) {
        Dictionary<int, Employee> dictionary = new Dictionary<int, Employee>();
        foreach (Employee employee in employees) {
            dictionary.Add(employee.id, employee);
        }
        int total = 0;
        Queue<int> queue = new Queue<int>();
        queue.Enqueue(id);
        while (queue.Count > 0) {
            int curId = queue.Dequeue();
            Employee employee = dictionary[curId];
            total += employee.importance;
            IList<int> subordinates = employee.subordinates;
            foreach (int subId in subordinates) {
                queue.Enqueue(subId);
            }
        }
        return total;
    }
}
```

```JavaScript [sol2-JavaScript]
var GetImportance = function(employees, id) {
    const map = new Map();
    for (const employee of employees) {
        map.set(employee.id, employee);
    }
    let total = 0;
    const queue = [];
    queue.push(id);
    while (queue.length) {
        const curId = queue.shift();
        const employee = map.get(curId);
        total += employee.importance;
        const subordinates = employee.subordinates;
        for (const subId of subordinates) {
            queue.push(subId);
        }
    }
    return total;
};
```

```go [sol2-Golang]
func getImportance(employees []*Employee, id int) (total int) {
    mp := map[int]*Employee{}
    for _, employee := range employees {
        mp[employee.Id] = employee
    }

    queue := []int{id}
    for len(queue) > 0 {
        employee := mp[queue[0]]
        queue = queue[1:]
        total += employee.Importance
        for _, subId := range employee.Subordinates {
            queue = append(queue, subId)
        }
    }
    return
}
```

```C++ [sol2-C++]
class Solution {
public:
    int getImportance(vector<Employee *> employees, int id) {
        unordered_map<int, Employee *> mp;
        for (auto &employee : employees) {
            mp[employee->id] = employee;
        }

        int total = 0;
        queue<int> que;
        que.push(id);
        while (!que.empty()) {
            int curId = que.front();
            que.pop();
            Employee *employee = mp[curId];
            total += employee->importance;
            for (int subId : employee->subordinates) {
                que.push(subId);
            }
        }
        return total;
    }
};
```

```Python [sol2-Python3]
class Solution:
    def getImportance(self, employees: List['Employee'], idx: int) -> int:
        mp = {employee.id: employee for employee in employees}

        total = 0
        que = collections.deque([idx])
        while que:
            curIdx = que.popleft()
            employee = mp[curIdx]
            total += employee.importance
            for subIdx in employee.subordinates:
                que.append(subIdx)
        
        return total
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是员工数量。需要遍历所有员工，在哈希表中存储员工编号和员工的对应关系，广度优先搜索对每个员工遍历一次。

- 空间复杂度：$O(n)$，其中 $n$ 是员工数量。空间复杂度主要取决于哈希表的空间和队列的空间，哈希表的大小为 $n$，队列的大小不超过 $n$。