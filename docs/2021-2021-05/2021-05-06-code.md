# 2021年05月06日 code
<a href="https://toutiao.io/k/ok4mp6n">五一假期不想人挤人？来这里！</a><br /><a href="https://toutiao.io/k/4fpatsr">[译] Linux 系统安全强化指南</a><br /><a href="https://toutiao.io/k/jpoc824">[译] Pulsar 和 Kafka 架构对比</a><br /><a href="https://toutiao.io/k/2evvnnn">学就完事了！万星项目带你做 3D 游戏：GitHub 热点速览</a><br /><a href="https://toutiao.io/k/lqr22f6">闲鱼如何 0 到 1 搭建一套发布引导链路</a><br /><a href="https://toutiao.io/k/n05y7h2">58 集团白盒代码审计系统建设实践（二）：深入理解 SAST</a><br /><a href="https://toutiao.io/k/kpxvn6n">基于 Scoped CSS 和 Sass 的换肤方案</a><br /><a href="https://toutiao.io/k/luxyokg">终于把 XGBoost 总结写出来了</a><br /><a href="https://toutiao.io/k/cosvl59">简单说下 Promise.all 和 Promise.race 区别和使用场景</a><br /><a href="https://toutiao.io/k/ulixg07">内部环境的 Wi-Fi 钓鱼实践：基于信任的安全体系一攻即破</a><br /><a href="https://toutiao.io/k/lvyzxo8">[推荐] 图解 Kafka</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/0etokja">[推荐] Kafka：这次分享我只想把原理讲清楚</a><br /><a href="https://toutiao.io/k/2aonyjp">[推荐] 把 Redis 当作队列来用，真的合适吗？</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><a href="https://toutiao.io/k/90vs9kg">[推荐] ClickHouse 在 Bilibili 用户行为分析的实践</a><br /><hr /><a href="https://github.com/pallupz/covid-vaccine-booking">This very basic script can be used to automate COVID-19 vaccination slot booking on India's Co-WIN Platform.</a><br /><a href="https://github.com/DIGITALCRIMINAL/OnlyFans">Scrape all the media from an OnlyFans account - Updated regularly</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/alura-cursos/imersaodados3"></a><br /><a href="https://github.com/github/docs">The open-source repo for docs.github.com</a><br /><a href="https://github.com/jlevy/the-art-of-command-line">Master the command line, in one page</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/thedevdojo/wave">Wave - The Software as a Service Starter Kit, designed to help you build the SAAS of your dreams 🚀 💰</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/devsuperior/sds3"></a><br /><a href="https://github.com/terraform-aws-modules/terraform-aws-eks">Terraform module to create an Elastic Kubernetes (EKS) cluster and associated worker instances on AWS</a><br /><a href="https://github.com/andrejbauer/plzoo">Programming Languages Zoo</a><br /><a href="https://github.com/Shahzod114/NodeRelax-Blender-Addon">Helps to arrange nodes</a><br /><a href="https://github.com/ionic-team/ionic-framework">A powerful cross-platform UI toolkit for building native-quality iOS, Android, and Progressive Web Apps with HTML, CSS, and JavaScript.</a><br /><a href="https://github.com/bhattbhavesh91/cowin-vaccination-slot-availability">Script to check the available slots for Covid-19 Vaccination Centers from CoWIN API in India</a><br /><a href="https://github.com/cfalta/adsec">An introduction to Active Directory security</a><br /><a href="https://github.com/login?return_to=%2FEbookFoundation%2Ffree-programming-books">📚 Freely available programming books</a><br /><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">Bootstrap Kubernetes the hard way on Google Cloud Platform. No scripts.</a><br /><a href="https://github.com/login?return_to=%2F255kb%2Fstack-on-a-budget">A collection of services with great free tiers for developers on a budget. Sponsored by Mockoon, the best mock API tool. https://mockoon.com</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/roboll/helmfile">Deploy Kubernetes Helm Charts</a><br /><a href="https://github.com/storybookjs/storybook">📓 The UI component explorer. Develop, document, & test React, Vue, Angular, Web Components, Ember, Svelte & more!</a><br /><a href="https://github.com/thanos-io/thanos">Highly available Prometheus setup with long term storage capabilities. A CNCF Incubating project.</a><br /><a href="https://github.com/audacity/audacity">Audio Editor</a><br /><hr />解码异或后的数组<br /><p><strong>未知</strong> 整数数组 <code>arr</code> 由 <code>n</code> 个非负整数组成。</p>

<p>经编码后变为长度为 <code>n - 1</code> 的另一个整数数组 <code>encoded</code> ，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到 <code>encoded = [1,2,3]</code> 。</p>

<p>给你编码后的数组 <code>encoded</code> 和原数组 <code>arr</code> 的第一个元素 <code>first</code>（<code>arr[0]</code>）。</p>

<p>请解码返回原数组 <code>arr</code> 。可以证明答案存在并且是唯一的。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>encoded = [1,2,3], first = 1
<strong>输出：</strong>[1,0,2,1]
<strong>解释：</strong>若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>encoded = [6,2,7,3], first = 4
<strong>输出：</strong>[4,2,0,7,4]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>2 <= n <= 10<sup>4</sup></code></li>
	<li><code>encoded.length == n - 1</code></li>
	<li><code>0 <= encoded[i] <= 10<sup>5</sup></code></li>
	<li><code>0 <= first <= 10<sup>5</sup></code></li>
</ul>
<br />#### 方法一：利用异或运算的性质

原数组 $\textit{arr}$ 的长度为 $n$，对 $\textit{arr}$ 编码后得到长度为 $n-1$ 的数组 $\textit{encoded}$，编码规则为：$\textit{encoded}[i]=\textit{arr}[i] \oplus \textit{arr}[i+1]$，其中 $\oplus$ 是异或运算符，$0 \le i<n-1$。

已知编码后的数组 $\textit{encoded}$ 和原数组 $\textit{arr}$ 的第一个元素 $\textit{arr}[0]=\textit{first}$，需要解码得到原数组 $\textit{arr}$。可以利用异或运算的性质实现。

异或运算具有如下性质：

- 异或运算满足交换律和结合律；

- 任意整数和自身做异或运算的结果都等于 $0$，即 $x \oplus x = 0$；

- 任意整数和 $0$ 做异或运算的结果都等于其自身，即 $x \oplus 0 = 0 \oplus x = x$。

当 $1 \le i<n$ 时，有 $\textit{encoded}[i-1]=\textit{arr}[i-1] \oplus \textit{arr}[i]$。在等号两边同时异或 $\textit{arr}[i-1]$，可以得到 $\textit{arr}[i]=\textit{arr}[i-1] \oplus \textit{encoded}[i-1]$，计算过程如下：

$$
\begin{aligned}
\textit{encoded}[i-1] &= \textit{arr}[i-1] \oplus \textit{arr}[i] \\
\textit{encoded}[i-1] \oplus \textit{arr}[i-1] &= \textit{arr}[i-1] \oplus \textit{arr}[i] \oplus \textit{arr}[i-1] \\
\textit{arr}[i-1] \oplus \textit{encoded}[i-1] &= \textit{arr}[i-1] \oplus \textit{arr}[i-1] \oplus \textit{arr}[i] \\
\textit{arr}[i-1] \oplus \textit{encoded}[i-1] &= 0 \oplus \textit{arr}[i] \\
\textit{arr}[i-1] \oplus \textit{encoded}[i-1] &= \textit{arr}[i]
\end{aligned}
$$

因此当 $1 \le i<n$ 时，有 $\textit{arr}[i]=\textit{arr}[i-1] \oplus \textit{encoded}[i-1]$。

由于 $\textit{arr}[0]=\textit{first}$ 已知，因此对 $i$ 从 $1$ 到 $n-1$ 依次计算 $\textit{arr}[i]$ 的值，即可解码得到原数组 $\textit{arr}$。

```Java [sol1-Java]
class Solution {
    public int[] decode(int[] encoded, int first) {
        int n = encoded.length + 1;
        int[] arr = new int[n];
        arr[0] = first;
        for (int i = 1; i < n; i++) {
            arr[i] = arr[i - 1] ^ encoded[i - 1];
        }
        return arr;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int[] Decode(int[] encoded, int first) {
        int n = encoded.Length + 1;
        int[] arr = new int[n];
        arr[0] = first;
        for (int i = 1; i < n; i++) {
            arr[i] = arr[i - 1] ^ encoded[i - 1];
        }
        return arr;
    }
}
```

```JavaScript [sol1-JavaScript]
var decode = function(encoded, first) {
    const n = encoded.length + 1;
    const arr = new Array(n).fill(0);
    arr[0] = first;
    for (let i = 1; i < n; i++) {
        arr[i] = arr[i - 1] ^ encoded[i - 1];
    }
    return arr;
};
```

```go [sol1-Golang]
func decode(encoded []int, first int) []int {
    ans := make([]int, len(encoded)+1)
    ans[0] = first
    for i, e := range encoded {
        ans[i+1] = ans[i] ^ e
    }
    return ans
}
```

```Python [sol1-Python3]
class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        n = len(encoded)
        arr = [first]
        for num in encoded:
            arr.append(arr[-1] ^ num)
        return arr
```

```C [sol1-C]
int* decode(int* encoded, int encodedSize, int first, int* returnSize) {
    int* arr = malloc(sizeof(int) * (encodedSize + 1));
    arr[0] = first;
    for (int i = 0; i < encodedSize; i++) {
        arr[i + 1] = encoded[i] ^ arr[i];
    }
    *returnSize = encodedSize + 1;
    return arr;
}
```

```C++ [sol1-C++]
class Solution {
public:
    vector<int> decode(vector<int>& encoded, int first) {
        int n = encoded.size() + 1;
        vector<int> arr(n);
        arr[0] = first;
        for (int i = 1; i < n; i++) {
            arr[i] = arr[i - 1] ^ encoded[i - 1];
        }
        return arr;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是原数组 $\textit{arr}$ 的长度。需要遍历长度为 $n-1$ 的编码数组 $\textit{encoded}$ 一次，计算原数组 $\textit{arr}$ 的每个元素值。

- 空间复杂度：$O(1)$。注意空间复杂度不考虑返回值。