# 2021年05月11日 code
<a href="https://toutiao.io/k/4sywkcm">微服务设计原则</a><br /><a href="https://toutiao.io/k/gc13z71">数据分析十年，我只推荐这些书</a><br /><a href="https://toutiao.io/k/utt4f5d">简单了解一下 K8S，并搭建自己的集群</a><br /><a href="https://toutiao.io/k/r1j2iq6">探索使用 Golang 和 Webassembly 构建一个多人游戏服务器</a><br /><a href="https://toutiao.io/k/moooo7c">我，管理 100 多人技术团队的二三事</a><br /><a href="https://toutiao.io/k/uea8zyc">图算法系列之深度优先搜索（一）</a><br /><a href="https://toutiao.io/k/96xpug6">如何做一场高质量的分享</a><br /><a href="https://toutiao.io/k/wesd48c">一代传奇！经典播放器 Winamp 的开源实现</a><br /><a href="https://toutiao.io/k/pfig936">75 张图带你了解网络设备、网络地址规划、静态路由、实战演练 </a><br /><a href="https://toutiao.io/k/65z25sa">阿里一面如何：spring 自定义 XML schema 扩展</a><br /><a href="https://toutiao.io/k/wpvh74i">Kustomize 简明教程</a><br /><a href="https://toutiao.io/k/z0h2jib">Java 并发容器篇</a><br /><a href="https://toutiao.io/k/vo84qme">架构设计笔记（十六）：关键模式_业务层优化</a><br /><a href="https://toutiao.io/k/ua9a8za">Java 中 RMI 的使用</a><br /><a href="https://toutiao.io/k/2e8owp3">实时计算框架：Spark 集群搭建与入门案例</a><br /><a href="https://toutiao.io/k/p1p2mh7">工程师应该如何学习</a><br /><a href="https://toutiao.io/k/96f66qj">打造一个干净且个性化的公众号阅读环境</a><br /><a href="https://toutiao.io/k/ssd4qfx">数据安全怎么做：数据跨境的思考</a><br /><a href="https://toutiao.io/k/vy7wfl3">设计模式：超越软件与设计的模式语言</a><br /><a href="https://toutiao.io/k/cmharv7">Flink 实时计算在微博的应用</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/lvyzxo8">[推荐] 图解 Kafka</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/6mzds1m">[推荐] 系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/xdsox3x">[推荐] 撸代码前，写下设计方案</a><br /><a href="https://toutiao.io/k/4fpatsr">[推荐] [译] Linux 系统安全强化指南</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/ss8h91v">[推荐] 架构师必看：架构设计的四大思维支柱</a><br /><a href="https://toutiao.io/k/nkx9rki">[推荐] 我认为最优美的数据结构</a><br /><hr /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Public Beta 🎉)</a><br /><a href="https://github.com/Renovamen/playground-macos">My portfolio website simulating macOS's GUI, developed with React and tailwindcss.</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/sundowndev/phoneinfoga">Information gathering & OSINT framework for phone numbers</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/abuanwar072/Flutter-Responsive-Admin-Panel-or-Dashboard">Responsive Admin Panel or Dashboard using Flutter</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/Light-City/CPlusPlusThings">C++那些事</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/google/zx">A tool for writing better scripts</a><br /><a href="https://github.com/login?return_to=%2Frustdesk%2Frustdesk">The best open source remote desktop client software</a><br /><a href="https://github.com/trimstray/the-book-of-secret-knowledge">A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more.</a><br /><a href="https://github.com/donnemartin/system-design-primer">Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</a><br /><a href="https://github.com/ossrs/srs">SRS is a simple, high efficiency and realtime video server, supports RTMP/WebRTC/HLS/HTTP-FLV/SRT/GB28181.</a><br /><a href="https://github.com/lucidrains/x-transformers">A simple but complete full-attention transformer with a set of promising experimental features from various papers</a><br /><a href="https://github.com/TheAlgorithms/C-Plus-Plus">Collection of various algorithms in mathematics, machine learning, computer science and physics implemented in C++ for educational purposes.</a><br /><a href="https://github.com/discordjs/discord.js">A powerful JavaScript library for interacting with the Discord API</a><br /><a href="https://github.com/home-assistant/core">🏡 Open source home automation that puts local control and privacy first</a><br /><a href="https://github.com/dromara/shenyu">High-Performance Java API Gateway</a><br /><a href="https://github.com/devsuperior/sds3"></a><br /><a href="https://github.com/alacritty/alacritty">A cross-platform, OpenGL terminal emulator.</a><br /><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">🔗 Some useful websites for programmers.</a><br /><a href="https://github.com/Olshansk/interview">Everything you need to prepare for your technical interview</a><br /><a href="https://github.com/sherlock-project/sherlock">🔎 Hunt down social media accounts by username across social networks</a><br /><hr />解码异或后的排列<br /><p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>

<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>

<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>encoded = [3,1]
<b>输出：</b>[1,2,3]
<b>解释：</b>如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>encoded = [6,5,4,6]
<b>输出：</b>[2,4,1,5,3]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>3 &lt;= n &lt; 10<sup>5</sup></code></li>
	<li><code>n</code> 是奇数。</li>
	<li><code>encoded.length == n - 1</code></li>
</ul>
<br />#### 方法一：利用异或运算解码

这道题规定了数组 $\textit{perm}$ 是前 $n$ 个正整数的排列，其中 $n$ 是**奇数**，只有充分利用给定的条件，才能得到答案。

为了得到原始数组 $\textit{perm}$，应首先得到数组 $\textit{perm}$ 的第一个元素（即下标为 $0$ 的元素），这也是最容易得到的。如果能得到数组 $\textit{perm}$ 的全部元素的异或运算结果，以及数组 $\textit{perm}$ 除了 $\textit{perm}[0]$ 以外的全部元素的异或运算结果，即可得到 $\textit{perm}[0]$ 的值。

由于数组 $\textit{perm}$ 是前 $n$ 个正整数的排列，因此数组 $\textit{perm}$ 的全部元素的异或运算结果即为从 $1$ 到 $n$ 的全部正整数的异或运算结果。用 $\textit{total}$ 表示数组 $\textit{perm}$ 的全部元素的异或运算结果，则有

$$
\begin{aligned}
\textit{total} &= 1 \oplus 2 \oplus \ldots \oplus n \\
&= \textit{perm}[0] \oplus \textit{perm}[1] \oplus \ldots \oplus \textit{perm}[n-1]
\end{aligned}
$$

其中 $\oplus$ 是异或运算符。

如何得到数组 $\textit{perm}$ 除了 $\textit{perm}[0]$ 以外的全部元素的异或运算结果？由于 $n$ 是奇数，除了 $\textit{perm}[0]$ 以外，数组 $\textit{perm}$ 还有 $n-1$ 个其他元素，$n-1$ 是偶数，又由于数组 $\textit{encoded}$ 的每个元素都是数组 $\textit{perm}$ 的两个元素异或运算的结果，因此数组 $\textit{encoded}$ 中存在 $\frac{n-1}{2}$ 个元素，这些元素的异或运算的结果为数组 $\textit{perm}$ 除了 $\textit{perm}[0]$ 以外的全部元素的异或运算结果。

具体而言，数组 $\textit{encoded}$ 的所有下标为奇数的元素的异或运算结果即为数组 $\textit{perm}$ 除了 $\textit{perm}[0]$ 以外的全部元素的异或运算结果。用 $\textit{odd}$ 表示数组 $\textit{encoded}$ 的所有下标为奇数的元素的异或运算结果，则有

$$
\begin{aligned}
\textit{odd} &= \textit{encoded}[1] \oplus \textit{encoded}[3] \oplus \ldots \oplus \textit{encoded}[n-2] \\
&= \textit{perm}[1] \oplus \textit{perm}[2] \oplus \ldots \oplus \textit{perm}[n]
\end{aligned}
$$

根据 $\textit{total}$ 和 $\textit{odd}$ 的值，即可计算得到 $\textit{perm}[0]$ 的值：

$$
\begin{aligned}
\textit{perm}[0] &= (\textit{perm}[0] \oplus \ldots \oplus \textit{perm}[n]) \oplus (\textit{perm}[1] \oplus \ldots \oplus \textit{perm}[n]) \\
&= \textit{total} \oplus \textit{odd}
\end{aligned}
$$

当 $1 \le i<n$ 时，有 $\textit{encoded}[i-1]=\textit{perm}[i-1] \oplus \textit{perm}[i]$。在等号两边同时异或 $\textit{perm}[i-1]$，即可得到 $\textit{perm}[i]=\textit{perm}[i-1] \oplus \textit{encoded}[i-1]$。计算过程见「[1720. 解码异或后的数组的官方题解](https://leetcode-cn.com/problems/decode-xored-array/solution/jie-ma-yi-huo-hou-de-shu-zu-by-leetcode-yp0mg/)」。

由于 $\textit{perm}[0]$ 已知，因此对 $i$ 从 $1$ 到 $n-1$ 依次计算 $\textit{perm}[i]$ 的值，即可得到原始数组 $\textit{perm}$。

```Java [sol1-Java]
class Solution {
    public int[] decode(int[] encoded) {
        int n = encoded.length + 1;
        int total = 0;
        for (int i = 1; i <= n; i++) {
            total ^= i;
        }
        int odd = 0;
        for (int i = 1; i < n - 1; i += 2) {
            odd ^= encoded[i];
        }
        int[] perm = new int[n];
        perm[0] = total ^ odd;
        for (int i = 0; i < n - 1; i++) {
            perm[i + 1] = perm[i] ^ encoded[i];
        }
        return perm;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int[] Decode(int[] encoded) {
        int n = encoded.Length + 1;
        int total = 0;
        for (int i = 1; i <= n; i++) {
            total ^= i;
        }
        int odd = 0;
        for (int i = 1; i < n - 1; i += 2) {
            odd ^= encoded[i];
        }
        int[] perm = new int[n];
        perm[0] = total ^ odd;
        for (int i = 0; i < n - 1; i++) {
            perm[i + 1] = perm[i] ^ encoded[i];
        }
        return perm;
    }
}
```

```JavaScript [sol1-JavaScript]
var decode = function(encoded) {
    const n = encoded.length + 1;
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total ^= i;
    }
    let odd = 0;
    for (let i = 1; i < n - 1; i += 2) {
        odd ^= encoded[i];
    }
    const perm = new Array(n).fill(0);
    perm[0] = total ^ odd;
    for (let i = 0; i < n - 1; i++) {
        perm[i + 1] = perm[i] ^ encoded[i];
    }
    return perm;
};
```

```go [sol1-Golang]
func decode(encoded []int) []int {
    n := len(encoded)
    total := 0
    for i := 1; i <= n+1; i++ {
        total ^= i
    }
    odd := 0
    for i := 1; i < n; i += 2 {
        odd ^= encoded[i]
    }
    perm := make([]int, n+1)
    perm[0] = total ^ odd
    for i, v := range encoded {
        perm[i+1] = perm[i] ^ v
    }
    return perm
}
```

```C++ [sol1-C++]
class Solution {
public:
    vector<int> decode(vector<int>& encoded) {
        int n = encoded.size() + 1;
        int total = 0;
        for (int i = 1; i <= n; i++) {
            total ^= i;
        }
        int odd = 0;
        for (int i = 1; i < n - 1; i += 2) {
            odd ^= encoded[i];
        }
        vector<int> perm(n);
        perm[0] = total ^ odd;
        for (int i = 0; i < n - 1; i++) {
            perm[i + 1] = perm[i] ^ encoded[i];
        }
        return perm;
    }
};
```

```C [sol1-C]
int* decode(int* encoded, int encodedSize, int* returnSize) {
    int n = encodedSize + 1;
    int total = 0;
    for (int i = 1; i <= n; i++) {
        total ^= i;
    }
    int odd = 0;
    for (int i = 1; i < n - 1; i += 2) {
        odd ^= encoded[i];
    }
    int* perm = malloc(sizeof(int) * n);
    *returnSize = n;
    perm[0] = total ^ odd;
    for (int i = 0; i < n - 1; i++) {
        perm[i + 1] = perm[i] ^ encoded[i];
    }
    return perm;
}
```

```Python [sol1-Python3]
class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        n = len(encoded) + 1
        total = reduce(xor, range(1, n + 1))
        odd = 0
        for i in range(1, n - 1, 2):
            odd ^= encoded[i]
        
        perm = [total ^ odd]
        for i in range(n - 1):
            perm.append(perm[-1] ^ encoded[i])
        
        return perm
```

**复杂度分析**

- 时间复杂度：$O(n)$，其中 $n$ 是原始数组 $\textit{perm}$ 的长度。计算 $\textit{total}$ 和 $\textit{odd}$ 各需要遍历长度为 $n-1$ 的数组 $\textit{encoded}$ 一次，计算原数组 $\textit{perm}$ 的每个元素值也需要遍历长度为 $n-1$ 的数组 $\textit{encoded}$ 一次。

- 空间复杂度：$O(1)$。注意空间复杂度不考虑返回值。