# 2021年05月20日 code
<a href="https://toutiao.io/k/l9yirih">JVM 进阶之路（十二）：字节码指令</a><br /><a href="https://toutiao.io/k/3o1c6vb">Java 反编译工具的使用与对比分析</a><br /><a href="https://toutiao.io/k/pwz9rfd">Go sync.Pool 浅析</a><br /><a href="https://toutiao.io/k/r3kppel">WebRTC 的前世今生</a><br /><a href="https://toutiao.io/k/6xcz0t9">如何快速实现一个聊天室？</a><br /><a href="https://toutiao.io/k/3auey0k">实践解析 | 如何通过 WebAssembly 在 Web 进行实时视频人像分割</a><br /><a href="https://toutiao.io/k/ys4z01r">Kubebuilder 进阶：源码分析</a><br /><a href="https://toutiao.io/k/gf1ivgw">算法转 Java 后端，2021 秋招斩获腾讯、京东、百度等大厂 Offer 面经分享</a><br /><a href="https://toutiao.io/k/o7pvjm6">六面字节终于拿下，双非菜鸡的暑期实习</a><br /><a href="https://toutiao.io/k/sq70sbp">Arthas 3.5.1 发布：神级特性！内存搜索对象</a><br /><a href="https://toutiao.io/k/gq64qdn">Django 3.0 + Redis 3.4 + Celery 4.4 应用开发（附源码）</a><br /><a href="https://toutiao.io/k/z474gay">FoundationDB：Apple 开源的分布式 KV 存储</a><br /><a href="https://toutiao.io/k/ukuaetz">深入探究 6 个 React 诡异现象</a><br /><a href="https://toutiao.io/k/oweu0c5">早期阶段的 ToB SaaS 如何做 “数据收集”</a><br /><a href="https://toutiao.io/k/qadxlhp">Go 语言中 new 和 make 你使用哪个来分配内存？</a><br /><a href="https://toutiao.io/k/xfj8e0e">动图演示：彻底理解红黑树？</a><br /><a href="https://toutiao.io/k/cc99d68">消息队列产生严重消息堆积怎么处理？</a><br /><a href="https://toutiao.io/k/5i83v42">打造后台登录页面扫描工具</a><br /><a href="https://toutiao.io/k/ioljlm8">Presto 入门及查询优化方法总结</a><br /><a href="https://toutiao.io/k/ff93fhy">你真的懂点击率 (CTR) 建模吗？</a><br /><a href="https://toutiao.io/k/jt9e5bq">[推荐] 动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a><br /><a href="https://toutiao.io/k/ca8fe6d">[推荐] 吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</a><br /><a href="https://toutiao.io/k/moooo7c">[推荐] 我，管理 100 多人技术团队的二三事</a><br /><a href="https://toutiao.io/k/nkx9rki">[推荐] 我认为最优美的数据结构</a><br /><a href="https://toutiao.io/k/wa52n1g">[推荐] 高并发，我把握不住啊</a><br /><a href="https://toutiao.io/k/ss8h91v">[推荐] 架构师必看：架构设计的四大思维支柱</a><br /><a href="https://toutiao.io/k/2tnj5np">[推荐] RabbitMQ、Kafka、RocketMQ 是如何实现高可用的？</a><br /><a href="https://toutiao.io/k/bjis3t4">[推荐] 36 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/9yex08q">[推荐] 我把这个软件，推荐给了总监</a><br /><a href="https://toutiao.io/k/w8wyj2e">[推荐] 消息队列把消息弄丢了怎么办？</a><br /><a href="https://toutiao.io/k/k1o0w99">[推荐] 哈啰在分布式消息治理和微服务治理中的实践</a><br /><a href="https://toutiao.io/k/gc13z71">[推荐] 数据分析十年，我只推荐这些书</a><br /><a href="https://toutiao.io/k/gs6z30z">[推荐] 轻轻松松打印网页并生成 pdf 文档</a><br /><a href="https://toutiao.io/k/4sywkcm">[推荐] 微服务设计原则</a><br /><a href="https://toutiao.io/k/3byclqk">[推荐] 这个 GitHub 项目能克隆你的声音</a><br /><hr /><a href="https://github.com/login?return_to=%2Filuwatar%2Fjava-design-patterns">Design patterns implemented in Java</a><br /><a href="https://github.com/covid19india/covid19india-react">Tracking the impact of COVID-19 in India</a><br /><a href="https://github.com/google/googletest">GoogleTest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/login?return_to=%2FGitSquared%2Fedex-ui">A cross-platform, customizable science fiction terminal emulator with advanced monitoring & touchscreen support.</a><br /><a href="https://github.com/0vercl0k/CVE-2021-31166">Proof of concept for CVE-2021-31166, a remote HTTP.sys use-after-free triggered remotely.</a><br /><a href="https://github.com/ErickWendel/semana-javascript-expert04">Todas as aulas da Semana JS Expert 4.0 - ClubHouse Clone</a><br /><a href="https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh">程序员应该访问的最佳网站中文版</a><br /><a href="https://github.com/jakevdp/PythonDataScienceHandbook">Python Data Science Handbook: full text in Jupyter Notebooks</a><br /><a href="https://github.com/paritytech/substrate">Substrate: The platform for blockchain innovators</a><br /><a href="https://github.com/sqlfluff/sqlfluff">A SQL linter and auto-formatter for Humans</a><br /><a href="https://github.com/TheAlgorithms/Python">All Algorithms implemented in Python</a><br /><a href="https://github.com/Chia-Network/pool-reference"></a><br /><a href="https://github.com/vercel/next.js">The React Framework</a><br /><a href="https://github.com/morpheusthewhite/spicetify-themes">A community-driven collection of themes for customizing Spotify through Spicetify (https://github.com/khanhas/spicetify-cli)</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/quarkusio/quarkus">Quarkus: Supersonic Subatomic Java.</a><br /><a href="https://github.com/onnx/onnx">Open standard for machine learning interoperability</a><br /><a href="https://github.com/ClickHouse/ClickHouse">ClickHouse® is a free analytics DBMS for big data</a><br /><a href="https://github.com/login?return_to=%2Fmrdoob%2Fthree.js">JavaScript 3D Library.</a><br /><a href="https://github.com/fairlearn/fairlearn">A Python package to assess and improve fairness of machine learning models.</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">🗂 The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/apache/spark">Apache Spark - A unified analytics engine for large-scale data processing</a><br /><a href="https://github.com/IBM/Project_CodeNet">This repository is to support contributions for tools for the Project CodeNet dataset hosted in DAX</a><br /><a href="https://github.com/fastlane/fastlane">🚀 The easiest way to automate building and releasing your iOS and Android apps</a><br /><a href="https://github.com/torvalds/linux">Linux kernel source tree</a><br /><hr />前K个高频单词<br /><p>给一非空的单词列表，返回前&nbsp;<em>k&nbsp;</em>个出现次数最多的单词。</p>

<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入:</strong> [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2
<strong>输出:</strong> [&quot;i&quot;, &quot;love&quot;]
<strong>解析:</strong> &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。
    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。
</pre>

<p>&nbsp;</p>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入:</strong> [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4
<strong>输出:</strong> [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]
<strong>解析:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，
    出现次数依次为 4, 3, 2 和 1 次。
</pre>

<p>&nbsp;</p>

<p><strong>注意：</strong></p>

<ol>
	<li>假定 <em>k</em> 总为有效值， 1 &le; <em>k</em> &le; 集合元素数。</li>
	<li>输入的单词均由小写字母组成。</li>
</ol>

<p>&nbsp;</p>

<p><strong>扩展练习：</strong></p>

<ol>
	<li>尝试以&nbsp;<em>O</em>(<em>n</em> log <em>k</em>) 时间复杂度和&nbsp;<em>O</em>(<em>n</em>) 空间复杂度解决。</li>
</ol>
<br />#### 方法一：哈希表 + 排序

**思路及算法**

我们可以预处理出每一个单词出现的频率，然后依据每个单词出现的频率降序排序，最后返回前 $k$ 个字符串即可。

具体地，我们利用哈希表记录每一个字符串出现的频率，然后将哈希表中所有字符串进行排序，排序时，如果两个字符串出现频率相同，那么我们让两字符串中字典序较小的排在前面，否则我们让出现频率较高的排在前面。最后我们只需要保留序列中的前 $k$ 个字符串即可。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> cnt;
        for (auto& word : words) {
            ++cnt[word];
        }
        vector<string> rec;
        for (auto& [key, value] : cnt) {
            rec.emplace_back(key);
        }
        sort(rec.begin(), rec.end(), [&](const string& a, const string& b) -> bool {
            return cnt[a] == cnt[b] ? a < b : cnt[a] > cnt[b];
        });
        rec.erase(rec.begin() + k, rec.end());
        return rec;
    }
};
```

```Java [sol1-Java]
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> cnt = new HashMap<String, Integer>();
        for (String word : words) {
            cnt.put(word, cnt.getOrDefault(word, 0) + 1);
        }
        List<String> rec = new ArrayList<String>();
        for (Map.Entry<String, Integer> entry : cnt.entrySet()) {
            rec.add(entry.getKey());
        }
        Collections.sort(rec, new Comparator<String>() {
            public int compare(String word1, String word2) {
                return cnt.get(word1) == cnt.get(word2) ? word1.compareTo(word2) : cnt.get(word2) - cnt.get(word1);
            }
        });
        return rec.subList(0, k);
    }
}
```

```C# [sol1-C#]
public class Solution {
    public IList<string> TopKFrequent(string[] words, int k) {
        Dictionary<string, int> cnt = new Dictionary<string, int>();
        foreach (string word in words) {
            if (cnt.ContainsKey(word)) {
                cnt[word]++;
            } else {
                cnt.Add(word, 1);
            }
        }
        List<string> rec = new List<string>();
        foreach (var item in cnt) {
            rec.Add(item.Key);
        }
        rec.Sort(
            delegate(string word1, string word2) {
                return cnt[word1] == cnt[word2] ? word1.CompareTo(word2) : cnt[word2] - cnt[word1];
            }
        );
        return rec.GetRange(0, k);
    }
}
```

```go [sol1-Golang]
func topKFrequent(words []string, k int) []string {
    cnt := map[string]int{}
    for _, w := range words {
        cnt[w]++
    }
    uniqueWords := make([]string, 0, len(cnt))
    for w := range cnt {
        uniqueWords = append(uniqueWords, w)
    }
    sort.Slice(uniqueWords, func(i, j int) bool {
        s, t := uniqueWords[i], uniqueWords[j]
        return cnt[s] > cnt[t] || cnt[s] == cnt[t] && s < t
    })
    return uniqueWords[:k]
}
```

```JavaScript [sol1-JavaScript]
var topKFrequent = function(words, k) {
    const cnt = new Map();
    for (const word of words) {
        cnt.set(word, (cnt.get(word) || 0) + 1);
    }
    const rec = [];
    for (const entry of cnt.keys()) {
        rec.push(entry);
    }
    rec.sort((word1, word2) => {
        return cnt.get(word1) === cnt.get(word2) ? word1.localeCompare(word2) : cnt.get(word2) - cnt.get(word1);
    })
    return rec.slice(0, k);
};
```

```C [sol1-C]
struct HashTable {
    char* key;
    int val;
    UT_hash_handle hh;
};

struct HashTable* cnt;

int queryVal(struct HashTable* hashTable, char* ikey) {
    struct HashTable* tmp;
    HASH_FIND_STR(hashTable, ikey, tmp);
    return tmp == NULL ? 0 : tmp->val;
}

int cmp(char** a, char** b) {
    int valA = queryVal(cnt, *a), valB = queryVal(cnt, *b);
    if (valA != valB) {
        return valB - valA;
    }
    int lenA = strlen(*a), lenB = strlen(*b);
    int len = fmin(lenA, lenB);
    for (int i = 0; i < len; i++) {
        if ((*a)[i] != (*b)[i]) {
            return (*a)[i] - (*b)[i];
        }
    }
    return lenA - lenB;
}

char** topKFrequent(char** words, int wordsSize, int k, int* returnSize) {
    cnt = NULL;
    for (int i = 0; i < wordsSize; i++) {
        struct HashTable* tmp;
        HASH_FIND_STR(cnt, words[i], tmp);
        if (tmp == NULL) {
            struct HashTable* tmp = malloc(sizeof(struct HashTable));
            tmp->key = words[i];
            tmp->val = 1;
            HASH_ADD_KEYPTR(hh, cnt, tmp->key, strlen(tmp->key), tmp);
        } else {
            tmp->val++;
        }
    }
    char** ret = malloc(sizeof(char*) * HASH_COUNT(cnt));
    *returnSize = 0;

    struct HashTable *iter, *tmp;
    HASH_ITER(hh, cnt, iter, tmp) {
        ret[(*returnSize)++] = iter->key;
    }

    qsort(ret, *returnSize, sizeof(char*), cmp);
    *returnSize = k;
    return ret;
}
```

**复杂度分析**

- 时间复杂度：$O(l \times n + l \times m \log m)$，其中 $n$ 表示给定字符串序列的长度，$l$ 表示字符串的平均长度，$m$ 表示实际字符串种类数。我们需要 $l \times n$ 的时间将字符串插入到哈希表中，以及 $l \times m \log m$ 的时间完成字符串比较（最坏情况下所有字符串出现频率都相同，我们需要将它们两两比较）。

- 空间复杂度：$O(l \times m)$，其中 $l$ 表示字符串的平均长度，$m$ 表示实际字符串种类数。哈希表和生成的排序数组空间占用均为 $O(l \times m)$。

#### 方法二：优先队列

**思路及算法**

对于前 $k$ 大或前 $k$ 小这类问题，有一个通用的解法：优先队列。优先队列可以在 $O(\log n)$ 的时间内完成插入或删除元素的操作（其中 $n$ 为优先队列的大小），并可以 $O(1)$ 地查询优先队列顶端元素。

在本题中，我们可以创建一个小根优先队列（顾名思义，就是优先队列顶端元素是最小元素的优先队列）。我们将每一个字符串插入到优先队列中，如果优先队列的大小超过了 $k$，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 $k$ 个元素就是前 $k$ 个出现次数最多的单词。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> cnt;
        for (auto& word : words) {
            cnt[word]++;
        }
        auto cmp = [](const pair<string, int>& a, const pair<string, int>& b) {
            return a.second == b.second ? a.first < b.first : a.second > b.second;
        };
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> que(cmp);
        for (auto& it : cnt) {
            que.emplace(it);
            if (que.size() > k) {
                que.pop();
            }
        }
        vector<string> ret(k);
        for (int i = k - 1; i >= 0; i--) {
            ret[i] = que.top().first;
            que.pop();
        }
        return ret;
    }
};
```

```Java [sol2-Java]
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> cnt = new HashMap<String, Integer>();
        for (String word : words) {
            cnt.put(word, cnt.getOrDefault(word, 0) + 1);
        }
        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<Map.Entry<String, Integer>>(new Comparator<Map.Entry<String, Integer>>() {
            public int compare(Map.Entry<String, Integer> entry1, Map.Entry<String, Integer> entry2) {
                return entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();
            }
        });
        for (Map.Entry<String, Integer> entry : cnt.entrySet()) {
            pq.offer(entry);
            if (pq.size() > k) {
                pq.poll();
            }
        }
        List<String> ret = new ArrayList<String>();
        while (!pq.isEmpty()) {
            ret.add(pq.poll().getKey());
        }
        Collections.reverse(ret);
        return ret;
    }
}
```

```go [sol2-Golang]
type pair struct {
    w string
    c int
}
type hp []pair
func (h hp) Len() int            { return len(h) }
func (h hp) Less(i, j int) bool  { a, b := h[i], h[j]; return a.c < b.c || a.c == b.c && a.w > b.w }
func (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v interface{}) { *h = append(*h, v.(pair)) }
func (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }

func topKFrequent(words []string, k int) []string {
    cnt := map[string]int{}
    for _, w := range words {
        cnt[w]++
    }
    h := &hp{}
    for w, c := range cnt {
        heap.Push(h, pair{w, c})
        if h.Len() > k {
            heap.Pop(h)
        }
    }
    ans := make([]string, k)
    for i := k - 1; i >= 0; i-- {
        ans[i] = heap.Pop(h).(pair).w
    }
    return ans
}
```

**复杂度分析**

- 时间复杂度：$O(l \times n + m \times l \log k)$，其中 $n$ 表示给定字符串序列的长度，$m$ 表示实际字符串种类数，$l$ 表示字符串的平均长度。我们需要 $l \times n$ 的时间将字符串插入到哈希表中，以及每次插入元素到优先队列中都需要 $l \log k$ 的时间，共需要插入 $m$ 次。

- 空间复杂度：$O(l \times (m + k))$，其中 $l$ 表示字符串的平均长度，$m$ 表示实际字符串种类数。哈希表空间占用为 $O(l \times m)$，优先队列空间占用为 $O(l \times k)$。

---
## ✨扣友帮帮团 - 互动答疑

[![讨论.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)


即日起 - 5 月 30 日，点击 [这里](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/) 前往「[扣友帮帮团](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)」活动页，把你遇到的问题大胆地提出来，让扣友为你解答～

### 🎁 奖励规则
被采纳数量排名 1～3 名：「力扣极客套装」 *1 并将获得「力扣神秘应援团」内测资格
被采纳数量排名 4～10 名：「力扣鼠标垫」 *1 并将获得「力扣神秘应援团」内测资格
「诲人不倦」：活动期间「解惑者」只要有 1 个回答被采纳，即可获得 20 LeetCoins 奖励！
「求知若渴」：活动期间「求知者」在活动页发起一次符合要求的疑问帖并至少采纳一次「解惑者」的回答，即可获得 20 LeetCoins 奖励！

活动详情猛戳链接了解更多：[活动｜你有 BUG 我来帮 - 力扣互动答疑季](https://leetcode-cn.com/circle/discuss/xtliW6/)