# 2021年05月08日 code
<a href="https://toutiao.io/k/7v2gnx6">程序员必备基础：10 种常见安全漏洞浅析</a><br /><a href="https://toutiao.io/k/fsnuhkp">技术之外的工程师另类成长指南</a><br /><a href="https://toutiao.io/k/07qzmoj">Kafka 不再需要 ZooKeeper</a><br /><a href="https://toutiao.io/k/efrdgy5">ThreadLocal 使用与原理</a><br /><a href="https://toutiao.io/k/funesvi">Raft 的 Figure 8 讲了什么问题？为什么需要 no-op 日志？</a><br /><a href="https://toutiao.io/k/wbuol5s">Spring Boot 集成 groovy 脚本</a><br /><a href="https://toutiao.io/k/zgtkl3z">职场感悟：我的参考系在哪？</a><br /><a href="https://toutiao.io/k/1ekyryi">一文读懂 MySQL 查询语句的执行过程</a><br /><a href="https://toutiao.io/k/3xmfopc">Curl 使用指南</a><br /><a href="https://toutiao.io/k/67zyftw">聊一聊可信执行环境</a><br /><a href="https://toutiao.io/k/go0rojp">GraphQL 及元数据驱动架构在后端 BFF 中的实践</a><br /><a href="https://toutiao.io/k/2u2tp7g">再谈 synchronized 锁升级</a><br /><a href="https://toutiao.io/k/rluv4r3">C/C++ 构建系统，我用 xmake</a><br /><a href="https://toutiao.io/k/kg5vie0">使用 Kotlin 提高生产力</a><br /><a href="https://toutiao.io/k/u231mw2">工具 | 一个非常实用的 NLP 索引工具</a><br /><a href="https://toutiao.io/k/g5lxvm0">酷炫！Python 函数耗时异常自动化监控</a><br /><a href="https://toutiao.io/k/2i4xfjb">[译] 神经网络不收敛怎么办？看看是不是这些原因</a><br /><a href="https://toutiao.io/k/iukeyvj">React-Hooks 面试解答</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/6mzds1m">[推荐] 系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/xdsox3x">[推荐] 撸代码前，写下设计方案</a><br /><a href="https://toutiao.io/k/lvyzxo8">[推荐] 图解 Kafka</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/0etokja">[推荐] Kafka：这次分享我只想把原理讲清楚</a><br /><hr /><a href="https://github.com/pallupz/covid-vaccine-booking">This very basic script can be used to automate COVID-19 vaccination slot booking on India's Co-WIN Platform.</a><br /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Public Beta 🎉)</a><br /><a href="https://github.com/Uniswap/uniswap-v3-core">🦄 🦄 🦄 Core smart contracts of Uniswap v3</a><br /><a href="https://github.com/pixie-labs/pixie">Instant Kubernetes-Native Application Observability</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/axios/axios">Promise based HTTP client for the browser and node.js</a><br /><a href="https://github.com/andymatuschak/orbit"></a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/abuanwar072/Flutter-Responsive-Admin-Panel-or-Dashboard">Responsive Admin Panel or Dashboard using Flutter</a><br /><a href="https://github.com/jlevy/the-art-of-command-line">Master the command line, in one page</a><br /><a href="https://github.com/public-apis/public-apis">A collective list of free APIs</a><br /><a href="https://github.com/jwasham/coding-interview-university">A complete computer science study plan to become a software engineer.</a><br /><a href="https://github.com/kcp-dev/kcp">kcp is a prototype of a Kubernetes API server that is not a Kubernetes cluster - a place to create, update, and maintain Kube-like APis with controllers above or without clusters.</a><br /><a href="https://github.com/LeCoupa/awesome-cheatsheets">👩‍💻👨‍💻 Awesome cheatsheets for popular programming languages, frameworks and development tools. They include everything you should know in one single file.</a><br /><a href="https://github.com/trimstray/the-book-of-secret-knowledge">A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more.</a><br /><a href="https://github.com/seemoo-lab/openhaystack">Build your own 'AirTags' 🏷 today! Framework for tracking personal Bluetooth devices via Apple's massive Find My network.</a><br /><a href="https://github.com/vinta/awesome-python">A curated list of awesome Python frameworks, libraries, software and resources</a><br /><a href="https://github.com/Azure/counterfit">a CLI that provides a generic automation layer for assessing the security of ML models</a><br /><a href="https://github.com/imarvinle/awesome-cs-books">经典编程书籍大全，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试等</a><br /><a href="https://github.com/audacity/audacity">Audio Editor</a><br /><a href="https://github.com/Uniswap/uniswap-v3-periphery">🦄 🦄 🦄 Peripheral smart contracts for interacting with Uniswap v3</a><br /><a href="https://github.com/itdevbooks/pdf">编程电子书，电子书，编程书籍，包括C，C#，Docker，Elasticsearch，Git，Hadoop，HeadFirst，Java，Javascript，jvm，Kafka，Linux，Maven，MongoDB，MyBatis，MySQL，Netty，Nginx，Python，RabbitMQ，Redis，Scala，Solr，Spark，Spring，SpringBoot，SpringCloud，TCPIP，Tomcat，Zookeeper，人工智能，大数据类，并发编程，数据库类，数据挖掘，新面试题，架构设计，算法系列，计算机类，设计模式，软件测试，重构优化，等更多分类</a><br /><a href="https://github.com/login?return_to=%2Ftokio-rs%2Fconsole">tokio-console prototypes</a><br /><a href="https://github.com/alibaba/DataX"></a><br /><a href="https://github.com/storybookjs/storybook">📓 The UI component explorer. Develop, document, & test React, Vue, Angular, Web Components, Ember, Svelte & more!</a><br /><hr />完成所有工作的最短时间<br /><p>给你一个整数数组 <code>jobs</code> ，其中 <code>jobs[i]</code> 是完成第 <code>i</code> 项工作要花费的时间。</p>

<p>请你将这些工作分配给 <code>k</code> 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 <strong>工作时间</strong> 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 <strong>最大工作时间</strong> 得以 <strong>最小化</strong> 。</p>

<p>返回分配方案中尽可能 <strong>最小</strong> 的 <strong>最大工作时间</strong> 。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>jobs = [3,2,3], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>给每位工人分配一项工作，最大工作时间是 3 。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>jobs = [1,2,4,7,8], k = 2
<strong>输出：</strong>11
<strong>解释：</strong>按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= k <= jobs.length <= 12</code></li>
	<li><code>1 <= jobs[i] <= 10<sup>7</sup></code></li>
</ul>
<br />#### 方法一：二分查找 + 回溯 + 剪枝

**思路及算法**

在本题中，我们很难直接计算出完成所有工作的最短时间。而注意到，当完成所有工作的最短时间已经确定为 $\textit{limit}$ 时，如果存在可行的方案，那么对于任意长于 $\textit{limit}$ 的最短时间，都一定也存在可行的方案。因此我们可以考虑使用二分查找的方法寻找最小的存在可行方案的 $\textit{limit}$ 值。

当完成所有工作的最短时间已经确定为 $\textit{limit}$ 时，我们可以利用回溯的方式来寻找方案。

一个朴素的方案是，开辟一个大小为 $k$ 的数组 $\textit{workloads}$，$\textit{workloads}[i]$ 表示第 $i$ 个工人的当前已经被分配的工作量，然后我们利用一个递归函数 $\text{backtrack}(i)$ 递归地枚举第 $i$ 个任务的分配方案，过程中实时地更新 $\textit{workloads}$ 数组。具体地，函数中我们检查每一个工人 $j$ 当前已经被分配的工作量，如果被分配的工作量 $\textit{workloads}[j]$ 与当前工作的工作量 $\textit{jobs}[i]$ 之和不超过 $\textit{limit}$ 的限制，我们即可以将该工作分配给工人 $j$，然后计算下一个工作 $jobs[i+1]$ 的分配方案。过程中一旦我们找到了一个可行方案，我们即可以返回 $\text{true}$，而无需枚举完所有的方案。

朴素的方案中，$\text{backtrack}$ 函数的效率可能十分低下，有可能需要枚举完所有的分配方案才能得到答案，因此我们提出几个优化措施：

1. 缩小二分查找的上下限，下限为所有工作中的最大工作量，上限为所有工作的工作量之和。
   - 每一个工作都必须被分配，因此必然有一个工人承接了工作量最大的工作；
   - 在最坏情况下，只有一个工人，他必须承接所有工作。
2. 优先分配工作量大的工作。
   - 感性地理解，如果要求将小石子和大石块放入玻璃瓶中，优先放入大石块更容易使得工作变得简单。
   - 在搜索过程中，优先分配工作量小的工作会使得工作量大的工作更有可能最后无法被分配。
3. 当工人 $i$ 还没被分配工作时，我们不给工人 $i+1$ 分配工作。
   - 如果当前工人 $i$ 和 $i+1$ 都没有被分配工作，那么我们将工作先分配给任何一个人都没有区别，如果分配给工人 $i$ 不能成功完成分配任务，那么分配给工人 $i+1$ 也一样无法完成。
4. 当我们将工作 $i$ 分配给工人 $j$，使得工人 $j$ 的工作量恰好达到 $\textit{limit}$，且计算分配下一个工作的递归函数返回了 $\text{false}$，此时即无需尝试将工作 $i$ 分配给其他工人，直接返回 $\text{false}$ 即可。
   - 常规逻辑下，递归函数返回了 $\text{false}$，那么我们需要尝试将工作 $i$ 分配给其他工人，假设分配给了工人 $j'$，那么此时工人 $j'$ 的工作量必定不多于工人 $j$ 的工作量；
   - 如果存在一个方案使得分配给工人 $j'$ 能够成功完成分配任务，那么此时必然有一个或一组工作 $i'$ 取代了工作 $i$ 被分配给工人 $j$，否则我们可以直接将工作 $i$ 移交给工人 $j$，仍然能成功完成分配任务。而我们知道工作 $i'$ 的总工作量不会超过工作 $i$，因此我们可以直接交换工作 $i$ 与工作 $i'$，仍然能成功完成分配任务。这与假设不符，可知不存在这样一个满足条件的工人 $j'$。

**代码**

```C++ [sol1-C++]
class Solution {
public:
    bool backtrack(vector<int>& jobs, vector<int>& workloads, int idx, int limit) {
        if (idx >= jobs.size()) {
            return true;
        }
        int cur = jobs[idx];
        for (auto& workload : workloads) {
            if (workload + cur <= limit) {
                workload += cur;
                if (backtrack(jobs, workloads, idx + 1, limit)) {
                    return true;
                }
                workload -= cur;
            }
            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
            // 或者当前工作恰能使该工人的工作量达到了上限
            // 这两种情况下我们无需尝试继续分配工作
            if (workload == 0 || workload + cur == limit) {
                break;
            }
        }
        return false;
    }

    bool check(vector<int>& jobs, int k, int limit) {
        vector<int> workloads(k, 0);
        return backtrack(jobs, workloads, 0, limit);
    }

    int minimumTimeRequired(vector<int>& jobs, int k) {
        sort(jobs.begin(), jobs.end(), greater<int>());
        int l = jobs[0], r = accumulate(jobs.begin(), jobs.end(), 0);
        while (l < r) {
            int mid = (l + r) >> 1;
            if (check(jobs, k, mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int minimumTimeRequired(int[] jobs, int k) {
        Arrays.sort(jobs);
        int low = 0, high = jobs.length - 1;
        while (low < high) {
            int temp = jobs[low];
            jobs[low] = jobs[high];
            jobs[high] = temp;
            low++;
            high--;
        }
        int l = jobs[0], r = Arrays.stream(jobs).sum();
        while (l < r) {
            int mid = (l + r) >> 1;
            if (check(jobs, k, mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    public boolean check(int[] jobs, int k, int limit) {
        int[] workloads = new int[k];
        return backtrack(jobs, workloads, 0, limit);
    }

    public boolean backtrack(int[] jobs, int[] workloads, int i, int limit) {
        if (i >= jobs.length) {
            return true;
        }
        int cur = jobs[i];
        for (int j = 0; j < workloads.length; ++j) {
            if (workloads[j] + cur <= limit) {
                workloads[j] += cur;
                if (backtrack(jobs, workloads, i + 1, limit)) {
                    return true;
                }
                workloads[j] -= cur;
            }
            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
            // 或者当前工作恰能使该工人的工作量达到了上限
            // 这两种情况下我们无需尝试继续分配工作
            if (workloads[j] == 0 || workloads[j] + cur == limit) {
                break;
            }
        }
        return false;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int MinimumTimeRequired(int[] jobs, int k) {
        Array.Sort(jobs);
        Array.Reverse(jobs);
        int l = jobs[0], r = jobs.Sum();
        while (l < r) {
            int mid = (l + r) >> 1;
            if (Check(jobs, k, mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    public bool Check(int[] jobs, int k, int limit) {
        int[] workloads = new int[k];
        return Backtrack(jobs, workloads, 0, limit);
    }

    public bool Backtrack(int[] jobs, int[] workloads, int i, int limit) {
        if (i >= jobs.Length) {
            return true;
        }
        int cur = jobs[i];
        for (int j = 0; j < workloads.Length; ++j) {
            if (workloads[j] + cur <= limit) {
                workloads[j] += cur;
                if (Backtrack(jobs, workloads, i + 1, limit)) {
                    return true;
                }
                workloads[j] -= cur;
            }
            // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
            // 或者当前工作恰能使该工人的工作量达到了上限
            // 这两种情况下我们无需尝试继续分配工作
            if (workloads[j] == 0 || workloads[j] + cur == limit) {
                break;
            }
        }
        return false;
    }
}
```

```JavaScript [sol1-JavaScript]
var minimumTimeRequired = function(jobs, k) {
    jobs.sort((a, b) => a - b);
    let low = 0, high = jobs.length - 1;
    while (low < high) {
        const temp = jobs[low];
        jobs[low] = jobs[high];
        jobs[high] = temp;
        low++;
        high--;
    }
    let l = jobs[0], r = jobs.reduce(function(prev, curr, idx, jobs){ return prev + curr });
    while (l < r) {
        const mid = Math.floor((l + r) >> 1);
        if (check(jobs, k, mid)) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
};

const check = (jobs, k, limit) => {
    const workloads = new Array(k).fill(0);
    return backtrack(jobs, workloads, 0, limit);
}

const backtrack = (jobs, workloads, i, limit) => {
    if (i >= jobs.length) {
        return true;
    }
    let cur = jobs[i];
    for (let j = 0; j < workloads.length; ++j) {
        if (workloads[j] + cur <= limit) {
            workloads[j] += cur;
            if (backtrack(jobs, workloads, i + 1, limit)) {
                return true;
            }
            workloads[j] -= cur;
        }
        // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
        // 或者当前工作恰能使该工人的工作量达到了上限
        // 这两种情况下我们无需尝试继续分配工作
        if (workloads[j] === 0 || workloads[j] + cur === limit) {
            break;
        }
    }
    return false;
}
```

```go [sol1-Golang]
func minimumTimeRequired(jobs []int, k int) int {
    n := len(jobs)
    sort.Sort(sort.Reverse(sort.IntSlice(jobs)))
    l, r := jobs[0], 0
    for _, v := range jobs {
        r += v
    }
    return l + sort.Search(r-l, func(limit int) bool {
        limit += l
        workloads := make([]int, k)
        var backtrack func(int) bool
        backtrack = func(idx int) bool {
            if idx == n {
                return true
            }
            cur := jobs[idx]
            for i := range workloads {
                if workloads[i]+cur <= limit {
                    workloads[i] += cur
                    if backtrack(idx + 1) {
                        return true
                    }
                    workloads[i] -= cur
                }
                // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
                // 或者当前工作恰能使该工人的工作量达到了上限
                // 这两种情况下我们无需尝试继续分配工作
                if workloads[i] == 0 || workloads[i]+cur == limit {
                    break
                }
            }
            return false
        }
        return backtrack(0)
    })
}
```

```C [sol1-C]
bool backtrack(int* jobs, int jobsSize, int* workloads, int workloadsSize, int idx, int limit) {
    if (idx >= jobsSize) {
        return true;
    }
    int cur = jobs[idx];
    for (int i = 0; i < workloadsSize; i++) {
        if (workloads[i] + cur <= limit) {
            workloads[i] += cur;
            if (backtrack(jobs, jobsSize, workloads, workloadsSize, idx + 1, limit)) {
                return true;
            }
            workloads[i] -= cur;
        }
        // 如果当前工人未被分配工作，那么下一个工人也必然未被分配工作
        // 或者当前工作恰能使该工人的工作量达到了上限
        // 这两种情况下我们无需尝试继续分配工作
        if (workloads[i] == 0 || workloads[i] + cur == limit) {
            break;
        }
    }
    return false;
}

bool check(int* jobs, int jobsSize, int k, int limit) {
    int workloads[k];
    memset(workloads, 0, sizeof(workloads));
    return backtrack(jobs, jobsSize, workloads, k, 0, limit);
}

int cmp(int* a, int* b) {
    return *b - *a;
}

int accumulate(int* arr, int* arrSize) {
    int ret = 0;
    for (int i = 0; i < arrSize; i++) {
        ret += arr[i];
    }
    return ret;
}

int minimumTimeRequired(int* jobs, int jobsSize, int k) {
    qsort(jobs, jobsSize, sizeof(int), cmp);
    int l = jobs[0], r = accumulate(jobs, jobsSize);
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(jobs, jobsSize, k, mid)) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
```

**复杂度分析**

- 时间复杂度：$O(n \log n + \log (S-M) \times n!)$，其中 $n$ 是数组 $\textit{jobs}$ 的长度，$S$ 是数组 $\textit{jobs}$ 的元素之和，$M$ 是数组 $\textit{jobs}$ 中元素的最大值。最坏情况下每次二分需要遍历所有分配方案的排列，但经过一系列优化后，实际上可以规避掉绝大部分不必要的计算。

- 空间复杂度：$O(n)$。空间复杂度主要取决于递归的栈空间的消耗，而递归至多有 $n$ 层。


#### 方法二：动态规划 + 状态压缩

**思路及算法**

按照朴素的思路，我们按顺序给每一个工人安排工作，注意到当我们给第 $i$ 个工人分配工作的时候，能够选择的分配方案仅和前 $i-1$ 个人被分配的工作有关。因此我们考虑使用动态规划解决本题，只需要记录已经被分配了工作的工人数量，以及已经被分配的工作是哪些即可。

因为工作数量较少，我们可以使用状态压缩的方式来表示已经被分配的工作是哪些。具体地，假设有 $n$ 个工作需要被分配，我们就使用一个 $n$ 位的二进制整数来表示哪些工作已经被分配，哪些工作尚未被分配，如果该二进制整数的第 $i$ 位为 $1$，那么第 $i$ 个工作已经被分配，否则第 $i$ 个工作尚未被分配。如有 $3$ 个工作需要被分配，那么 $5=(101)_2$ 即代表 第 $0$ 和第 $2$ 个工作已经被分配，第 $1$ 个工作还未被分配。

这样我们可以写出状态方程：$f[i][j]$ 表示给前 $i$ 个人分配工作，工作的分配情况为 $j$ 时，完成所有工作的最短时间。注意这里的 $j$ 是一个二进制整数，表示了工作的分配情况。实际上我们也可以将 $j$ 看作一个集合，包含了已经被分配的工作。

那么我们可以写出状态转移方程：

$$
f[i][j] = \min_{j'\in j}\{ \max(f[i-1][\complement_{j}j'], \textit{sum}[j'])\}
$$

式中 $\textit{sum}[j']$ 表示集合 $j'$ 中的工作的总工作量，$\complement_{j}j'$ 表示集合 $j$ 中子集 $j'$ 的补集。状态转移方程的含义为，我们枚举 $j$ 的每一个子集 $j'$，让其作为分配给工人 $i$ 的工作，这样我们需要给前 $i-1$ 个人分配 $\complement_{j}j'$ 的工作。

在实际代码中，我们首先预处理出 $\textit{sum}$ 数组，然后初始化 $f[0][j]=sum[j]$，最终答案即为 $f[k-1][2^n-1]$（表示给全部 $k$ 个工人分配全部 $n$ 个工作，完成所有工作的最短时间）。

**代码**

```C++ [sol2-C++]
class Solution {
public:
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int n = jobs.size();
        vector<int> sum(1 << n);
        for (int i = 1; i < (1 << n); i++) {
            int x = __builtin_ctz(i), y = i - (1 << x);
            sum[i] = sum[y] + jobs[x];
        }

        vector<vector<int>> dp(k, vector<int>(1 << n));
        for (int i = 0; i < (1 << n); i++) {
            dp[0][i] = sum[i];
        }

        for (int i = 1; i < k; i++) {
            for (int j = 0; j < (1 << n); j++) {
                int minn = INT_MAX;
                for (int x = j; x; x = (x - 1) & j) {
                    minn = min(minn, max(dp[i - 1][j - x], sum[x]));
                }
                dp[i][j] = minn;
            }
        }
        return dp[k - 1][(1 << n) - 1];
    }
};
```

```Java [sol2-Java]
class Solution {
    public int minimumTimeRequired(int[] jobs, int k) {
        int n = jobs.length;
        int[] sum = new int[1 << n];
        for (int i = 1; i < (1 << n); i++) {
            int x = Integer.numberOfTrailingZeros(i), y = i - (1 << x);
            sum[i] = sum[y] + jobs[x];
        }

        int[][] dp = new int[k][1 << n];
        for (int i = 0; i < (1 << n); i++) {
            dp[0][i] = sum[i];
        }

        for (int i = 1; i < k; i++) {
            for (int j = 0; j < (1 << n); j++) {
                int minn = Integer.MAX_VALUE;
                for (int x = j; x != 0; x = (x - 1) & j) {
                    minn = Math.min(minn, Math.max(dp[i - 1][j - x], sum[x]));
                }
                dp[i][j] = minn;
            }
        }
        return dp[k - 1][(1 << n) - 1];
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int MinimumTimeRequired(int[] jobs, int k) {
        int n = jobs.Length;
        int[] sum = new int[1 << n];
        for (uint i = 1; i < (1 << n); i++) {
            int x = NumberOfTrailingZeros(i), y = (int)i - (int)(1 << x);
            sum[i] = sum[y] + jobs[x];
        }

        int[,] dp = new int[k, 1 << n];
        for (int i = 0; i < (1 << n); i++) {
            dp[0, i] = sum[i];
        }

        for (int i = 1; i < k; i++) {
            for (int j = 0; j < (1 << n); j++) {
                int minn = int.MaxValue;
                for (int x = j; x != 0; x = (x - 1) & j) {
                    minn = Math.Min(minn, Math.Max(dp[i - 1, j - x], sum[x]));
                }
                dp[i, j] = minn;
            }
        }
        return dp[k - 1, (1 << n) - 1];
    }

    private static int NumberOfTrailingZeros(uint i) {
        uint y;
        if (i == 0) return 32;
        int n = 31;
        y = i <<16; if (y != 0) { n = n -16; i = y; }
        y = i << 8; if (y != 0) { n = n - 8; i = y; }
        y = i << 4; if (y != 0) { n = n - 4; i = y; }
        y = i << 2; if (y != 0) { n = n - 2; i = y; }
        return (int)n - (int)((i << 1) >> 31);
    }
}
```

```JavaScript [sol2-JavaScript]
var minimumTimeRequired = function(jobs, k) {
    const n = jobs.length;
    const sum = new Array(1 << n).fill(0);
    for (let i = 1; i < (1 << n); i++) {
        const x = NumberOfTrailingZeros(i), y = i - (1 << x);
        sum[i] = sum[y] + jobs[x];
    }

    const dp = new Array(k).fill(0).map(() => new Array(1 << n).fill(0));
    for (let i = 0; i < (1 << n); i++) {
        dp[0][i] = sum[i];
    }

    for (let i = 1; i < k; i++) {
        for (let j = 0; j < (1 << n); j++) {
            let minn = Number.MAX_VALUE;
            for (let x = j; x != 0; x = (x - 1) & j) {
                minn = Math.min(minn, Math.max(dp[i - 1][j - x], sum[x]));
            }
            dp[i][j] = minn;
        }
    }
    return dp[k - 1][(1 << n) - 1];
};

const NumberOfTrailingZeros = (number) => {
    const num = parseInt(number).toString(2);
    const multiply_De_Bruijn_position = [
        0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
        31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9];
    return multiply_De_Bruijn_position[(((num & (-num)) * 0x077CB531) >> 27) & 31]
}
```

```go [sol2-Golang]
func minimumTimeRequired(jobs []int, k int) int {
    n := len(jobs)
    m := 1 << n
    sum := make([]int, m)
    for i := 1; i < m; i++ {
        x := bits.TrailingZeros(uint(i))
        y := i ^ 1<<x
        sum[i] = sum[y] + jobs[x]
    }

    dp := make([][]int, k)
    for i := range dp {
        dp[i] = make([]int, m)
    }
    for i, s := range sum {
        dp[0][i] = s
    }

    for i := 1; i < k; i++ {
        for j := 0; j < (1 << n); j++ {
            minn := math.MaxInt64
            for x := j; x > 0; x = (x - 1) & j {
                minn = min(minn, max(dp[i-1][j-x], sum[x]))
            }
            dp[i][j] = minn
        }
    }
    return dp[k-1][(1<<n)-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```C [sol2-C]
int minimumTimeRequired(int* jobs, int jobsSize, int k) {
    int n = jobsSize;
    int sum[1 << n];
    sum[0] = 0;
    for (int i = 1; i < (1 << n); i++) {
        int x = __builtin_ctz(i), y = i - (1 << x);
        sum[i] = sum[y] + jobs[x];
    }
    int dp[k][1 << n];
    for (int i = 0; i < (1 << n); i++) {
        dp[0][i] = sum[i];
    }

    for (int i = 1; i < k; i++) {
        for (int j = 0; j < (1 << n); j++) {
            int minn = INT_MAX;
            for (int x = j; x; x = (x - 1) & j) {
                minn = fmin(minn, fmax(dp[i - 1][j - x], sum[x]));
            }
            dp[i][j] = minn;
        }
    }
    return dp[k - 1][(1 << n) - 1];
}
```

**复杂度分析**

- 时间复杂度：$O(n\times 3^n)$，其中 $n$ 是数组 $\textit{jobs}$ 的长度。我们需要 $O(2^n)$ 的时间预处理 $\textit{sum}$ 数组。动态规划中共有 $O(n \times 2^n)$ 种状态，将每个状态看作集合，大小为 $k$ 的集合有 $n \times C_n^k$ 个，其转移个数为 $2^k$，根据二项式定理有 
  
  $$
  
  \sum_{k=0}^nC_n^k2^k=\sum_{k=0}^nC_n^k2^k1^{n-k}=(2+1)^n=3^n
  
  $$ 
  
  因此动态规划的时间复杂度为 $O(n \times 3^n)$，故总时间复杂度为 $O(n\times 3^n)$。

- 空间复杂度：$O(n\times 2^{n})$。我们需要保存动态规划的每一个状态。