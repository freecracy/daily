# 2021年05月13日 code
<a href="https://toutiao.io/k/bjis3t4">36 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/dzgh03u">解码无代码/低代码创业圈子及其玩家</a><br /><a href="https://toutiao.io/k/zv6r0sz">如果你也会手抖输错命令，那就必须给你推荐这个 Fuck 工具</a><br /><a href="https://toutiao.io/k/9jssaxp">Kubebuilder 实战：CRUD</a><br /><a href="https://toutiao.io/k/4t5ie44">3 个主流 Java 微服务框架</a><br /><a href="https://toutiao.io/k/s4wvw9c">从工业化到智能化，未来的 AB 实验是什么样子</a><br /><a href="https://toutiao.io/k/mkz0x54">Java 筑基：JNI 到底是个啥</a><br /><a href="https://toutiao.io/k/8j8d5kk">白话科普：网站图片不显示，背后的原因你都清楚吗</a><br /><a href="https://toutiao.io/k/n3ba3h0">面试题：如何实现丝滑般的数据库扩容</a><br /><a href="https://toutiao.io/k/khmbz6a">有的便宜不能占</a><br /><a href="https://toutiao.io/k/0qx8h1s">关于 Java 单线程经常占用 CPU 100% 的分析</a><br /><a href="https://toutiao.io/k/p5nrsbj">跟我一起学 Go 系列：gRPC 入门必备</a><br /><a href="https://toutiao.io/k/lg7cu53">面对千万级、亿级流量怎么处理？</a><br /><a href="https://toutiao.io/k/5fucqps">Birdseye：极其强大的 Python 调试工具</a><br /><a href="https://toutiao.io/k/pidu1sj">Python 知识巩固：通过主进程带起多个子进程实现多进程执行逻辑</a><br /><a href="https://toutiao.io/k/40ef4ad">微服务的灾难</a><br /><a href="https://toutiao.io/k/9llygzd">Spark 推荐实战系列之 ALS 算法实现分析</a><br /><a href="https://toutiao.io/k/mvihi6m">AAAI 2021：关键词指导的神经对话模型</a><br /><a href="https://toutiao.io/k/mktshpy">出现了，PPT 制作新方式：GitHub 热点速览</a><br /><a href="https://toutiao.io/k/cx9vamj">NodeJS 如何实现控制台打印高亮代码</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/4fpatsr">[推荐] [译] Linux 系统安全强化指南</a><br /><a href="https://toutiao.io/k/xdsox3x">[推荐] 撸代码前，写下设计方案</a><br /><a href="https://toutiao.io/k/1nwsx5k">[推荐] 万级并发：电商库存扣减如何设计？不超卖</a><br /><a href="https://toutiao.io/k/7v2gnx6">[推荐] 程序员必备基础：10 种常见安全漏洞浅析</a><br /><a href="https://toutiao.io/k/nkx9rki">[推荐] 我认为最优美的数据结构</a><br /><a href="https://toutiao.io/k/6mzds1m">[推荐] 系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/ss8h91v">[推荐] 架构师必看：架构设计的四大思维支柱</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><hr /><a href="https://github.com/Renovamen/playground-macos">My portfolio website simulating macOS's GUI, developed with React and tailwindcss.</a><br /><a href="https://github.com/YunYouJun/air-conditioner">❄️ 云空调，便携小空调，为你的夏日带去清凉！</a><br /><a href="https://github.com/CyberPunkMetalHead/Binance-volatility-trading-bot">This is a fully functioning Binance trading bot that measures the volatility of every coin on Binance and places trades with the highest gaining coins If you like this project consider donating though the Brave browser to allow me to continuously improve the script.</a><br /><a href="https://github.com/dfinity/ic">Source project for the Internet Computer software</a><br /><a href="https://github.com/ossrs/srs">SRS is a simple, high efficiency and realtime video server, supports RTMP/WebRTC/HLS/HTTP-FLV/SRT/GB28181.</a><br /><a href="https://github.com/CyC2018/CS-Notes">📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</a><br /><a href="https://github.com/tevador/RandomX">Proof of work algorithm based on random code execution</a><br /><a href="https://github.com/gto76/python-cheatsheet">Comprehensive Python Cheatsheet</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/google/zx">A tool for writing better scripts</a><br /><a href="https://github.com/microsoft/Web-Dev-For-Beginners">24 Lessons, 12 Weeks, Get Started as a Web Developer</a><br /><a href="https://github.com/30-seconds/30-seconds-of-code">Short JavaScript code snippets for all your development needs</a><br /><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">🔗 Some useful websites for programmers.</a><br /><a href="https://github.com/PaddlePaddle/PaddleDetection">Object detection and instance segmentation toolkit based on PaddlePaddle.</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/slidevjs/slidev">Presentation Slides for Developers (Public Beta 🎉)</a><br /><a href="https://github.com/CovidTrackerFr/vitemadose">Détection de créneaux de vaccination disponibles pour l'outil ViteMaDose</a><br /><a href="https://github.com/login?return_to=%2Frustdesk%2Frustdesk">The best open source remote desktop client software</a><br /><a href="https://github.com/home-assistant/core">🏡 Open source home automation that puts local control and privacy first</a><br /><a href="https://github.com/login?return_to=%2Fqarmin%2Fczkawka">Multi functional app to find duplicates, empty folders, similar images etc.</a><br /><a href="https://github.com/trustwallet/assets">A comprehensive, up-to-date collection of information about several thousands (!) of crypto tokens.</a><br /><a href="https://github.com/Light-City/CPlusPlusThings">C++那些事</a><br /><a href="https://github.com/wisz2021/jd_docker">借用的github账号，仅用查看环境变量文档与教程，反馈issue使用</a><br /><a href="https://github.com/TheAlgorithms/C-Plus-Plus">Collection of various algorithms in mathematics, machine learning, computer science and physics implemented in C++ for educational purposes.</a><br /><a href="https://github.com/zhangdaiscott/JimuReport">一款免费的数据可视化工具，报表与大屏设计！类似于excel操作风格，在线拖拽完成报表设计！功能涵盖: 报表设计、图形报表、打印设计、大屏设计等，永久免费！</a><br /><hr />停在原地的方案数<br /><p>有一个长度为&nbsp;<code>arrLen</code>&nbsp;的数组，开始有一个指针在索引&nbsp;<code>0</code> 处。</p>

<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>

<p>给你两个整数&nbsp;<code>steps</code> 和&nbsp;<code>arrLen</code> ，请你计算并返回：在恰好执行&nbsp;<code>steps</code>&nbsp;次操作以后，指针仍然指向索引&nbsp;<code>0</code> 处的方案数。</p>

<p>由于答案可能会很大，请返回方案数 <strong>模</strong>&nbsp;<code>10^9 + 7</code> 后的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>steps = 3, arrLen = 2
<strong>输出：</strong>4
<strong>解释：</strong>3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
</pre>

<p><strong>示例&nbsp; 2：</strong></p>

<pre><strong>输入：</strong>steps = 2, arrLen = 4
<strong>输出：</strong>2
<strong>解释：</strong>2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>steps = 4, arrLen = 2
<strong>输出：</strong>8
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= steps &lt;= 500</code></li>
	<li><code>1 &lt;= arrLen&nbsp;&lt;= 10^6</code></li>
</ul>
<br />#### 方法一：动态规划

对于计算方案数的题目，常用的方法是动态规划。对于这道题，需要计算在 $\textit{steps}$ 步操作之后，指针位于下标 $0$ 的方案数。

用 $\textit{dp}[i][j]$ 表示在 $i$ 步操作之后，指针位于下标 $j$ 的方案数。其中，$i$ 的取值范围是 $0 \le i \le \textit{steps}$，$j$ 的取值范围是 $0 \le j \le \textit{arrLen}-1$。

由于一共执行 $\textit{steps}$ 步操作，因此指针所在下标一定不会超过 $\textit{steps}$，可以将 $j$ 的取值范围进一步缩小到 $0 \le j \le \min(\textit{arrLen}-1, \textit{steps})$。

当没有进行任何操作时，指针一定位于下标 $0$，因此动态规划的边界条件是 $\textit{dp}[0][0]=1$，当 $1 \le j \le \min(\textit{arrLen}-1, \textit{steps})$ 时有 $\textit{dp}[0][j]=0$。

每一步操作中，指针可以向左或向右移动 $1$ 步，或者停在原地。因此，当 $1 \le i \le \textit{steps}$ 时，状态 $\textit{dp}[i][j]$ 可以从 $\textit{dp}[i-1][j-1]$、$\textit{dp}[i-1][j]$ 和 $\textit{dp}[i-1][j+1]$ 这三个状态转移得到。状态转移方程如下：

$$
\textit{dp}[i][j] = \textit{dp}[i-1][j-1]+\textit{dp}[i-1][j]+\textit{dp}[i-1][j+1]
$$

由于指针不能移动到数组范围外，因此对于上述状态转移方程，需要注意下标边界情况。当 $j=0$ 时，$\textit{dp}[i-1][j-1]=0$；当 $j=\min(\textit{arrLen}-1, \textit{steps})$ 时，$\textit{dp}[i-1][j+1]=0$。具体实现时，需要对下标进行判断，避免下标越界。

计算过程中需要对每个状态的值计算模 $10^9+7$ 后的结果。最终得到 $\textit{dp}[\textit{steps}][0]$ 的值即为答案。

```Java [sol11-Java]
class Solution {
    public int numWays(int steps, int arrLen) {
        final int MODULO = 1000000007;
        int maxColumn = Math.min(arrLen - 1, steps);
        int[][] dp = new int[steps + 1][maxColumn + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= steps; i++) {
            for (int j = 0; j <= maxColumn; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - 1 >= 0) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MODULO;
                }
            }
        }
        return dp[steps][0];
    }
}
```

```C# [sol11-C#]
public class Solution {
    public int NumWays(int steps, int arrLen) {
        const int MODULO = 1000000007;
        int maxColumn = Math.Min(arrLen - 1, steps);
        int[,] dp = new int[steps + 1, maxColumn + 1];
        dp[0, 0] = 1;
        for (int i = 1; i <= steps; i++) {
            for (int j = 0; j <= maxColumn; j++) {
                dp[i, j] = dp[i - 1, j];
                if (j - 1 >= 0) {
                    dp[i, j] = (dp[i, j] + dp[i - 1, j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dp[i, j] = (dp[i, j] + dp[i - 1, j + 1]) % MODULO;
                }
            }
        }
        return dp[steps, 0];
    }
}
```

```go [sol11-Golang]
func numWays(steps, arrLen int) int {
    const mod = 1e9 + 7
    maxColumn := min(arrLen-1, steps)
    dp := make([][]int, steps+1)
    for i := range dp {
        dp[i] = make([]int, maxColumn+1)
    }
    dp[0][0] = 1
    for i := 1; i <= steps; i++ {
        for j := 0; j <= maxColumn; j++ {
            dp[i][j] = dp[i-1][j]
            if j-1 >= 0 {
                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % mod
            }
            if j+1 <= maxColumn {
                dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % mod
            }
        }
    }
    return dp[steps][0]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```C++ [sol11-C++]
class Solution {
public:
    const int MODULO = 1000000007;

    int numWays(int steps, int arrLen) {
        int maxColumn = min(arrLen - 1, steps);
        vector<vector<int>> dp(steps + 1, vector<int>(maxColumn + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= steps; i++) {
            for (int j = 0; j <= maxColumn; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - 1 >= 0) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MODULO;
                }
            }
        }
        return dp[steps][0];
    }
};
```

```C [sol11-C]
const int MODULO = 1000000007;

int numWays(int steps, int arrLen) {
    int maxColumn = fmin(arrLen - 1, steps);
    int dp[steps + 1][maxColumn + 1];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    for (int i = 1; i <= steps; i++) {
        for (int j = 0; j <= maxColumn; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j - 1 >= 0) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MODULO;
            }
            if (j + 1 <= maxColumn) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MODULO;
            }
        }
    }
    return dp[steps][0];
}
```

```Python [sol11-Python3]
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        mod = 10**9 + 7
        maxColumn = min(arrLen - 1, steps)

        dp = [[0] * (maxColumn + 1) for _ in range(steps + 1)]
        dp[0][0] = 1

        for i in range(1, steps + 1):
            for j in range(0, maxColumn + 1):
                dp[i][j] = dp[i - 1][j]
                if j - 1 >= 0:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod
                if j + 1 <= maxColumn:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod
        
        return dp[steps][0]
```

```JavaScript [sol11-JavaScript]
var numWays = function(steps, arrLen) {
    const MODULO = 1000000007;
    let maxColumn = Math.min(arrLen - 1, steps);
    const dp = new Array(steps + 1).fill(0).map(() => new Array(maxColumn + 1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= steps; i++) {
        for (let j = 0; j <= maxColumn; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j - 1 >= 0) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MODULO;
            }
            if (j + 1 <= maxColumn) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MODULO;
            }
        }
    }
    return dp[steps][0];
};
```

上述实现的时间复杂度是 $O(\textit{steps} \times \min(\textit{arrLen}, \textit{steps}))$，空间复杂度是 $O(\textit{steps} \times \min(\textit{arrLen}, \textit{steps}))$。

注意到 $\textit{dp}$ 的每一行只和上一行有关，因此可以将空间复杂度降低到 $O(\min(\textit{arrLen}, \textit{steps}))$。

```Java [sol12-Java]
class Solution {
    public int numWays(int steps, int arrLen) {
        final int MODULO = 1000000007;
        int maxColumn = Math.min(arrLen - 1, steps);
        int[] dp = new int[maxColumn + 1];
        dp[0] = 1;
        for (int i = 1; i <= steps; i++) {
            int[] dpNext = new int[maxColumn + 1];
            for (int j = 0; j <= maxColumn; j++) {
                dpNext[j] = dp[j];
                if (j - 1 >= 0) {
                    dpNext[j] = (dpNext[j] + dp[j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dpNext[j] = (dpNext[j] + dp[j + 1]) % MODULO;
                }
            }
            dp = dpNext;
        }
        return dp[0];
    }
}
```

```C# [sol12-C#]
public class Solution {
    public int NumWays(int steps, int arrLen) {
        const int MODULO = 1000000007;
        int maxColumn = Math.Min(arrLen - 1, steps);
        int[] dp = new int[maxColumn + 1];
        dp[0] = 1;
        for (int i = 1; i <= steps; i++) {
            int[] dpNext = new int[maxColumn + 1];
            for (int j = 0; j <= maxColumn; j++) {
                dpNext[j] = dp[j];
                if (j - 1 >= 0) {
                    dpNext[j] = (dpNext[j] + dp[j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dpNext[j] = (dpNext[j] + dp[j + 1]) % MODULO;
                }
            }
            dp = dpNext;
        }
        return dp[0];
    }
}
```

```go [sol12-Golang]
func numWays(steps, arrLen int) int {
    const mod = 1e9 + 7
    maxColumn := min(arrLen-1, steps)
    dp := make([]int, maxColumn+1)
    dp[0] = 1
    for i := 1; i <= steps; i++ {
        dpNext := make([]int, maxColumn+1)
        for j := 0; j <= maxColumn; j++ {
            dpNext[j] = dp[j]
            if j-1 >= 0 {
                dpNext[j] = (dpNext[j] + dp[j-1]) % mod
            }
            if j+1 <= maxColumn {
                dpNext[j] = (dpNext[j] + dp[j+1]) % mod
            }
        }
        dp = dpNext
    }
    return dp[0]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```C++ [sol12-C++]
class Solution {
public:
    const int MODULO = 1000000007;

    int numWays(int steps, int arrLen) {
        int maxColumn = min(arrLen - 1, steps);
        vector<int> dp(maxColumn + 1);
        dp[0] = 1;
        for (int i = 1; i <= steps; i++) {
            vector<int> dpNext(maxColumn + 1);
            for (int j = 0; j <= maxColumn; j++) {
                dpNext[j] = dp[j];
                if (j - 1 >= 0) {
                    dpNext[j] = (dpNext[j] + dp[j - 1]) % MODULO;
                }
                if (j + 1 <= maxColumn) {
                    dpNext[j] = (dpNext[j] + dp[j + 1]) % MODULO;
                }
            }
            dp = dpNext;
        }
        return dp[0];
    }
};
```

```C [sol12-C]
const int MODULO = 1000000007;

int numWays(int steps, int arrLen) {
    int maxColumn = fmin(arrLen - 1, steps);
    int dp[maxColumn + 1];
    memset(dp, 0, sizeof(dp));
    dp[0] = 1;
    for (int i = 1; i <= steps; i++) {
        int dpNext[maxColumn + 1];
        for (int j = 0; j <= maxColumn; j++) {
            dpNext[j] = dp[j];
            if (j - 1 >= 0) {
                dpNext[j] = (dpNext[j] + dp[j - 1]) % MODULO;
            }
            if (j + 1 <= maxColumn) {
                dpNext[j] = (dpNext[j] + dp[j + 1]) % MODULO;
            }
        }
        memcpy(dp, dpNext, sizeof(dp));
    }
    return dp[0];
}
```

```Python [sol12-Python3]
class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        mod = 10**9 + 7
        maxColumn = min(arrLen - 1, steps)

        dp = [0] * (maxColumn + 1)
        dp[0] = 1

        for i in range(1, steps + 1):
            dpNext = [0] * (maxColumn + 1)
            for j in range(0, maxColumn + 1):
                dpNext[j] = dp[j]
                if j - 1 >= 0:
                    dpNext[j] = (dpNext[j] + dp[j - 1]) % mod
                if j + 1 <= maxColumn:
                    dpNext[j] = (dpNext[j] + dp[j + 1]) % mod
            dp = dpNext
        
        return dp[0]
```

```JavaScript [sol12-JavaScript]
var numWays = function(steps, arrLen) {
    const MODULO = 1000000007;
    let maxColumn = Math.min(arrLen - 1, steps);
    let dp = new Array(maxColumn + 1).fill(0);
    dp[0] = 1;
    for (let i = 1; i <= steps; i++) {
        const dpNext = new Array(maxColumn + 1).fill(0);
        for (let j = 0; j <= maxColumn; j++) {
            dpNext[j] = dp[j];
            if (j - 1 >= 0) {
                dpNext[j] = (dpNext[j] + dp[j - 1]) % MODULO;
            }
            if (j + 1 <= maxColumn) {
                dpNext[j] = (dpNext[j] + dp[j + 1]) % MODULO;
            }
        }
        dp = dpNext;
    }
    return dp[0];
};
```

**复杂度分析**

- 时间复杂度：$O(\textit{steps} \times \min(\textit{arrLen}, \textit{steps}))$。动态规划需要计算每个状态的值。

- 空间复杂度：$O(\min(\textit{arrLen}, \textit{steps}))$。使用空间优化的做法，可以将空间复杂度降低到 $O(\min(\textit{arrLen}, \textit{steps}))$。