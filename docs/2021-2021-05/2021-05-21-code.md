# 2021年05月21日 code
<a href="https://toutiao.io/k/ep5e8sd">亿级系统的 Redis 缓存如何设计？</a><br /><a href="https://toutiao.io/k/0xgnpbf">Java 容器：基于源码分析 List 集合体系</a><br /><a href="https://toutiao.io/k/8fcktmr">App 安全合规</a><br /><a href="https://toutiao.io/k/osge9c2">这款远程桌面软件开源了</a><br /><a href="https://toutiao.io/k/5ode4ev">图算法系列之深度优先搜索（二）</a><br /><a href="https://toutiao.io/k/6vy3amw">深度解密 Go 语言之基于信号的抢占式调度</a><br /><a href="https://toutiao.io/k/92jmc1s">Linux 内核 vs Windows 内核</a><br /><a href="https://toutiao.io/k/w4firqt">云计算的背后到底是什么？</a><br /><a href="https://toutiao.io/k/9l6q8vn">数据分析引擎黑马 ClickHouse 最新技术的实践与应用</a><br /><a href="https://toutiao.io/k/7l0c9n2">Karmada：工商银行多 k8s 集群管理及容灾实践</a><br /><a href="https://toutiao.io/k/xkm9s48">漫画｜程序员：大师，面对 bug 我总是冷静不了，应该怎么办？</a><br /><a href="https://toutiao.io/k/5ybjmgl">JavaScript 的基本类型和引用类型</a><br /><a href="https://toutiao.io/k/4lpp3ik">Python 自动扫描出微信不是好友名单</a><br /><a href="https://toutiao.io/k/8to855z">初探 Golang 代码混淆</a><br /><a href="https://toutiao.io/k/sb4ru62">现代 C++：简洁的 as_cast 函数模板</a><br /><a href="https://toutiao.io/k/f5jeg82">这些前沿 BIP 开发知识，你还不知道吗</a><br /><a href="https://toutiao.io/k/0nlu21e">一文彻底搞懂 DvaJS 原理</a><br /><a href="https://toutiao.io/k/tbed5tx">Flutter Fish Redux 架构演进 2.0</a><br /><a href="https://toutiao.io/k/1qmg2o3">前端小姐姐和你聊聊 IOC 中依赖注入那些事 (Dependency inject)</a><br /><a href="https://toutiao.io/k/yfcmr5y">绘制类图的一般步骤和方法</a><br /><a href="https://toutiao.io/k/moooo7c">[推荐] 我，管理 100 多人技术团队的二三事</a><br /><a href="https://toutiao.io/k/7v2gnx6">[推荐] 程序员必备基础：10 种常见安全漏洞浅析</a><br /><a href="https://toutiao.io/k/3byclqk">[推荐] 这个 GitHub 项目能克隆你的声音</a><br /><a href="https://toutiao.io/k/k1o0w99">[推荐] 哈啰在分布式消息治理和微服务治理中的实践</a><br /><a href="https://toutiao.io/k/gs6z30z">[推荐] 轻轻松松打印网页并生成 pdf 文档</a><br /><a href="https://toutiao.io/k/0hjw87u">[推荐] 日订单量达到 100 万单后，我们做了订单中心重构</a><br /><a href="https://toutiao.io/k/2tnj5np">[推荐] RabbitMQ、Kafka、RocketMQ 是如何实现高可用的？</a><br /><a href="https://toutiao.io/k/bjis3t4">[推荐] 36 张图详解网络基础知识</a><br /><a href="https://toutiao.io/k/jt9e5bq">[推荐] 动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a><br /><a href="https://toutiao.io/k/ca8fe6d">[推荐] 吊炸天的 Docker 图形化工具 Portainer，必须推荐给你</a><br /><a href="https://toutiao.io/k/4sywkcm">[推荐] 微服务设计原则</a><br /><a href="https://toutiao.io/k/9yex08q">[推荐] 我把这个软件，推荐给了总监</a><br /><a href="https://toutiao.io/k/wa52n1g">[推荐] 高并发，我把握不住啊</a><br /><a href="https://toutiao.io/k/w8wyj2e">[推荐] 消息队列把消息弄丢了怎么办？</a><br /><a href="https://toutiao.io/k/gc13z71">[推荐] 数据分析十年，我只推荐这些书</a><br /><hr /><a href="https://github.com/rbignon/doctoshotgun">Script to automatically book a vaccine slot on Doctolib for today or tomorrow, following rules from the French Government.</a><br /><a href="https://github.com/google/googletest">GoogleTest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/onnx/onnx">Open standard for machine learning interoperability</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/covid19india/covid19india-react">Tracking the impact of COVID-19 in India</a><br /><a href="https://github.com/login?return_to=%2FGitSquared%2Fedex-ui">A cross-platform, customizable science fiction terminal emulator with advanced monitoring & touchscreen support.</a><br /><a href="https://github.com/981011512/--">停车场系统源码，停车场小程序，智能停车，Parking system，【功能介绍】：①兼容市面上主流的多家相机，理论上兼容所有硬件，可灵活扩展，②相机识别后数据自动上传到云端并记录，校验相机唯一id和硬件序列号，防止非法数据录入，③用户手机查询停车记录详情可自主缴费(支持微信，支付宝，银行接口支付，支持每个停车场指定不同的商户进行收款)，支付后出场在免费时间内会自动抬杆。④支持app上查询附近停车场(导航，可用车位数，停车场费用，优惠券，评分，评论等)，可预约车位。⑤断电断网支持岗亭人员使用app可接管硬件进行停车记录的录入。 【技术架构】：后端开发语言java，框架oauth2+springboot2+dubble，数据库mysql/mongodb/redis，即时通讯底层框架net…</a><br /><a href="https://github.com/carykh/PrisonersDilemmaTournament">Watch This Place's awesome video about iterated Prisoner's Dilemma for context! https://www.youtube.com/watch?v=BOvAbjfJ0x0</a><br /><a href="https://github.com/ashishpatel26/500-AI-Machine-learning-Deep-learning-Computer-vision-NLP-Projects-with-code">500 AI Machine learning Deep learning Computer vision NLP Projects with code</a><br /><a href="https://github.com/iptv-org/iptv">Collection of publicly available IPTV channels from all over the world</a><br /><a href="https://github.com/benawad/dogehouse">Taking voice conversations to the moon 🚀</a><br /><a href="https://github.com/mehdihadeli/awesome-software-architecture">A curated list of awesome articles and resources to learn and practice about software architecture, patterns, and principles.</a><br /><a href="https://github.com/google/iosched">The Google I/O Android App</a><br /><a href="https://github.com/ErickWendel/semana-javascript-expert04">Todas as aulas da Semana JS Expert 4.0 - ClubHouse Clone</a><br /><a href="https://github.com/microsoft/TypeScript">TypeScript is a superset of JavaScript that compiles to clean JavaScript output.</a><br /><a href="https://github.com/facebookresearch/pytorchvideo">A deep learning library for video understanding research.</a><br /><a href="https://github.com/apache/spark">Apache Spark - A unified analytics engine for large-scale data processing</a><br /><a href="https://github.com/parcel-bundler/parcel">📦🚀 Blazing fast, zero configuration web application bundler</a><br /><a href="https://github.com/jackfrued/Python-100-Days">Python - 100天从新手到大师</a><br /><a href="https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh">程序员应该访问的最佳网站中文版</a><br /><a href="https://github.com/login?return_to=%2Filuwatar%2Fjava-design-patterns">Design patterns implemented in Java</a><br /><a href="https://github.com/youngyangyang04/leetcode-master">LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀</a><br /><a href="https://github.com/Kong/kong">🦍 The Cloud-Native API Gateway</a><br /><a href="https://github.com/yichahucha/surge">Some useful scripts.</a><br /><a href="https://github.com/frappe/erpnext">World's best free and open source ERP.</a><br /><hr />不相交的线<br /><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>

<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p>

<ul>
	<li> <code>nums1[i] == nums2[j]</code></li>
	<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>

<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>

<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>

<p> </p>

<p><strong>示例 1：</strong></p>
<strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png" style="height: 72px; width: 100px;" /></strong>

<pre>
<strong>输入：</strong>nums1 = <span id="example-input-1-1">[1,4,2]</span>, nums2 = <span id="example-input-1-2">[1,2,4]</span>
<strong>输出：</strong><span id="example-output-1">2</span>
<strong>解释：</strong>可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
</pre>

<div>
<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums1 = <span id="example-input-2-1">[2,5,1,2,5]</span>, nums2 = <span id="example-input-2-2">[10,5,2,1,5,2]</span>
<strong>输出：</strong><span id="example-output-2">3</span>
</pre>

<div>
<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums1 = <span id="example-input-3-1">[1,3,7,1,7,5]</span>, nums2 = <span id="example-input-3-2">[1,9,2,5,1]</span>
<strong>输出：</strong><span id="example-output-3">2</span></pre>

<p> </p>
</div>
</div>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= nums1.length <= 500</code></li>
	<li><code>1 <= nums2.length <= 500</code></li>
	<li><code><font face="monospace">1 <= nums1[i], nums2[i] <= 2000</font></code></li>
</ul>

<p> </p>
<br />#### 方法一：动态规划

给定两个数组 $\textit{nums}_1$ 和 $\textit{nums}_2$，当 $\textit{nums}_1[i]=\textit{nums}_2[j]$ 时，可以用一条直线连接 $\textit{nums}_1[i]$ 和 $\textit{nums}_2[j]$。假设一共绘制了 $k$ 条互不相交的直线，其中第 $x$ 条直线连接 $\textit{nums}_1[i_x]$ 和 $\textit{nums}_2[j_x]$，则对于任意 $1 \le x \le k$ 都有 $\textit{nums}_1[i_x]=\textit{nums}_2[j_x]$，其中 $i_1<i_2<\ldots<i_k$，$j_1<j_2<\ldots<j_k$。

上述 $k$ 条互不相交的直线分别连接了数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的 $k$ 对相等的元素，而且这 $k$ 对相等的元素在两个数组中的相对顺序是一致的，因此，这 $k$ 对相等的元素组成的序列即为数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的公共子序列。要计算可以绘制的最大连线数，即为计算数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的最长公共子序列的长度。最长公共子序列问题是典型的二维动态规划问题。

假设数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的长度分别为 $m$ 和 $n$，创建 $m+1$ 行 $n+1$ 列的二维数组 $\textit{dp}$，其中 $\textit{dp}[i][j]$ 表示 $\textit{nums}_1[0:i]$ 和 $\textit{nums}_2[0:j]$ 的最长公共子序列的长度。

> 上述表示中，$\textit{nums}_1[0:i]$ 表示数组 $\textit{nums}_1$ 的长度为 $i$ 的前缀，$\textit{nums}_2[0:j]$ 表示数组 $\textit{nums}_2$ 的长度为 $j$ 的前缀。

考虑动态规划的边界情况：

- 当 $i=0$ 时，$\textit{nums}_1[0:i]$ 为空，空数组和任何数组的最长公共子序列的长度都是 $0$，因此对任意 $0 \le j \le n$，有 $\textit{dp}[0][j]=0$；

- 当 $j=0$ 时，$\textit{nums}_2[0:j]$ 为空，同理可得，对任意 $0 \le i \le m$，有 $\textit{dp}[i][0]=0$。

因此动态规划的边界情况是：当 $i=0$ 或 $j=0$ 时，$\textit{dp}[i][j]=0$。

当 $i>0$ 且 $j>0$ 时，考虑 $\textit{dp}[i][j]$ 的计算：

- 当 $\textit{nums}_1[i-1]=\textit{nums}_2[j-1]$ 时，将这两个相同的元素称为公共元素，考虑 $\textit{nums}_1[0:i-1]$ 和 $\textit{nums}_2[0:j-1]$ 的最长公共子序列，再增加一个元素（即公共元素）即可得到 $\textit{nums}_1[0:i]$ 和 $\textit{nums}_2[0:j]$ 的最长公共子序列，因此 $\textit{dp}[i][j]=\textit{dp}[i-1][j-1]+1$。

- 当 $\textit{nums}_1[i-1] \ne \textit{nums}_2[j-1]$ 时，考虑以下两项：

   - $\textit{nums}_1[0:i-1]$ 和 $\textit{nums}_2[0:j]$ 的最长公共子序列；

   - $\textit{nums}_1[0:i]$ 和 $\textit{nums}_2[0:j-1]$ 的最长公共子序列。

   要得到 $\textit{nums}_1[0:i]$ 和 $\textit{nums}_2[0:j]$ 的最长公共子序列，应取两项中的长度较大的一项，因此 $\textit{dp}[i][j]=\max(\textit{dp}[i-1][j],\textit{dp}[i][j-1])$。

由此可以得到如下状态转移方程：

$$
\textit{dp}[i][j] = \begin{cases}
\textit{dp}[i-1][j-1]+1, & \textit{nums}_1[i-1]=\textit{nums}_2[j-1] \\
\max(\textit{dp}[i-1][j],\textit{dp}[i][j-1]), & \textit{nums}_1[i-1] \ne \textit{nums}_2[j-1]
\end{cases}
$$

最终计算得到 $\textit{dp}[m][n]$ 即为数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的最长公共子序列的长度，即可以绘制的最大连线数。

![fig1](https://assets.leetcode-cn.com/solution-static/1035/1.png){:width="80%"}

```Java [sol1-Java]
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            int num1 = nums1[i - 1];
            for (int j = 1; j <= n; j++) {
                int num2 = nums2[j - 1];
                if (num1 == num2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int MaxUncrossedLines(int[] nums1, int[] nums2) {
        int m = nums1.Length, n = nums2.Length;
        int[,] dp = new int[m + 1, n + 1];
        for (int i = 1; i <= m; i++) {
            int num1 = nums1[i - 1];
            for (int j = 1; j <= n; j++) {
                int num2 = nums2[j - 1];
                if (num1 == num2) {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                } else {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }
        return dp[m, n];
    }
}
```

```JavaScript [sol1-JavaScript]
var maxUncrossedLines = function(nums1, nums2) {
    const m = nums1.length, n = nums2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 1; i <= m; i++) {
        const num1 = nums1[i - 1];
        for (let j = 1; j <= n; j++) {
            const num2 = nums2[j - 1];
            if (num1 === num2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```

```go [sol1-Golang]
func maxUncrossedLines(nums1, nums2 []int) int {
    m, n := len(nums1), len(nums2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i, v := range nums1 {
        for j, w := range nums2 {
            if v == w {
                dp[i+1][j+1] = dp[i][j] + 1
            } else {
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```Python [sol1-Python3]
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i, num1 in enumerate(nums1):
            for j, num2 in enumerate(nums2):
                if num1 == num2:
                    dp[i + 1][j + 1] = dp[i][j] + 1
                else:
                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])
        
        return dp[m][n]
```

```C++ [sol1-C++]
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i <= m; i++) {
            int num1 = nums1[i - 1];
            for (int j = 1; j <= n; j++) {
                int num2 = nums2[j - 1];
                if (num1 == num2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};
```

```C [sol1-C]
int maxUncrossedLines(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    int m = nums1Size, n = nums2Size;
    int dp[m + 1][n + 1];
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= m; i++) {
        int num1 = nums1[i - 1];
        for (int j = 1; j <= n; j++) {
            int num2 = nums2[j - 1];
            if (num1 == num2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = fmax(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

**复杂度分析**

- 时间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的长度。二维数组 $\textit{dp}$ 有 $m+1$ 行和 $n+1$ 列，需要对 $\textit{dp}$ 中的每个元素进行计算。

- 空间复杂度：$O(mn)$，其中 $m$ 和 $n$ 分别是数组 $\textit{nums}_1$ 和 $\textit{nums}_2$ 的长度。创建了 $m+1$ 行 $n+1$ 列的二维数组 $\textit{dp}$。


---
## ✨扣友帮帮团 - 互动答疑

[![讨论.jpg](https://pic.leetcode-cn.com/1621178600-MKHFrl-%E8%AE%A8%E8%AE%BA.jpg){:width=260px}](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)


即日起 - 5 月 30 日，点击 [这里](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/) 前往「[扣友帮帮团](https://leetcode-cn.com/topic/kou-you-bang-bang-tuan/discuss/latest/)」活动页，把你遇到的问题大胆地提出来，让扣友为你解答～

### 🎁 奖励规则
被采纳数量排名 1～3 名：「力扣极客套装」 *1 并将获得「力扣神秘应援团」内测资格
被采纳数量排名 4～10 名：「力扣鼠标垫」 *1 并将获得「力扣神秘应援团」内测资格
「诲人不倦」：活动期间「解惑者」只要有 1 个回答被采纳，即可获得 20 LeetCoins 奖励！
「求知若渴」：活动期间「求知者」在活动页发起一次符合要求的疑问帖并至少采纳一次「解惑者」的回答，即可获得 20 LeetCoins 奖励！

活动详情猛戳链接了解更多：[🐞 你有 BUG 我来帮 - 力扣互动答疑季](https://leetcode-cn.com/circle/discuss/xtliW6/)