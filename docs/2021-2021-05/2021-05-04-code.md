# 2021å¹´05æœˆ04æ—¥ code
<a href="https://toutiao.io/k/ok4mp6n">äº”ä¸€å‡æœŸä¸æƒ³äººæŒ¤äººï¼Ÿæ¥è¿™é‡Œï¼</a><br /><a href="https://toutiao.io/k/6mzds1m">ç³»ç»Ÿè®¾è®¡ä¹‹è·¯ï¼šå¦‚ä½•è®¾è®¡ä¸€ä¸ª URL çŸ­é“¾æœåŠ¡</a><br /><a href="https://toutiao.io/k/wa4mx5o">å¯¹è±¡çš„å¯è§æ€§ï¼švolatile ç¯‡</a><br /><a href="https://toutiao.io/k/b6wvgvt">å¦‚ä½•å€ŸåŠ© Proxy ä»£ç†ï¼Œæå‡æ¶æ„æ‰©å±•æ€§</a><br /><a href="https://toutiao.io/k/z7fag7p">Java åŒåˆƒå‰‘ä¹‹ Unsafe ç±»è¯¦è§£</a><br /><a href="https://toutiao.io/k/kjh5lwh">äººå·¥å’Œè‡ªç„¶</a><br /><a href="https://toutiao.io/k/gvwrofa">ç®€å•èŠä¸€èŠ MQTT</a><br /><a href="https://toutiao.io/k/gil680k">è¢«æ‹‰è¿›ä¸€ä¸ªåˆ·å•ç¾¤ï¼Œèµšäº† 75 å…ƒï¼šå°±çœŸçš„åªæ˜¯åˆ·å•å—ï¼Ÿ</a><br /><a href="https://toutiao.io/k/bbseaei">Kotlin å†…å»ºä»£ç†</a><br /><a href="https://toutiao.io/k/ncs1rgp">å¦‚ä½•ä»å¹¿åº¦ä¸æ·±åº¦è¡¡é‡æ‰“åŒ…å·¥å…·çš„å¥½å</a><br /><a href="https://toutiao.io/k/xkhaihd">[æ¨è] åç¨‹åˆ‡æ¢ä¼šå¼•èµ·ä»€ä¹ˆé—®é¢˜</a><br /><a href="https://toutiao.io/k/iwkig90">[æ¨è] æ®·æµ©è¯¦è§£ DDDï¼šå¦‚ä½•é¿å…å†™æµæ°´è´¦ä»£ç ï¼Ÿ</a><br /><a href="https://toutiao.io/k/2aonyjp">[æ¨è] æŠŠ Redis å½“ä½œé˜Ÿåˆ—æ¥ç”¨ï¼ŒçœŸçš„åˆé€‚å—ï¼Ÿ</a><br /><a href="https://toutiao.io/k/90vs9kg">[æ¨è] ClickHouse åœ¨ Bilibili ç”¨æˆ·è¡Œä¸ºåˆ†æçš„å®è·µ</a><br /><a href="https://toutiao.io/k/0etokja">[æ¨è] Kafkaï¼šè¿™æ¬¡åˆ†äº«æˆ‘åªæƒ³æŠŠåŸç†è®²æ¸…æ¥š</a><br /><a href="https://toutiao.io/k/j7fdh6h">[æ¨è] ä¸€æ–‡ææ‡‚åˆ†å¸ƒå¼é”çš„åŸç†ä¸å®ç°</a><br /><a href="https://toutiao.io/k/wxrneux">[æ¨è] ä¸ºä»€ä¹ˆæ”¾å¼ƒ Kafkaï¼Œé€‰æ‹© Pulsar?</a><br /><a href="https://toutiao.io/k/a5s1rfh">[æ¨è] å‰ç«¯å“ªéœ€è¦è‡ªå·±è®¾è®¡é¡µé¢ï¼Ÿç”¨ç°æˆçš„ä¸å°±å¥½äº†</a><br /><a href="https://toutiao.io/k/0iue4f4">[æ¨è] 2.7w å­—ï¼Java åŸºç¡€é¢è¯•é¢˜/çŸ¥è¯†ç‚¹æ€»ç»“ï¼ˆ2021 æœ€æ–°ç‰ˆï¼‰</a><br /><a href="https://toutiao.io/k/upefap5">[æ¨è] ç¨‹åºå‘˜åº”è¯¥æŒæ¡çš„å¸¸ç”¨ç½‘ç»œé—®é¢˜å®šä½å·¥å…·</a><br /><a href="https://toutiao.io/k/nrdp4oq">[æ¨è] ç”¨æˆ·ç”»åƒçš„åŸºç¡€ã€åŸç†ã€æ–¹æ³•è®ºï¼ˆæ¨¡å‹ï¼‰å’Œåº”ç”¨</a><br /><a href="https://toutiao.io/k/6z3uu2m">[æ¨è] å¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜æ€§èƒ½çš„ç§’æ€ç³»ç»Ÿ</a><br /><a href="https://toutiao.io/k/fwtxydd">[æ¨è] æ¶æ„æ¨¡å¼ä¹‹åˆ†å±‚æ¶æ„æ€»ç»“</a><br /><a href="https://toutiao.io/k/08uadl6">[æ¨è] ä¹¦å•ä¸¨â€œ1 æœ¬æŠµ 10 æœ¬â€ çš„å¥½ä¹¦ï¼Œå»ºè®®æ”¶è—</a><br /><a href="https://toutiao.io/k/ti0gb8i">[æ¨è] Redis è¿›é˜¶ç¬”è®°</a><br /><hr /><a href="https://github.com/facebookresearch/dino">PyTorch code for Vision Transformers training with the Self-Supervised learning method DINO</a><br /><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">Bootstrap Kubernetes the hard way on Google Cloud Platform. No scripts.</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/login?return_to=%2Fsupabase%2Fsupabase">The open source Firebase alternative. Follow to stay updated about our public Beta.</a><br /><a href="https://github.com/bitclout/frontend">bitclout.com frontend</a><br /><a href="https://github.com/mrdbourke/tensorflow-deep-learning">All course materials for the Zero to Mastery Deep Learning with TensorFlow course.</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/thedevdojo/wave">Wave - The Software as a Service Starter Kit, designed to help you build the SAAS of your dreams ğŸš€ ğŸ’°</a><br /><a href="https://github.com/DIGITALCRIMINAL/OnlyFans">Scrape all the media from an OnlyFans account - Updated regularly</a><br /><a href="https://github.com/twintproject/twint">An advanced Twitter scraping & OSINT tool written in Python that doesn't use Twitter's API, allowing you to scrape a user's followers, following, Tweets and more while evading most API limitations.</a><br /><a href="https://github.com/projectdiscovery/interactsh">An OOB interaction gathering server and client library</a><br /><a href="https://github.com/androidmalware/android_hid">Use Android as Rubber Ducky against another Android device</a><br /><a href="https://github.com/commaai/openpilot">openpilot is an open source driver assistance system. openpilot performs the functions of Automated Lane Centering and Adaptive Cruise Control for over 100 supported car makes and models.</a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/Uniswap/uniswap-interface">ğŸ¦„ An open source interface for the Uniswap protocol</a><br /><a href="https://github.com/ninjamuffin99/Funkin"></a><br /><a href="https://github.com/katherinepeterson/readme.so"></a><br /><a href="https://github.com/flashlight/flashlight">A C++ standalone library for machine learning</a><br /><a href="https://github.com/microsoft/PowerToys">Windows system utilities to maximize productivity</a><br /><a href="https://github.com/github/docs">The open-source repo for docs.github.com</a><br /><a href="https://github.com/wisz2021/jd_docker">ä»…ç”¨æŸ¥çœ‹æ–‡æ¡£</a><br /><a href="https://github.com/CSSEGISandData/COVID-19">Novel Coronavirus (COVID-19) Cases, provided by JHU CSSE</a><br /><a href="https://github.com/vfat-tools/vfat-tools"></a><br /><a href="https://github.com/bhattbhavesh91/cowin-vaccination-slot-availability">Script to check the available slots for Covid-19 Vaccination Centers from CoWIN API in India</a><br /><a href="https://github.com/KOBA789/relly">RDBMS ã®ã—ãã¿ã‚’å­¦ã¶ãŸã‚ã®å°ã•ãª RDBMS å®Ÿè£…</a><br /><hr />ç²‰åˆ·æˆ¿å­ III<br /><p>åœ¨ä¸€ä¸ªå°åŸå¸‚é‡Œï¼Œæœ‰&nbsp;<code>m</code>&nbsp;ä¸ªæˆ¿å­æ’æˆä¸€æ’ï¼Œä½ éœ€è¦ç»™æ¯ä¸ªæˆ¿å­æ¶‚ä¸Š <code>n</code>&nbsp;ç§é¢œè‰²ä¹‹ä¸€ï¼ˆé¢œè‰²ç¼–å·ä¸º <code>1</code> åˆ° <code>n</code>&nbsp;ï¼‰ã€‚æœ‰çš„æˆ¿å­å»å¹´å¤å¤©å·²ç»æ¶‚è¿‡é¢œè‰²äº†ï¼Œæ‰€ä»¥è¿™äº›æˆ¿å­ä¸éœ€è¦è¢«é‡æ–°æ¶‚è‰²ã€‚</p>

<p>æˆ‘ä»¬å°†è¿ç»­ç›¸åŒé¢œè‰²å°½å¯èƒ½å¤šçš„æˆ¿å­ç§°ä¸ºä¸€ä¸ªè¡—åŒºã€‚ï¼ˆæ¯”æ–¹è¯´ <code>houses = [1,2,2,3,3,2,1,1]</code> ï¼Œå®ƒåŒ…å« 5 ä¸ªè¡—åŒº&nbsp;<code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> ã€‚ï¼‰</p>

<p>ç»™ä½ ä¸€ä¸ªæ•°ç»„&nbsp;<code>houses</code>&nbsp;ï¼Œä¸€ä¸ª&nbsp;<code>m * n</code>&nbsp;çš„çŸ©é˜µ&nbsp;<code>cost</code>&nbsp;å’Œä¸€ä¸ªæ•´æ•°&nbsp;<code>target</code>&nbsp;ï¼Œå…¶ä¸­ï¼š</p>

<ul>
	<li><code>houses[i]</code>ï¼šæ˜¯ç¬¬&nbsp;<code>i</code>&nbsp;ä¸ªæˆ¿å­çš„é¢œè‰²ï¼Œ<strong>0</strong>&nbsp;è¡¨ç¤ºè¿™ä¸ªæˆ¿å­è¿˜æ²¡æœ‰è¢«æ¶‚è‰²ã€‚</li>
	<li><code>cost[i][j]</code>ï¼šæ˜¯å°†ç¬¬&nbsp;<code>i</code>&nbsp;ä¸ªæˆ¿å­æ¶‚æˆé¢œè‰²&nbsp;<code>j+1</code>&nbsp;çš„èŠ±è´¹ã€‚</li>
</ul>

<p>è¯·ä½ è¿”å›æˆ¿å­æ¶‚è‰²æ–¹æ¡ˆçš„æœ€å°æ€»èŠ±è´¹ï¼Œä½¿å¾—æ¯ä¸ªæˆ¿å­éƒ½è¢«æ¶‚è‰²åï¼Œæ°å¥½ç»„æˆ&nbsp;<code>target</code>&nbsp;ä¸ªè¡—åŒºã€‚å¦‚æœæ²¡æœ‰å¯ç”¨çš„æ¶‚è‰²æ–¹æ¡ˆï¼Œè¯·è¿”å›&nbsp;<strong>-1</strong>&nbsp;ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>è¾“å‡ºï¼š</strong>9
<strong>è§£é‡Šï¼š</strong>æˆ¿å­æ¶‚è‰²æ–¹æ¡ˆä¸º [1,2,2,1,1]
æ­¤æ–¹æ¡ˆåŒ…å« target = 3 ä¸ªè¡—åŒºï¼Œåˆ†åˆ«æ˜¯ [{1}, {2,2}, {1,1}]ã€‚
æ¶‚è‰²çš„æ€»èŠ±è´¹ä¸º (1 + 1 + 1 + 1 + 5) = 9ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>è¾“å‡ºï¼š</strong>11
<strong>è§£é‡Šï¼š</strong>æœ‰çš„æˆ¿å­å·²ç»è¢«æ¶‚è‰²äº†ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šæ¶‚è‰²æ–¹æ¡ˆä¸º [2,2,1,2,2]
æ­¤æ–¹æ¡ˆåŒ…å« target = 3 ä¸ªè¡—åŒºï¼Œåˆ†åˆ«æ˜¯ [{2,2}, {1}, {2,2}]ã€‚
ç»™ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæˆ¿å­æ¶‚è‰²çš„èŠ±è´¹ä¸º (10 + 1) = 11ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
<strong>è¾“å‡ºï¼š</strong>5
</pre>

<p><strong>ç¤ºä¾‹ 4ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
<strong>è¾“å‡ºï¼š</strong>-1
<strong>è§£é‡Šï¼š</strong>æˆ¿å­å·²ç»è¢«æ¶‚è‰²å¹¶ç»„æˆäº† 4 ä¸ªè¡—åŒºï¼Œåˆ†åˆ«æ˜¯ [{3},{1},{2},{3}] ï¼Œæ— æ³•å½¢æˆ target = 3 ä¸ªè¡—åŒºã€‚
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li><code>m == houses.length == cost.length</code></li>
	<li><code>n == cost[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>1 &lt;= target&nbsp;&lt;= m</code></li>
	<li><code>0 &lt;= houses[i]&nbsp;&lt;= n</code></li>
	<li><code>1 &lt;= cost[i][j] &lt;= 10^4</code></li>
</ul>
<br />#### å‰è¨€

ä¸ºäº†å™è¿°æ–¹ä¾¿ï¼Œæˆ‘ä»¬ä»¤æ‰€æœ‰çš„å˜é‡éƒ½ä» $0$ å¼€å§‹ç¼–å·ï¼Œå³ï¼š

- æˆ¿å­çš„ç¼–å·ä¸º $[0, m-1]$ï¼›
- é¢œè‰²çš„ç¼–å·ä¸º $[0, n-1]$ï¼Œå¦‚æœæˆ¿å­æ²¡æœ‰æ¶‚ä¸Šé¢œè‰²ï¼Œé‚£ä¹ˆè®°ä¸º $-1$ï¼›
- è¡—åŒºçš„ç¼–å·ä¸º $[0, \textit{target}-1]$ã€‚

#### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

**æ€è·¯ä¸ç®—æ³•**

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’è§£å†³æœ¬é¢˜ã€‚

è®¾ $\textit{dp}(i,j,k)$ è¡¨ç¤ºå°† $[0, i]$ çš„æˆ¿å­éƒ½æ¶‚ä¸Šé¢œè‰²ï¼Œæœ€æœ«å°¾çš„ç¬¬ $i$ ä¸ªæˆ¿å­çš„é¢œè‰²ä¸º $j$ï¼Œå¹¶ä¸”å®ƒå±äºç¬¬ $k$ ä¸ªè¡—åŒºæ—¶ï¼Œéœ€è¦çš„æœ€å°‘èŠ±è´¹ã€‚

åœ¨è¿›è¡ŒçŠ¶æ€è½¬ç§»æ—¶ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ã€Œç¬¬ $i-1$ ä¸ªæˆ¿å­çš„é¢œè‰²ã€ï¼Œè¿™å…³ç³»åˆ°ã€ŒèŠ±è´¹ã€ä»¥åŠã€Œè¡—åŒºæ•°é‡ã€çš„è®¡ç®—ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦å¯¹å…¶è¿›è¡Œæšä¸¾ã€‚

è®¾ç¬¬ $i-1$ ä¸ªæˆ¿å­çš„é¢œè‰²ä¸º $j_0$ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†ç±»è®¨è®ºå‡ºä¸åŒæƒ…å†µä¸‹çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

- å¦‚æœ $\textit{houses}[i] \neq -1$ï¼Œè¯´æ˜ç¬¬ $i$ ä¸ªæˆ¿å­å·²ç»æ¶‚è¿‡é¢œè‰²äº†ã€‚ç”±äºæˆ‘ä»¬ä¸èƒ½é‡å¤æ¶‚è‰²ï¼Œé‚£ä¹ˆå¿…é¡»æœ‰ $\textit{houses}[i] = j$ã€‚æˆ‘ä»¬å¯ä»¥å†™å‡ºåœ¨ $\textit{houses}[i] \neq j$ æ—¶çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

    $$
    \textit{dp}(i, j, k) = \infty, \quad å¦‚æœ~\textit{houses}[i] \neq -1~å¹¶ä¸”~\textit{houses}[i] \neq j
    $$

    è¿™é‡Œæˆ‘ä»¬ç”¨æå¤§å€¼ $\infty$ è¡¨ç¤ºä¸æ»¡è¶³è¦æ±‚çš„çŠ¶æ€ï¼Œç”±äºæˆ‘ä»¬éœ€è¦æ±‚å‡ºçš„æ˜¯æœ€å°‘èŠ±è´¹ï¼Œå› æ­¤æå¤§å€¼ä¸ä¼šå¯¹çŠ¶æ€è½¬ç§»äº§ç”Ÿå½±å“ã€‚

    å½“ $\textit{houses}[i] = j$ æ—¶ï¼Œå¦‚æœ $j=j_0$ï¼Œé‚£ä¹ˆç¬¬ $i-1$ ä¸ªæˆ¿å­å’Œç¬¬ $i$ ä¸ªæˆ¿å­å±äºåŒä¸€ä¸ªè¡—åŒºï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

    $$
    \textit{dp}(i, j, k) = \textit{dp}(i-1, j, k), \quad å¦‚æœ~ \textit{houses}[i] = j
    $$

    å¦‚æœ $j \neq j_0$ï¼Œé‚£ä¹ˆå®ƒä»¬å±äºä¸åŒçš„è¡—åŒºï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

    $$
    \textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1), \quad å¦‚æœ~ \textit{houses}[i] = j
    $$

- å¦‚æœ $\textit{houses}[i] = -1$ï¼Œè¯´æ˜æˆ‘ä»¬éœ€è¦å°†ç¬¬ $i$ ä¸ªæˆ¿å­æ¶‚æˆé¢œè‰² $j$ï¼ŒèŠ±è´¹ä¸º $\textit{cost}[i][j]$ã€‚

    æ­¤å¤–çš„çŠ¶æ€è½¬ç§»ä¸ä¸Šä¸€ç±»æƒ…å†µç±»ä¼¼ã€‚å¦‚æœ $j = j_0$ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

    $$
    \textit{dp}(i, j, k) = \textit{dp}(i-1, j, k) + \textit{cost}[i][j], \quad å¦‚æœ~\textit{houses}[i]=-1
    $$

    å¦‚æœ $j \neq j_0$ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

    $$
    \textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1) + \textit{cost}[i][j], \quad å¦‚æœ~\textit{houses}[i]=-1
    $$

æœ€ç»ˆçš„ç­”æ¡ˆå³ä¸º $\min\limits_{j} \textit{dp}(m-1, j, \textit{target} - 1)$ã€‚

**ç»†èŠ‚**

ä»¥ä¸‹çš„ç»†èŠ‚æœ‰åŠ©äºå†™å‡ºæ›´ç®€æ´çš„ä»£ç ï¼š

- æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„çŠ¶æ€åˆå§‹åŒ–ä¸º $\infty$ã€‚åœ¨è¿›è¡ŒçŠ¶æ€è½¬ç§»æ—¶ï¼Œæˆ‘ä»¬æ˜¯é€‰æ‹©è½¬ç§»ä¸­çš„æœ€å°å€¼ï¼Œå› æ­¤ $\infty$ ä¸ä¼šäº§ç”Ÿå½±å“ï¼›

- ä¸¤ç±»æƒ…å†µä¸‹çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ååˆ†ç±»ä¼¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å…ˆä¸å»ç®¡ $\textit{cost}[i][j]$ çš„éƒ¨åˆ†ï¼Œåœ¨æ±‚å‡º $\textit{dp}(i, j, k)$ çš„æœ€å°å€¼ä¹‹åï¼Œå¦‚æœå‘ç° $\textit{houses}[i]=-1$ï¼Œå†åŠ ä¸Š $\textit{cost}[i][j]$ å³å¯ï¼›

- å½“ $k=0$ æ—¶ï¼Œä¸èƒ½ä»åŒ…å« $k-1$ çš„çŠ¶æ€è½¬ç§»è€Œæ¥ï¼›

- å½“ $i=0$ æ—¶ï¼Œç¬¬ $0$ ä¸ªæˆ¿å­ä¹‹å‰æ²¡æœ‰æˆ¿å­ï¼Œå› æ­¤ $k$ ä¹Ÿå¿…é¡»ä¸º $0$ã€‚æ­¤æ—¶çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

    $$
    \textit{dp}(0, j, 0) = \left\{ \begin{aligned}
    & \infty, && å¦‚æœ~\textit{houses}[i] \neq -1 ~å¹¶ä¸”~\textit{houses}[i] \neq j \\
    & 0, && å¦‚æœ~\textit{houses}[i] \neq -1 ~å¹¶ä¸”~\textit{houses}[i] = j \\
    & \textit{cost}[i][j], && å¦‚æœ~\textit{houses}[i]=-1
    \end{aligned} \right.
    $$

    å½“ $i=0$ ä¸” $k \neq 0$ æ—¶ï¼Œ$\textit{dp}(0, j, k) = \infty$ã€‚

**ä»£ç **

```C++ [sol1-C++]
class Solution {
private:
    // æå¤§å€¼
    // é€‰æ‹© INT_MAX / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
    static constexpr int INFTY = INT_MAX / 2;

public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        for (int& c: houses) {
            --c;
        }

        // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(target, INFTY)));

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    for (int j0 = 0; j0 < n; ++j0) {
                        if (j == j0) {
                            if (i == 0) {
                                if (k == 0) {
                                    dp[i][j][k] = 0;
                                }
                            }
                            else {
                                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k]);
                            }
                        }
                        else if (i > 0 && k > 0) {
                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j0][k - 1]);
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    // æå¤§å€¼
    // é€‰æ‹© Integer.MAX_VALUE / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
    static final int INFTY = Integer.MAX_VALUE / 2;

    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        int[][][] dp = new int[m][n][target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                Arrays.fill(dp[i][j], INFTY);
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    for (int j0 = 0; j0 < n; ++j0) {
                        if (j == j0) {
                            if (i == 0) {
                                if (k == 0) {
                                    dp[i][j][k] = 0;
                                }
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);
                            }
                        } else if (i > 0 && k > 0) {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]);
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```C# [sol1-C#]
public class Solution {
    // æå¤§å€¼
    // é€‰æ‹© int.MaxValue / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
    const int INFTY = int.MaxValue / 2;

    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {
        // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        int[,,] dp = new int[m, n, target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < target; ++k) {
                    dp[i, j, k] = INFTY;
                }
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    for (int j0 = 0; j0 < n; ++j0) {
                        if (j == j0) {
                            if (i == 0) {
                                if (k == 0) {
                                    dp[i, j, k] = 0;
                                }
                            } else {
                                dp[i, j, k] = Math.Min(dp[i, j, k], dp[i - 1, j, k]);
                            }
                        } else if (i > 0 && k > 0) {
                            dp[i, j, k] = Math.Min(dp[i, j, k], dp[i - 1, j0, k - 1]);
                        }
                    }

                    if (dp[i, j, k] != INFTY && houses[i] == -1) {
                        dp[i, j, k] += cost[i][j];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.Min(ans, dp[m - 1, j, target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        # å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        houses = [c - 1 for c in houses]

        # dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        dp = [[[float("inf")] * target for _ in range(n)] for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if houses[i] != -1 and houses[i] != j:
                    continue
                
                for k in range(target):
                    for j0 in range(n):
                        if j == j0:
                            if i == 0:
                                if k == 0:
                                    dp[i][j][k] = 0
                            else:
                                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])
                        elif i > 0 and k > 0:
                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j0][k - 1])

                    if dp[i][j][k] != float("inf") and houses[i] == -1:
                        dp[i][j][k] += cost[i][j]

        ans = min(dp[m - 1][j][target - 1] for j in range(n))
        return -1 if ans == float("inf") else ans
```

```JavaScript [sol1-JavaScript]
var minCost = function(houses, cost, m, n, target) {
    // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
    houses = houses.map(c => --c);
    const dp = new Array(m).fill(0)
                           .map(() => new Array(n).fill(0)
                           .map(() => new Array(target).fill(Number.MAX_VALUE)));
    
    // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (houses[i] !== -1 && houses[i] !== j) {
                continue;
            }
            
            for (let k = 0; k < target; ++k) {
                for (let j0 = 0; j0 < n; ++j0) {
                    if (j === j0) {
                        if (i === 0) {
                            if (k === 0) {
                                dp[i][j][k] = 0;
                            }
                        } else {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);
                        }
                    } else if (i > 0 && k > 0) {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]);
                    }
                }

                if (dp[i][j][k] !== Number.MAX_VALUE && houses[i] === -1) {
                    dp[i][j][k] += cost[i][j];
                }
            }
        }
    }
    
    let ans = Number.MAX_VALUE;
    for (let j = 0; j < n; ++j) {
        ans = Math.min(ans, dp[m - 1][j][target - 1]);
    }
    return ans === Number.MAX_VALUE ? -1 : ans;
};
```

```go [sol1-Golang]
func minCost(houses []int, cost [][]int, m, n, target int) int {
    const inf = math.MaxInt64 / 2 // é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º

    // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
    for i := range houses {
        houses[i]--
    }

    // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
    dp := make([][][]int, m)
    for i := range dp {
        dp[i] = make([][]int, n)
        for j := range dp[i] {
            dp[i][j] = make([]int, target)
            for k := range dp[i][j] {
                dp[i][j][k] = inf
            }
        }
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if houses[i] != -1 && houses[i] != j {
                continue
            }

            for k := 0; k < target; k++ {
                for j0 := 0; j0 < n; j0++ {
                    if j == j0 {
                        if i == 0 {
                            if k == 0 {
                                dp[i][j][k] = 0
                            }
                        } else {
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k])
                        }
                    } else if i > 0 && k > 0 {
                        dp[i][j][k] = min(dp[i][j][k], dp[i-1][j0][k-1])
                    }
                }

                if dp[i][j][k] != inf && houses[i] == -1 {
                    dp[i][j][k] += cost[i][j]
                }
            }
        }
    }

    ans := inf
    for _, res := range dp[m-1] {
        ans = min(ans, res[target-1])
    }
    if ans == inf {
        return -1
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```C [sol1-C]
// æå¤§å€¼
// é€‰æ‹© INT_MAX / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
const int INFTY = 0x3f3f3f3f;

int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target) {
    // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
    for (int i = 0; i < housesSize; ++i) {
        houses[i]--;
    }

    // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
    int dp[m][n][target];
    memset(dp, 0x3f, sizeof(dp));

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (houses[i] != -1 && houses[i] != j) {
                continue;
            }

            for (int k = 0; k < target; ++k) {
                for (int j0 = 0; j0 < n; ++j0) {
                    if (j == j0) {
                        if (i == 0) {
                            if (k == 0) {
                                dp[i][j][k] = 0;
                            }
                        } else {
                            dp[i][j][k] = fmin(dp[i][j][k], dp[i - 1][j][k]);
                        }
                    } else if (i > 0 && k > 0) {
                        dp[i][j][k] = fmin(dp[i][j][k], dp[i - 1][j0][k - 1]);
                    }
                }

                if (dp[i][j][k] != INFTY && houses[i] == -1) {
                    dp[i][j][k] += cost[i][j];
                }
            }
        }
    }

    int ans = INFTY;
    for (int j = 0; j < n; ++j) {
        ans = fmin(ans, dp[m - 1][j][target - 1]);
    }
    return ans == INFTY ? -1 : ans;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(m\cdot n^2\cdot \textit{target})$ã€‚çŠ¶æ€çš„æ•°é‡ä¸º $O(m\cdot n\cdot \textit{target})$ï¼Œæ¯ä¸ªçŠ¶æ€éœ€è¦ $O(n)$ çš„æ—¶é—´æšä¸¾ $j_0$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(m\cdot n^2\cdot \textit{target})$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(m \cdot n \cdot \textit{target})$ï¼Œå³ä¸ºçŠ¶æ€çš„æ•°é‡ã€‚

    æ³¨æ„åˆ° $\textit{dp}(i,j,k)$ åªä¼šä» $\textit{dp}(i-1, \cdots, \cdots)$ è½¬ç§»è€Œæ¥ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„å¯¹ç©ºé—´å¤æ‚åº¦è¿›è¡Œä¼˜åŒ–ï¼Œå³ä½¿ç”¨ä¸¤ä¸ªå¤§å°ä¸º $n \cdot \textit{target}$ çš„æ•°ç»„ $\textit{dp}_1$, $\textit{dp}_2$ï¼Œå°† $dp(0,j,k)$ çš„å€¼å­˜å‚¨åœ¨ $\textit{dp}_1$ ä¸­ï¼Œå°† $dp(1,j,k)$ çš„å€¼å­˜å‚¨åœ¨ $\textit{dp}_2$ ä¸­ï¼Œå°† $dp(2,j,k)$ çš„å€¼å­˜å‚¨åœ¨ $\textit{dp}_1$ ä¸­ï¼Œå°† $dp(3,j,k)$ çš„å€¼å­˜å‚¨åœ¨ $\textit{dp}_2$ ä¸­ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¿™æ ·ä¼˜åŒ–åçš„ç©ºé—´å¤æ‚åº¦ä¸º $O(n\cdot \textit{target})$ã€‚


#### æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’ + ä¼˜åŒ–

**æ€è·¯ä¸ç®—æ³•**

åœ¨æ–¹æ³•ä¸€ä¸­ï¼Œæˆ‘ä»¬åˆ†ç±»è®¨è®ºå‡ºäº†äº”ç§ä¸åŒçš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå…¶ä¸­æœ‰ä¸‰ç§æ˜¯å¯ä»¥åœ¨ $O(1)$ çš„æ—¶é—´è¿›è¡ŒçŠ¶æ€è½¬ç§»çš„ï¼Œè€Œå‰©ä½™çš„ä¸¤ç§éœ€è¦æšä¸¾ $j_0$ï¼Œåªèƒ½åœ¨ $O(n)$ çš„æ—¶é—´è¿›è¡Œè½¬ç§»ï¼Œå³ï¼š

$$
\textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1), \quad å¦‚æœ~ \textit{houses}[i] = j
$$

ä»¥åŠï¼š

$$
\textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1) + \textit{cost}[i][j], \quad å¦‚æœ~\textit{houses}[i]=-1
$$

å¦‚æœæˆ‘ä»¬èƒ½å°†å®ƒä»¬ä¼˜åŒ–è‡³ $O(1)$ï¼Œé‚£ä¹ˆæ•´ä¸ªåŠ¨æ€è§„åˆ’çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿå¯ä»¥ä» $O(m\cdot n^2\cdot \textit{target})$ ä¼˜åŒ–è‡³ $O(m \cdot n \cdot \textit{target})$ã€‚

æˆ‘ä»¬å¯ä»¥ä»¤ $\textit{best}(i, k) = (\textit{first}, \textit{first\_idx}, \textit{second})$ï¼Œè¡¨ç¤ºæ‰€æœ‰çš„çŠ¶æ€ $dp(i, j, k)$ ä¸­çš„æœ€å°å€¼ä¸º $\textit{first}$ï¼Œå–åˆ°æœ€å°å€¼å¯¹åº”çš„ $j$ å€¼ä¸º $\textit{first\_idx}$ï¼Œæ¬¡å°å€¼ä¸º $\textit{second}$ã€‚è¿™é‡Œ $j$ å¯ä»¥åœ¨ $[0, n)$ ä¸­ä»»æ„é€‰æ‹©ï¼Œä½†æˆ‘ä»¬åªè®°å½•æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼ï¼Œä»¥åŠæœ€å¤§å€¼å¯¹åº”çš„ $j$ã€‚

è¿™æ ·åšçš„å¥½å¤„åœ¨äºæˆ‘ä»¬å¯ä»¥å¿«é€Ÿåœ°æ±‚å‡ºåŸå…ˆéœ€è¦ $O(n)$ çš„æ—¶é—´æ‰èƒ½æ±‚å‡ºçš„ï¼š

$$
\min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1)
$$

è¿™ä¸€é¡¹ã€‚å³ï¼š

- æˆ‘ä»¬å–å‡º $\textit{best}(i - 1, k - 1)$ï¼Œå®ƒåŒ…å«çš„ä¸‰ä¸ªå€¼ä¸º $(\textit{first}, \textit{first\_idx}, \textit{second})$ï¼›

- å¦‚æœ $j = \textit{first\_idx}$ï¼Œé‚£ä¹ˆ $\textit{dp}(i, j, k) = \textit{second}$ï¼›

- å¦‚æœ $j \neq \textit{first\_idx}$ï¼Œé‚£ä¹ˆ $\textit{dp}(i, j, k) = \textit{first}$ã€‚

è¿™æ ·åšçš„æ­£ç¡®æ€§é€šè¿‡ $\min\limits_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1)$ æœ¬èº«çš„å®šä¹‰å°±èƒ½ä½“ç°ã€‚

é‚£ä¹ˆå¦‚ä½•æ±‚å‡º $\textit{best}(i, k)$ å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ç»™æ¯ä¸€ä¸ª $\textit{best}(i, k)$ èµ‹äºˆåˆå§‹å€¼ $(\infty, -1, \infty)$ï¼Œæ¯æ¬¡æˆ‘ä»¬è®¡ç®—å‡º $\textit{dp}(i, j, k)$ æ—¶ï¼Œä½¿ç”¨å…¶æ›´æ–° $\textit{best}(i, k)$ å³å¯ã€‚

**ä»£ç **

æ–¹æ³•äºŒçš„ä»£ç è¾ƒä¸ºå¤æ‚ï¼Œä¸»è¦çš„åŸå› åœ¨äºæˆ‘ä»¬éœ€è¦å°†æ–¹æ³•ä¸€ä¸­çš„ $O(n)$ æšä¸¾ $j_0$ çš„å¾ªç¯åˆ é™¤ï¼Œå¹¶ä¸”éœ€è¦ä¿æŒæ–¹æ³•ä¸€ä¸­çš„è¾¹ç•Œæ¡ä»¶ä¸å˜ã€‚

```C++ [sol2-C++]
class Solution {
private:
    // æå¤§å€¼
    // é€‰æ‹© INT_MAX / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
    static constexpr int INFTY = INT_MAX / 2;

    using TIII = tuple<int, int, int>;

public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        for (int& c: houses) {
            --c;
        }

        // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(target, INFTY)));
        vector<vector<TIII>> best(m, vector<TIII>(target, {INFTY, -1, INFTY}));

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    if (i == 0) {
                        if (k == 0) {
                            dp[i][j][k] = 0;
                        }
                    }
                    else {
                        dp[i][j][k] = dp[i - 1][j][k];
                        if (k > 0) {
                            // ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                            auto&& [first, first_idx, second] = best[i - 1][k - 1];
                            dp[i][j][k] = min(dp[i][j][k], (j == first_idx ? second : first));
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }

                    // ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                    auto&& [first, first_idx, second] = best[i][k];
                    if (dp[i][j][k] < first) {
                        second = first;
                        first = dp[i][j][k];
                        first_idx = j;
                    }
                    else if (dp[i][j][k] < second) {
                        second = dp[i][j][k];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    // æå¤§å€¼
    // é€‰æ‹© Integer.MAX_VALUE / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
    static final int INFTY = Integer.MAX_VALUE / 2;

    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        int[][][] dp = new int[m][n][target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                Arrays.fill(dp[i][j], INFTY);
            }
        }
        int[][][] best = new int[m][target][3];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < target; ++j) {
                best[i][j][0] = best[i][j][2] = INFTY;
                best[i][j][1] = -1;
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    if (i == 0) {
                        if (k == 0) {
                            dp[i][j][k] = 0;
                        }
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k];
                        if (k > 0) {
                            // ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                            int first = best[i - 1][k - 1][0];
                            int firstIdx = best[i - 1][k - 1][1];
                            int second = best[i - 1][k - 1][2];
                            dp[i][j][k] = Math.min(dp[i][j][k], (j == firstIdx ? second : first));
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }

                    // ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                    int first = best[i][k][0];
                    int firstIdx = best[i][k][1];
                    int second = best[i][k][2];
                    if (dp[i][j][k] < first) {
                        best[i][k][2] = first;
                        best[i][k][0] = dp[i][j][k];
                        best[i][k][1] = j;
                    } else if (dp[i][j][k] < second) {
                        best[i][k][2] = dp[i][j][k];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```C# [sol2-C#]
public class Solution {
    // æå¤§å€¼
    // é€‰æ‹© int.MaxValue / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
    const int INFTY = int.MaxValue / 2;

    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {
        // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        int[,,] dp = new int[m, n, target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < target; ++k) {
                    dp[i, j, k] = INFTY;
                }
            }
        }
        int[,,] best = new int[m, target, 3];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < target; ++j) {
                best[i, j, 0] = best[i, j, 2] = INFTY;
                best[i, j, 1] = -1;
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    if (i == 0) {
                        if (k == 0) {
                            dp[i, j, k] = 0;
                        }
                    } else {
                        dp[i, j, k] = dp[i - 1, j, k];
                        if (k > 0) {
                            // ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                            dp[i, j, k] = Math.Min(dp[i, j, k], (j == best[i - 1, k - 1, 1] ? best[i - 1, k - 1, 2] : best[i - 1, k - 1, 0]));
                        }
                    }

                    if (dp[i, j, k] != INFTY && houses[i] == -1) {
                        dp[i, j, k] += cost[i][j];
                    }

                    // ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                    int first = best[i, k, 0];
                    int firstIdx = best[i, k, 1];
                    int second = best[i, k, 2];
                    if (dp[i, j, k] < first) {
                        best[i, k, 2] = first;
                        best[i, k, 0] = dp[i, j, k];
                        best[i, k, 1] = j;
                    } else if (dp[i, j, k] < second) {
                        best[i, k, 2] = dp[i, j, k];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.Min(ans, dp[m - 1, j, target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```Python [sol2-Python3]
class Entry:
    def __init__(self):
        self.first = float("inf")
        self.first_idx = -1
        self.second = float("inf")

class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        # å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
        houses = [c - 1 for c in houses]

        # dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
        dp = [[[float("inf")] * target for _ in range(n)] for _ in range(m)]
        best = [[Entry() for _ in range(target)] for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if houses[i] != -1 and houses[i] != j:
                    continue
                
                for k in range(target):
                    if i == 0:
                        if k == 0:
                            dp[i][j][k] = 0
                    else:
                        dp[i][j][k] = dp[i - 1][j][k]
                        if k > 0:
                            # ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                            info = best[i - 1][k - 1]
                            dp[i][j][k] = min(dp[i][j][k], (info.second if j == info.first_idx else info.first))

                    if dp[i][j][k] != float("inf") and houses[i] == -1:
                        dp[i][j][k] += cost[i][j]
                    
                    # ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                    info = best[i][k]
                    if dp[i][j][k] < info.first:
                        info.second = info.first
                        info.first = dp[i][j][k]
                        info.first_idx = j
                    elif dp[i][j][k] < info.second:
                        info.second = dp[i][j][k]

        ans = min(dp[m - 1][j][target - 1] for j in range(n))
        return -1 if ans == float("inf") else ans
```

```go [sol2-Golang]
type entry struct {
    first, firstIdx, second int
}

func minCost(houses []int, cost [][]int, m, n, target int) int {
    const inf = math.MaxInt64 / 2 // é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º

    // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
    for i := range houses {
        houses[i]--
    }

    // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
    dp := make([][][]int, m)
    for i := range dp {
        dp[i] = make([][]int, n)
        for j := range dp[i] {
            dp[i][j] = make([]int, target)
            for k := range dp[i][j] {
                dp[i][j][k] = inf
            }
        }
    }
    best := make([][]entry, m)
    for i := range best {
        best[i] = make([]entry, target)
        for j := range best[i] {
            best[i][j] = entry{inf, -1, inf}
        }
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if houses[i] != -1 && houses[i] != j {
                continue
            }

            for k := 0; k < target; k++ {
                if i == 0 {
                    if k == 0 {
                        dp[i][j][k] = 0
                    }
                } else {
                    dp[i][j][k] = dp[i-1][j][k]
                    if k > 0 {
                        // ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                        if b := best[i-1][k-1]; j == b.firstIdx {
                            dp[i][j][k] = min(dp[i][j][k], b.second)
                        } else {
                            dp[i][j][k] = min(dp[i][j][k], b.first)
                        }
                    }
                }

                if dp[i][j][k] != inf && houses[i] == -1 {
                    dp[i][j][k] += cost[i][j]
                }

                // ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                if b := &best[i][k]; dp[i][j][k] < b.first {
                    b.second = b.first
                    b.first = dp[i][j][k]
                    b.firstIdx = j
                } else if dp[i][j][k] < b.second {
                    b.second = dp[i][j][k]
                }
            }
        }
    }

    ans := inf
    for _, res := range dp[m-1] {
        ans = min(ans, res[target-1])
    }
    if ans == inf {
        return -1
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```C [sol2-C]
struct TIII {
    int first, first_idx, second;
};

// æå¤§å€¼
// é€‰æ‹© INT_MAX / 2 çš„åŸå› æ˜¯é˜²æ­¢æ•´æ•°ç›¸åŠ æº¢å‡º
const int INFTY = 0x3f3f3f3f;

int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target) {
    // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
    for (int i = 0; i < housesSize; ++i) {
        houses[i]--;
    }

    // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
    int dp[m][n][target];
    memset(dp, 0x3f, sizeof(dp));
    struct TIII best[m][target];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < target; j++) {
            best[i][j] = (struct TIII){INFTY, -1, INFTY};
        }
    }

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (houses[i] != -1 && houses[i] != j) {
                continue;
            }

            for (int k = 0; k < target; ++k) {
                if (i == 0) {
                    if (k == 0) {
                        dp[i][j][k] = 0;
                    }
                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (k > 0) {
                        // ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                        struct TIII* tmp = &best[i - 1][k - 1];
                        dp[i][j][k] = fmin(dp[i][j][k], (j == tmp->first_idx ? tmp->second : tmp->first));
                    }
                }

                if (dp[i][j][k] != INFTY && houses[i] == -1) {
                    dp[i][j][k] += cost[i][j];
                }

                // ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                struct TIII* tmp = &best[i][k];
                if (dp[i][j][k] < tmp->first) {
                    tmp->second = tmp->first;
                    tmp->first = dp[i][j][k];
                    tmp->first_idx = j;
                } else if (dp[i][j][k] < tmp->second) {
                    tmp->second = dp[i][j][k];
                }
            }
        }
    }

    int ans = INFTY;
    for (int j = 0; j < n; ++j) {
        ans = fmin(ans, dp[m - 1][j][target - 1]);
    }
    return ans == INFTY ? -1 : ans;
}
```

```JavaScript [sol2-JavaScript]
var minCost = function(houses, cost, m, n, target) {
    const INFTY = Number.MAX_VALUE;

    // å°†é¢œè‰²è°ƒæ•´ä¸ºä» 0 å¼€å§‹ç¼–å·ï¼Œæ²¡æœ‰è¢«æ¶‚è‰²æ ‡è®°ä¸º -1
    for (let i = 0; i < m; ++i) {
        --houses[i];
    }

    // dp æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæå¤§å€¼
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0).map(() => new Array(target).fill(INFTY)));
    const best = new Array(m).fill(0).map(() => new Array(target).fill(0).map(() => new Array(3).fill(INFTY)));
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < target; ++j) {
            // best[i][j][0] = best[i][j][2] = INFTY;
            best[i][j][1] = -1;
        }
    }

    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (houses[i] !== -1 && houses[i] !== j) {
                continue;
            }

            for (let k = 0; k < target; ++k) {
                if (i === 0) {
                    if (k === 0) {
                        dp[i][j][k] = 0;
                    }
                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (k > 0) {
                        // ä½¿ç”¨ best(i-1,k-1) ç›´æ¥å¾—åˆ° dp(i,j,k) çš„å€¼
                        const first = best[i - 1][k - 1][0];
                        const firstIdx = best[i - 1][k - 1][1];
                        const second = best[i - 1][k - 1][2];
                        dp[i][j][k] = Math.min(dp[i][j][k], (j === firstIdx ? second : first));
                    }
                }

                if (dp[i][j][k] !== INFTY && houses[i] === -1) {
                    dp[i][j][k] += cost[i][j];
                }

                // ç”¨ dp(i,j,k) æ›´æ–° best(i,k)
                const first = best[i][k][0];
                const firstIdx = best[i][k][1];
                const second = best[i][k][2];
                if (dp[i][j][k] < first) {
                    best[i][k][2] = first;
                    best[i][k][0] = dp[i][j][k];
                    best[i][k][1] = j;
                } else if (dp[i][j][k] < second) {
                    best[i][k][2] = dp[i][j][k];
                }
            }
        }
    }
    let ans = INFTY;
    for (let j = 0; j < n; ++j) {
        ans = Math.min(ans, dp[m - 1][j][target - 1]);
    }
    return ans === INFTY ? -1 : ans;
};
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(m\cdot n\cdot \textit{target})$ã€‚çŠ¶æ€çš„æ•°é‡ä¸º $O(m\cdot n\cdot \textit{target})$ï¼Œæ¯ä¸ªçŠ¶æ€åªéœ€è¦ $O(1)$ çš„æ—¶é—´è¿›è¡Œè®¡ç®—ï¼ŒåŒæ—¶éœ€è¦ $O(1)$ çš„æ—¶é—´æ¥æ›´æ–° $\textit{best}$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(m\cdot n\cdot \textit{target})$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(m\cdot n \cdot \textit{target})$ï¼Œå³ä¸ºçŠ¶æ€çš„æ•°é‡ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬éœ€è¦ $O(m \cdot \textit{target})$ çš„ç©ºé—´å­˜å‚¨ $\textit{best}$ï¼Œä½†å…¶åœ¨æ¸è¿›æ„ä¹‰ä¸‹å°äºå‰è€…ï¼Œå› æ­¤å¯ä»¥å¿½ç•¥ã€‚

    ä¸æ–¹æ³•ä¸€ç›¸åŒï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–è‡³ $O(n\cdot \textit{target})$ã€‚