# 2021年05月04日 code
<a href="https://toutiao.io/k/ok4mp6n">五一假期不想人挤人？来这里！</a><br /><a href="https://toutiao.io/k/6mzds1m">系统设计之路：如何设计一个 URL 短链服务</a><br /><a href="https://toutiao.io/k/wa4mx5o">对象的可见性：volatile 篇</a><br /><a href="https://toutiao.io/k/b6wvgvt">如何借助 Proxy 代理，提升架构扩展性</a><br /><a href="https://toutiao.io/k/z7fag7p">Java 双刃剑之 Unsafe 类详解</a><br /><a href="https://toutiao.io/k/kjh5lwh">人工和自然</a><br /><a href="https://toutiao.io/k/gvwrofa">简单聊一聊 MQTT</a><br /><a href="https://toutiao.io/k/gil680k">被拉进一个刷单群，赚了 75 元：就真的只是刷单吗？</a><br /><a href="https://toutiao.io/k/bbseaei">Kotlin 内建代理</a><br /><a href="https://toutiao.io/k/ncs1rgp">如何从广度与深度衡量打包工具的好坏</a><br /><a href="https://toutiao.io/k/xkhaihd">[推荐] 协程切换会引起什么问题</a><br /><a href="https://toutiao.io/k/iwkig90">[推荐] 殷浩详解 DDD：如何避免写流水账代码？</a><br /><a href="https://toutiao.io/k/2aonyjp">[推荐] 把 Redis 当作队列来用，真的合适吗？</a><br /><a href="https://toutiao.io/k/90vs9kg">[推荐] ClickHouse 在 Bilibili 用户行为分析的实践</a><br /><a href="https://toutiao.io/k/0etokja">[推荐] Kafka：这次分享我只想把原理讲清楚</a><br /><a href="https://toutiao.io/k/j7fdh6h">[推荐] 一文搞懂分布式锁的原理与实现</a><br /><a href="https://toutiao.io/k/wxrneux">[推荐] 为什么放弃 Kafka，选择 Pulsar?</a><br /><a href="https://toutiao.io/k/a5s1rfh">[推荐] 前端哪需要自己设计页面？用现成的不就好了</a><br /><a href="https://toutiao.io/k/0iue4f4">[推荐] 2.7w 字！Java 基础面试题/知识点总结（2021 最新版）</a><br /><a href="https://toutiao.io/k/upefap5">[推荐] 程序员应该掌握的常用网络问题定位工具</a><br /><a href="https://toutiao.io/k/nrdp4oq">[推荐] 用户画像的基础、原理、方法论（模型）和应用</a><br /><a href="https://toutiao.io/k/6z3uu2m">[推荐] 如何设计一个高性能的秒杀系统</a><br /><a href="https://toutiao.io/k/fwtxydd">[推荐] 架构模式之分层架构总结</a><br /><a href="https://toutiao.io/k/08uadl6">[推荐] 书单丨“1 本抵 10 本” 的好书，建议收藏</a><br /><a href="https://toutiao.io/k/ti0gb8i">[推荐] Redis 进阶笔记</a><br /><hr /><a href="https://github.com/facebookresearch/dino">PyTorch code for Vision Transformers training with the Self-Supervised learning method DINO</a><br /><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">Bootstrap Kubernetes the hard way on Google Cloud Platform. No scripts.</a><br /><a href="https://github.com/Chia-Network/chia-blockchain">Chia blockchain python implementation (full node, farmer, harvester, timelord, and wallet)</a><br /><a href="https://github.com/login?return_to=%2Fsupabase%2Fsupabase">The open source Firebase alternative. Follow to stay updated about our public Beta.</a><br /><a href="https://github.com/bitclout/frontend">bitclout.com frontend</a><br /><a href="https://github.com/mrdbourke/tensorflow-deep-learning">All course materials for the Zero to Mastery Deep Learning with TensorFlow course.</a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/thedevdojo/wave">Wave - The Software as a Service Starter Kit, designed to help you build the SAAS of your dreams 🚀 💰</a><br /><a href="https://github.com/DIGITALCRIMINAL/OnlyFans">Scrape all the media from an OnlyFans account - Updated regularly</a><br /><a href="https://github.com/twintproject/twint">An advanced Twitter scraping & OSINT tool written in Python that doesn't use Twitter's API, allowing you to scrape a user's followers, following, Tweets and more while evading most API limitations.</a><br /><a href="https://github.com/projectdiscovery/interactsh">An OOB interaction gathering server and client library</a><br /><a href="https://github.com/androidmalware/android_hid">Use Android as Rubber Ducky against another Android device</a><br /><a href="https://github.com/commaai/openpilot">openpilot is an open source driver assistance system. openpilot performs the functions of Automated Lane Centering and Adaptive Cruise Control for over 100 supported car makes and models.</a><br /><a href="https://github.com/TheAlgorithms/Javascript">A repository for All algorithms implemented in Javascript (for educational purposes only)</a><br /><a href="https://github.com/Uniswap/uniswap-interface">🦄 An open source interface for the Uniswap protocol</a><br /><a href="https://github.com/ninjamuffin99/Funkin"></a><br /><a href="https://github.com/katherinepeterson/readme.so"></a><br /><a href="https://github.com/flashlight/flashlight">A C++ standalone library for machine learning</a><br /><a href="https://github.com/microsoft/PowerToys">Windows system utilities to maximize productivity</a><br /><a href="https://github.com/github/docs">The open-source repo for docs.github.com</a><br /><a href="https://github.com/wisz2021/jd_docker">仅用查看文档</a><br /><a href="https://github.com/CSSEGISandData/COVID-19">Novel Coronavirus (COVID-19) Cases, provided by JHU CSSE</a><br /><a href="https://github.com/vfat-tools/vfat-tools"></a><br /><a href="https://github.com/bhattbhavesh91/cowin-vaccination-slot-availability">Script to check the available slots for Covid-19 Vaccination Centers from CoWIN API in India</a><br /><a href="https://github.com/KOBA789/relly">RDBMS のしくみを学ぶための小さな RDBMS 実装</a><br /><hr />粉刷房子 III<br /><p>在一个小城市里，有&nbsp;<code>m</code>&nbsp;个房子排成一排，你需要给每个房子涂上 <code>n</code>&nbsp;种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code>&nbsp;）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p>

<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区&nbsp;<code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>

<p>给你一个数组&nbsp;<code>houses</code>&nbsp;，一个&nbsp;<code>m * n</code>&nbsp;的矩阵&nbsp;<code>cost</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;，其中：</p>

<ul>
	<li><code>houses[i]</code>：是第&nbsp;<code>i</code>&nbsp;个房子的颜色，<strong>0</strong>&nbsp;表示这个房子还没有被涂色。</li>
	<li><code>cost[i][j]</code>：是将第&nbsp;<code>i</code>&nbsp;个房子涂成颜色&nbsp;<code>j+1</code>&nbsp;的花费。</li>
</ul>

<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成&nbsp;<code>target</code>&nbsp;个街区。如果没有可用的涂色方案，请返回&nbsp;<strong>-1</strong>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>输出：</strong>9
<strong>解释：</strong>房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>输出：</strong>11
<strong>解释：</strong>有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
<strong>输出：</strong>5
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
<strong>输出：</strong>-1
<strong>解释：</strong>房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>m == houses.length == cost.length</code></li>
	<li><code>n == cost[i].length</code></li>
	<li><code>1 &lt;= m &lt;= 100</code></li>
	<li><code>1 &lt;= n &lt;= 20</code></li>
	<li><code>1 &lt;= target&nbsp;&lt;= m</code></li>
	<li><code>0 &lt;= houses[i]&nbsp;&lt;= n</code></li>
	<li><code>1 &lt;= cost[i][j] &lt;= 10^4</code></li>
</ul>
<br />#### 前言

为了叙述方便，我们令所有的变量都从 $0$ 开始编号，即：

- 房子的编号为 $[0, m-1]$；
- 颜色的编号为 $[0, n-1]$，如果房子没有涂上颜色，那么记为 $-1$；
- 街区的编号为 $[0, \textit{target}-1]$。

#### 方法一：动态规划

**思路与算法**

我们可以使用动态规划解决本题。

设 $\textit{dp}(i,j,k)$ 表示将 $[0, i]$ 的房子都涂上颜色，最末尾的第 $i$ 个房子的颜色为 $j$，并且它属于第 $k$ 个街区时，需要的最少花费。

在进行状态转移时，我们需要考虑「第 $i-1$ 个房子的颜色」，这关系到「花费」以及「街区数量」的计算，因此我们还需要对其进行枚举。

设第 $i-1$ 个房子的颜色为 $j_0$，我们可以分类讨论出不同情况下的状态转移方程：

- 如果 $\textit{houses}[i] \neq -1$，说明第 $i$ 个房子已经涂过颜色了。由于我们不能重复涂色，那么必须有 $\textit{houses}[i] = j$。我们可以写出在 $\textit{houses}[i] \neq j$ 时的状态转移方程：

    $$
    \textit{dp}(i, j, k) = \infty, \quad 如果~\textit{houses}[i] \neq -1~并且~\textit{houses}[i] \neq j
    $$

    这里我们用极大值 $\infty$ 表示不满足要求的状态，由于我们需要求出的是最少花费，因此极大值不会对状态转移产生影响。

    当 $\textit{houses}[i] = j$ 时，如果 $j=j_0$，那么第 $i-1$ 个房子和第 $i$ 个房子属于同一个街区，状态转移方程为：

    $$
    \textit{dp}(i, j, k) = \textit{dp}(i-1, j, k), \quad 如果~ \textit{houses}[i] = j
    $$

    如果 $j \neq j_0$，那么它们属于不同的街区，状态转移方程为：

    $$
    \textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1), \quad 如果~ \textit{houses}[i] = j
    $$

- 如果 $\textit{houses}[i] = -1$，说明我们需要将第 $i$ 个房子涂成颜色 $j$，花费为 $\textit{cost}[i][j]$。

    此外的状态转移与上一类情况类似。如果 $j = j_0$，那么状态转移方程为：

    $$
    \textit{dp}(i, j, k) = \textit{dp}(i-1, j, k) + \textit{cost}[i][j], \quad 如果~\textit{houses}[i]=-1
    $$

    如果 $j \neq j_0$，那么状态转移方程为：

    $$
    \textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1) + \textit{cost}[i][j], \quad 如果~\textit{houses}[i]=-1
    $$

最终的答案即为 $\min\limits_{j} \textit{dp}(m-1, j, \textit{target} - 1)$。

**细节**

以下的细节有助于写出更简洁的代码：

- 我们可以将所有的状态初始化为 $\infty$。在进行状态转移时，我们是选择转移中的最小值，因此 $\infty$ 不会产生影响；

- 两类情况下的状态转移方程十分类似，因此我们可以先不去管 $\textit{cost}[i][j]$ 的部分，在求出 $\textit{dp}(i, j, k)$ 的最小值之后，如果发现 $\textit{houses}[i]=-1$，再加上 $\textit{cost}[i][j]$ 即可；

- 当 $k=0$ 时，不能从包含 $k-1$ 的状态转移而来；

- 当 $i=0$ 时，第 $0$ 个房子之前没有房子，因此 $k$ 也必须为 $0$。此时状态转移方程为：

    $$
    \textit{dp}(0, j, 0) = \left\{ \begin{aligned}
    & \infty, && 如果~\textit{houses}[i] \neq -1 ~并且~\textit{houses}[i] \neq j \\
    & 0, && 如果~\textit{houses}[i] \neq -1 ~并且~\textit{houses}[i] = j \\
    & \textit{cost}[i][j], && 如果~\textit{houses}[i]=-1
    \end{aligned} \right.
    $$

    当 $i=0$ 且 $k \neq 0$ 时，$\textit{dp}(0, j, k) = \infty$。

**代码**

```C++ [sol1-C++]
class Solution {
private:
    // 极大值
    // 选择 INT_MAX / 2 的原因是防止整数相加溢出
    static constexpr int INFTY = INT_MAX / 2;

public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        for (int& c: houses) {
            --c;
        }

        // dp 所有元素初始化为极大值
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(target, INFTY)));

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    for (int j0 = 0; j0 < n; ++j0) {
                        if (j == j0) {
                            if (i == 0) {
                                if (k == 0) {
                                    dp[i][j][k] = 0;
                                }
                            }
                            else {
                                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k]);
                            }
                        }
                        else if (i > 0 && k > 0) {
                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j0][k - 1]);
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    // 极大值
    // 选择 Integer.MAX_VALUE / 2 的原因是防止整数相加溢出
    static final int INFTY = Integer.MAX_VALUE / 2;

    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp 所有元素初始化为极大值
        int[][][] dp = new int[m][n][target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                Arrays.fill(dp[i][j], INFTY);
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    for (int j0 = 0; j0 < n; ++j0) {
                        if (j == j0) {
                            if (i == 0) {
                                if (k == 0) {
                                    dp[i][j][k] = 0;
                                }
                            } else {
                                dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);
                            }
                        } else if (i > 0 && k > 0) {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]);
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```C# [sol1-C#]
public class Solution {
    // 极大值
    // 选择 int.MaxValue / 2 的原因是防止整数相加溢出
    const int INFTY = int.MaxValue / 2;

    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {
        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp 所有元素初始化为极大值
        int[,,] dp = new int[m, n, target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < target; ++k) {
                    dp[i, j, k] = INFTY;
                }
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    for (int j0 = 0; j0 < n; ++j0) {
                        if (j == j0) {
                            if (i == 0) {
                                if (k == 0) {
                                    dp[i, j, k] = 0;
                                }
                            } else {
                                dp[i, j, k] = Math.Min(dp[i, j, k], dp[i - 1, j, k]);
                            }
                        } else if (i > 0 && k > 0) {
                            dp[i, j, k] = Math.Min(dp[i, j, k], dp[i - 1, j0, k - 1]);
                        }
                    }

                    if (dp[i, j, k] != INFTY && houses[i] == -1) {
                        dp[i, j, k] += cost[i][j];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.Min(ans, dp[m - 1, j, target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        # 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        houses = [c - 1 for c in houses]

        # dp 所有元素初始化为极大值
        dp = [[[float("inf")] * target for _ in range(n)] for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if houses[i] != -1 and houses[i] != j:
                    continue
                
                for k in range(target):
                    for j0 in range(n):
                        if j == j0:
                            if i == 0:
                                if k == 0:
                                    dp[i][j][k] = 0
                            else:
                                dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])
                        elif i > 0 and k > 0:
                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j0][k - 1])

                    if dp[i][j][k] != float("inf") and houses[i] == -1:
                        dp[i][j][k] += cost[i][j]

        ans = min(dp[m - 1][j][target - 1] for j in range(n))
        return -1 if ans == float("inf") else ans
```

```JavaScript [sol1-JavaScript]
var minCost = function(houses, cost, m, n, target) {
    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
    houses = houses.map(c => --c);
    const dp = new Array(m).fill(0)
                           .map(() => new Array(n).fill(0)
                           .map(() => new Array(target).fill(Number.MAX_VALUE)));
    
    // dp 所有元素初始化为极大值
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (houses[i] !== -1 && houses[i] !== j) {
                continue;
            }
            
            for (let k = 0; k < target; ++k) {
                for (let j0 = 0; j0 < n; ++j0) {
                    if (j === j0) {
                        if (i === 0) {
                            if (k === 0) {
                                dp[i][j][k] = 0;
                            }
                        } else {
                            dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j][k]);
                        }
                    } else if (i > 0 && k > 0) {
                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i - 1][j0][k - 1]);
                    }
                }

                if (dp[i][j][k] !== Number.MAX_VALUE && houses[i] === -1) {
                    dp[i][j][k] += cost[i][j];
                }
            }
        }
    }
    
    let ans = Number.MAX_VALUE;
    for (let j = 0; j < n; ++j) {
        ans = Math.min(ans, dp[m - 1][j][target - 1]);
    }
    return ans === Number.MAX_VALUE ? -1 : ans;
};
```

```go [sol1-Golang]
func minCost(houses []int, cost [][]int, m, n, target int) int {
    const inf = math.MaxInt64 / 2 // 防止整数相加溢出

    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
    for i := range houses {
        houses[i]--
    }

    // dp 所有元素初始化为极大值
    dp := make([][][]int, m)
    for i := range dp {
        dp[i] = make([][]int, n)
        for j := range dp[i] {
            dp[i][j] = make([]int, target)
            for k := range dp[i][j] {
                dp[i][j][k] = inf
            }
        }
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if houses[i] != -1 && houses[i] != j {
                continue
            }

            for k := 0; k < target; k++ {
                for j0 := 0; j0 < n; j0++ {
                    if j == j0 {
                        if i == 0 {
                            if k == 0 {
                                dp[i][j][k] = 0
                            }
                        } else {
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k])
                        }
                    } else if i > 0 && k > 0 {
                        dp[i][j][k] = min(dp[i][j][k], dp[i-1][j0][k-1])
                    }
                }

                if dp[i][j][k] != inf && houses[i] == -1 {
                    dp[i][j][k] += cost[i][j]
                }
            }
        }
    }

    ans := inf
    for _, res := range dp[m-1] {
        ans = min(ans, res[target-1])
    }
    if ans == inf {
        return -1
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```C [sol1-C]
// 极大值
// 选择 INT_MAX / 2 的原因是防止整数相加溢出
const int INFTY = 0x3f3f3f3f;

int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target) {
    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
    for (int i = 0; i < housesSize; ++i) {
        houses[i]--;
    }

    // dp 所有元素初始化为极大值
    int dp[m][n][target];
    memset(dp, 0x3f, sizeof(dp));

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (houses[i] != -1 && houses[i] != j) {
                continue;
            }

            for (int k = 0; k < target; ++k) {
                for (int j0 = 0; j0 < n; ++j0) {
                    if (j == j0) {
                        if (i == 0) {
                            if (k == 0) {
                                dp[i][j][k] = 0;
                            }
                        } else {
                            dp[i][j][k] = fmin(dp[i][j][k], dp[i - 1][j][k]);
                        }
                    } else if (i > 0 && k > 0) {
                        dp[i][j][k] = fmin(dp[i][j][k], dp[i - 1][j0][k - 1]);
                    }
                }

                if (dp[i][j][k] != INFTY && houses[i] == -1) {
                    dp[i][j][k] += cost[i][j];
                }
            }
        }
    }

    int ans = INFTY;
    for (int j = 0; j < n; ++j) {
        ans = fmin(ans, dp[m - 1][j][target - 1]);
    }
    return ans == INFTY ? -1 : ans;
}
```

**复杂度分析**

- 时间复杂度：$O(m\cdot n^2\cdot \textit{target})$。状态的数量为 $O(m\cdot n\cdot \textit{target})$，每个状态需要 $O(n)$ 的时间枚举 $j_0$，因此总时间复杂度为 $O(m\cdot n^2\cdot \textit{target})$。

- 空间复杂度：$O(m \cdot n \cdot \textit{target})$，即为状态的数量。

    注意到 $\textit{dp}(i,j,k)$ 只会从 $\textit{dp}(i-1, \cdots, \cdots)$ 转移而来，因此我们可以使用滚动数组对空间复杂度进行优化，即使用两个大小为 $n \cdot \textit{target}$ 的数组 $\textit{dp}_1$, $\textit{dp}_2$，将 $dp(0,j,k)$ 的值存储在 $\textit{dp}_1$ 中，将 $dp(1,j,k)$ 的值存储在 $\textit{dp}_2$ 中，将 $dp(2,j,k)$ 的值存储在 $\textit{dp}_1$ 中，将 $dp(3,j,k)$ 的值存储在 $\textit{dp}_2$ 中，以此类推。这样优化后的空间复杂度为 $O(n\cdot \textit{target})$。


#### 方法二：动态规划 + 优化

**思路与算法**

在方法一中，我们分类讨论出了五种不同的状态转移方程，其中有三种是可以在 $O(1)$ 的时间进行状态转移的，而剩余的两种需要枚举 $j_0$，只能在 $O(n)$ 的时间进行转移，即：

$$
\textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1), \quad 如果~ \textit{houses}[i] = j
$$

以及：

$$
\textit{dp}(i, j, k) = \min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1) + \textit{cost}[i][j], \quad 如果~\textit{houses}[i]=-1
$$

如果我们能将它们优化至 $O(1)$，那么整个动态规划的时间复杂度也可以从 $O(m\cdot n^2\cdot \textit{target})$ 优化至 $O(m \cdot n \cdot \textit{target})$。

我们可以令 $\textit{best}(i, k) = (\textit{first}, \textit{first\_idx}, \textit{second})$，表示所有的状态 $dp(i, j, k)$ 中的最小值为 $\textit{first}$，取到最小值对应的 $j$ 值为 $\textit{first\_idx}$，次小值为 $\textit{second}$。这里 $j$ 可以在 $[0, n)$ 中任意选择，但我们只记录最大值和次大值，以及最大值对应的 $j$。

这样做的好处在于我们可以快速地求出原先需要 $O(n)$ 的时间才能求出的：

$$
\min_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1)
$$

这一项。即：

- 我们取出 $\textit{best}(i - 1, k - 1)$，它包含的三个值为 $(\textit{first}, \textit{first\_idx}, \textit{second})$；

- 如果 $j = \textit{first\_idx}$，那么 $\textit{dp}(i, j, k) = \textit{second}$；

- 如果 $j \neq \textit{first\_idx}$，那么 $\textit{dp}(i, j, k) = \textit{first}$。

这样做的正确性通过 $\min\limits_{j_0 \neq j} \textit{dp}(i-1,j_0, k-1)$ 本身的定义就能体现。

那么如何求出 $\textit{best}(i, k)$ 呢？我们可以给每一个 $\textit{best}(i, k)$ 赋予初始值 $(\infty, -1, \infty)$，每次我们计算出 $\textit{dp}(i, j, k)$ 时，使用其更新 $\textit{best}(i, k)$ 即可。

**代码**

方法二的代码较为复杂，主要的原因在于我们需要将方法一中的 $O(n)$ 枚举 $j_0$ 的循环删除，并且需要保持方法一中的边界条件不变。

```C++ [sol2-C++]
class Solution {
private:
    // 极大值
    // 选择 INT_MAX / 2 的原因是防止整数相加溢出
    static constexpr int INFTY = INT_MAX / 2;

    using TIII = tuple<int, int, int>;

public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) {
        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        for (int& c: houses) {
            --c;
        }

        // dp 所有元素初始化为极大值
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(target, INFTY)));
        vector<vector<TIII>> best(m, vector<TIII>(target, {INFTY, -1, INFTY}));

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    if (i == 0) {
                        if (k == 0) {
                            dp[i][j][k] = 0;
                        }
                    }
                    else {
                        dp[i][j][k] = dp[i - 1][j][k];
                        if (k > 0) {
                            // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                            auto&& [first, first_idx, second] = best[i - 1][k - 1];
                            dp[i][j][k] = min(dp[i][j][k], (j == first_idx ? second : first));
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }

                    // 用 dp(i,j,k) 更新 best(i,k)
                    auto&& [first, first_idx, second] = best[i][k];
                    if (dp[i][j][k] < first) {
                        second = first;
                        first = dp[i][j][k];
                        first_idx = j;
                    }
                    else if (dp[i][j][k] < second) {
                        second = dp[i][j][k];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    // 极大值
    // 选择 Integer.MAX_VALUE / 2 的原因是防止整数相加溢出
    static final int INFTY = Integer.MAX_VALUE / 2;

    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp 所有元素初始化为极大值
        int[][][] dp = new int[m][n][target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                Arrays.fill(dp[i][j], INFTY);
            }
        }
        int[][][] best = new int[m][target][3];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < target; ++j) {
                best[i][j][0] = best[i][j][2] = INFTY;
                best[i][j][1] = -1;
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    if (i == 0) {
                        if (k == 0) {
                            dp[i][j][k] = 0;
                        }
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k];
                        if (k > 0) {
                            // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                            int first = best[i - 1][k - 1][0];
                            int firstIdx = best[i - 1][k - 1][1];
                            int second = best[i - 1][k - 1][2];
                            dp[i][j][k] = Math.min(dp[i][j][k], (j == firstIdx ? second : first));
                        }
                    }

                    if (dp[i][j][k] != INFTY && houses[i] == -1) {
                        dp[i][j][k] += cost[i][j];
                    }

                    // 用 dp(i,j,k) 更新 best(i,k)
                    int first = best[i][k][0];
                    int firstIdx = best[i][k][1];
                    int second = best[i][k][2];
                    if (dp[i][j][k] < first) {
                        best[i][k][2] = first;
                        best[i][k][0] = dp[i][j][k];
                        best[i][k][1] = j;
                    } else if (dp[i][j][k] < second) {
                        best[i][k][2] = dp[i][j][k];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.min(ans, dp[m - 1][j][target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```C# [sol2-C#]
public class Solution {
    // 极大值
    // 选择 int.MaxValue / 2 的原因是防止整数相加溢出
    const int INFTY = int.MaxValue / 2;

    public int MinCost(int[] houses, int[][] cost, int m, int n, int target) {
        // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        for (int i = 0; i < m; ++i) {
            --houses[i];
        }

        // dp 所有元素初始化为极大值
        int[,,] dp = new int[m, n, target];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < target; ++k) {
                    dp[i, j, k] = INFTY;
                }
            }
        }
        int[,,] best = new int[m, target, 3];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < target; ++j) {
                best[i, j, 0] = best[i, j, 2] = INFTY;
                best[i, j, 1] = -1;
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (houses[i] != -1 && houses[i] != j) {
                    continue;
                }
                
                for (int k = 0; k < target; ++k) {
                    if (i == 0) {
                        if (k == 0) {
                            dp[i, j, k] = 0;
                        }
                    } else {
                        dp[i, j, k] = dp[i - 1, j, k];
                        if (k > 0) {
                            // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                            dp[i, j, k] = Math.Min(dp[i, j, k], (j == best[i - 1, k - 1, 1] ? best[i - 1, k - 1, 2] : best[i - 1, k - 1, 0]));
                        }
                    }

                    if (dp[i, j, k] != INFTY && houses[i] == -1) {
                        dp[i, j, k] += cost[i][j];
                    }

                    // 用 dp(i,j,k) 更新 best(i,k)
                    int first = best[i, k, 0];
                    int firstIdx = best[i, k, 1];
                    int second = best[i, k, 2];
                    if (dp[i, j, k] < first) {
                        best[i, k, 2] = first;
                        best[i, k, 0] = dp[i, j, k];
                        best[i, k, 1] = j;
                    } else if (dp[i, j, k] < second) {
                        best[i, k, 2] = dp[i, j, k];
                    }
                }
            }
        }

        int ans = INFTY;
        for (int j = 0; j < n; ++j) {
            ans = Math.Min(ans, dp[m - 1, j, target - 1]);
        }
        return ans == INFTY ? -1 : ans;
    }
}
```

```Python [sol2-Python3]
class Entry:
    def __init__(self):
        self.first = float("inf")
        self.first_idx = -1
        self.second = float("inf")

class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        # 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
        houses = [c - 1 for c in houses]

        # dp 所有元素初始化为极大值
        dp = [[[float("inf")] * target for _ in range(n)] for _ in range(m)]
        best = [[Entry() for _ in range(target)] for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if houses[i] != -1 and houses[i] != j:
                    continue
                
                for k in range(target):
                    if i == 0:
                        if k == 0:
                            dp[i][j][k] = 0
                    else:
                        dp[i][j][k] = dp[i - 1][j][k]
                        if k > 0:
                            # 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                            info = best[i - 1][k - 1]
                            dp[i][j][k] = min(dp[i][j][k], (info.second if j == info.first_idx else info.first))

                    if dp[i][j][k] != float("inf") and houses[i] == -1:
                        dp[i][j][k] += cost[i][j]
                    
                    # 用 dp(i,j,k) 更新 best(i,k)
                    info = best[i][k]
                    if dp[i][j][k] < info.first:
                        info.second = info.first
                        info.first = dp[i][j][k]
                        info.first_idx = j
                    elif dp[i][j][k] < info.second:
                        info.second = dp[i][j][k]

        ans = min(dp[m - 1][j][target - 1] for j in range(n))
        return -1 if ans == float("inf") else ans
```

```go [sol2-Golang]
type entry struct {
    first, firstIdx, second int
}

func minCost(houses []int, cost [][]int, m, n, target int) int {
    const inf = math.MaxInt64 / 2 // 防止整数相加溢出

    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
    for i := range houses {
        houses[i]--
    }

    // dp 所有元素初始化为极大值
    dp := make([][][]int, m)
    for i := range dp {
        dp[i] = make([][]int, n)
        for j := range dp[i] {
            dp[i][j] = make([]int, target)
            for k := range dp[i][j] {
                dp[i][j][k] = inf
            }
        }
    }
    best := make([][]entry, m)
    for i := range best {
        best[i] = make([]entry, target)
        for j := range best[i] {
            best[i][j] = entry{inf, -1, inf}
        }
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if houses[i] != -1 && houses[i] != j {
                continue
            }

            for k := 0; k < target; k++ {
                if i == 0 {
                    if k == 0 {
                        dp[i][j][k] = 0
                    }
                } else {
                    dp[i][j][k] = dp[i-1][j][k]
                    if k > 0 {
                        // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                        if b := best[i-1][k-1]; j == b.firstIdx {
                            dp[i][j][k] = min(dp[i][j][k], b.second)
                        } else {
                            dp[i][j][k] = min(dp[i][j][k], b.first)
                        }
                    }
                }

                if dp[i][j][k] != inf && houses[i] == -1 {
                    dp[i][j][k] += cost[i][j]
                }

                // 用 dp(i,j,k) 更新 best(i,k)
                if b := &best[i][k]; dp[i][j][k] < b.first {
                    b.second = b.first
                    b.first = dp[i][j][k]
                    b.firstIdx = j
                } else if dp[i][j][k] < b.second {
                    b.second = dp[i][j][k]
                }
            }
        }
    }

    ans := inf
    for _, res := range dp[m-1] {
        ans = min(ans, res[target-1])
    }
    if ans == inf {
        return -1
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

```C [sol2-C]
struct TIII {
    int first, first_idx, second;
};

// 极大值
// 选择 INT_MAX / 2 的原因是防止整数相加溢出
const int INFTY = 0x3f3f3f3f;

int minCost(int* houses, int housesSize, int** cost, int costSize, int* costColSize, int m, int n, int target) {
    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
    for (int i = 0; i < housesSize; ++i) {
        houses[i]--;
    }

    // dp 所有元素初始化为极大值
    int dp[m][n][target];
    memset(dp, 0x3f, sizeof(dp));
    struct TIII best[m][target];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < target; j++) {
            best[i][j] = (struct TIII){INFTY, -1, INFTY};
        }
    }

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (houses[i] != -1 && houses[i] != j) {
                continue;
            }

            for (int k = 0; k < target; ++k) {
                if (i == 0) {
                    if (k == 0) {
                        dp[i][j][k] = 0;
                    }
                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (k > 0) {
                        // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                        struct TIII* tmp = &best[i - 1][k - 1];
                        dp[i][j][k] = fmin(dp[i][j][k], (j == tmp->first_idx ? tmp->second : tmp->first));
                    }
                }

                if (dp[i][j][k] != INFTY && houses[i] == -1) {
                    dp[i][j][k] += cost[i][j];
                }

                // 用 dp(i,j,k) 更新 best(i,k)
                struct TIII* tmp = &best[i][k];
                if (dp[i][j][k] < tmp->first) {
                    tmp->second = tmp->first;
                    tmp->first = dp[i][j][k];
                    tmp->first_idx = j;
                } else if (dp[i][j][k] < tmp->second) {
                    tmp->second = dp[i][j][k];
                }
            }
        }
    }

    int ans = INFTY;
    for (int j = 0; j < n; ++j) {
        ans = fmin(ans, dp[m - 1][j][target - 1]);
    }
    return ans == INFTY ? -1 : ans;
}
```

```JavaScript [sol2-JavaScript]
var minCost = function(houses, cost, m, n, target) {
    const INFTY = Number.MAX_VALUE;

    // 将颜色调整为从 0 开始编号，没有被涂色标记为 -1
    for (let i = 0; i < m; ++i) {
        --houses[i];
    }

    // dp 所有元素初始化为极大值
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0).map(() => new Array(target).fill(INFTY)));
    const best = new Array(m).fill(0).map(() => new Array(target).fill(0).map(() => new Array(3).fill(INFTY)));
    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < target; ++j) {
            // best[i][j][0] = best[i][j][2] = INFTY;
            best[i][j][1] = -1;
        }
    }

    for (let i = 0; i < m; ++i) {
        for (let j = 0; j < n; ++j) {
            if (houses[i] !== -1 && houses[i] !== j) {
                continue;
            }

            for (let k = 0; k < target; ++k) {
                if (i === 0) {
                    if (k === 0) {
                        dp[i][j][k] = 0;
                    }
                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (k > 0) {
                        // 使用 best(i-1,k-1) 直接得到 dp(i,j,k) 的值
                        const first = best[i - 1][k - 1][0];
                        const firstIdx = best[i - 1][k - 1][1];
                        const second = best[i - 1][k - 1][2];
                        dp[i][j][k] = Math.min(dp[i][j][k], (j === firstIdx ? second : first));
                    }
                }

                if (dp[i][j][k] !== INFTY && houses[i] === -1) {
                    dp[i][j][k] += cost[i][j];
                }

                // 用 dp(i,j,k) 更新 best(i,k)
                const first = best[i][k][0];
                const firstIdx = best[i][k][1];
                const second = best[i][k][2];
                if (dp[i][j][k] < first) {
                    best[i][k][2] = first;
                    best[i][k][0] = dp[i][j][k];
                    best[i][k][1] = j;
                } else if (dp[i][j][k] < second) {
                    best[i][k][2] = dp[i][j][k];
                }
            }
        }
    }
    let ans = INFTY;
    for (let j = 0; j < n; ++j) {
        ans = Math.min(ans, dp[m - 1][j][target - 1]);
    }
    return ans === INFTY ? -1 : ans;
};
```

**复杂度分析**

- 时间复杂度：$O(m\cdot n\cdot \textit{target})$。状态的数量为 $O(m\cdot n\cdot \textit{target})$，每个状态只需要 $O(1)$ 的时间进行计算，同时需要 $O(1)$ 的时间来更新 $\textit{best}$，因此总时间复杂度为 $O(m\cdot n\cdot \textit{target})$。

- 空间复杂度：$O(m\cdot n \cdot \textit{target})$，即为状态的数量。除此之外，我们需要 $O(m \cdot \textit{target})$ 的空间存储 $\textit{best}$，但其在渐进意义下小于前者，因此可以忽略。

    与方法一相同，我们也可以将空间复杂度优化至 $O(n\cdot \textit{target})$。