# 2021å¹´05æœˆ16æ—¥ code
<a href="https://toutiao.io/k/9yex08q">æˆ‘æŠŠè¿™ä¸ªè½¯ä»¶ï¼Œæ¨èç»™äº†æ€»ç›‘</a><br /><a href="https://toutiao.io/k/5ga4hr7">ç”¨ Go å®ç°é…ç½®ä¸­å¿ƒï¼ˆä¸€ï¼‰</a><br /><a href="https://toutiao.io/k/jggpayh">å®ç°æ— é™ç¼“å­˜çš„ channel</a><br /><a href="https://toutiao.io/k/8ee5tsg">Java å¹¶å‘å·¥å…·ç¯‡</a><br /><a href="https://toutiao.io/k/o9vzo5r">2021 Java åç«¯å®ä¹ æ˜¥æ‹›é¢è¯•é¢˜æ•´ç†ï¼ˆå«ç­”æ¡ˆï¼‰</a><br /><a href="https://toutiao.io/k/38r8iaa">nocode å’Œ lowcode</a><br /><a href="https://toutiao.io/k/22qf866">åœ¨ RecyclerView ä¸­ä½¿ç”¨ ListAdapter</a><br /><a href="https://toutiao.io/k/sdn01ho">æ‹’ç»åçŸ¥åè§‰ï¼Œåˆ†æå¸ˆä¸»åŠ¨ç ´å±€ä¹‹è·¯</a><br /><a href="https://toutiao.io/k/na9v8qi">Golang è°ƒåº¦æ¨¡å‹</a><br /><a href="https://toutiao.io/k/7rpkxbw">è®ºæ–‡ï½œDeepWalk çš„ç®—æ³•åŸç†ã€ä»£ç å®ç°å’Œåº”ç”¨è¯´æ˜</a><br /><a href="https://toutiao.io/k/bjis3t4">[æ¨è] 36 å¼ å›¾è¯¦è§£ç½‘ç»œåŸºç¡€çŸ¥è¯†</a><br /><a href="https://toutiao.io/k/7v2gnx6">[æ¨è] ç¨‹åºå‘˜å¿…å¤‡åŸºç¡€ï¼š10 ç§å¸¸è§å®‰å…¨æ¼æ´æµ…æ</a><br /><a href="https://toutiao.io/k/xdsox3x">[æ¨è] æ’¸ä»£ç å‰ï¼Œå†™ä¸‹è®¾è®¡æ–¹æ¡ˆ</a><br /><a href="https://toutiao.io/k/gs6z30z">[æ¨è] è½»è½»æ¾æ¾æ‰“å°ç½‘é¡µå¹¶ç”Ÿæˆ pdf æ–‡æ¡£</a><br /><a href="https://toutiao.io/k/4fpatsr">[æ¨è] [è¯‘] Linux ç³»ç»Ÿå®‰å…¨å¼ºåŒ–æŒ‡å—</a><br /><a href="https://toutiao.io/k/nkx9rki">[æ¨è] æˆ‘è®¤ä¸ºæœ€ä¼˜ç¾çš„æ•°æ®ç»“æ„</a><br /><a href="https://toutiao.io/k/ss8h91v">[æ¨è] æ¶æ„å¸ˆå¿…çœ‹ï¼šæ¶æ„è®¾è®¡çš„å››å¤§æ€ç»´æ”¯æŸ±</a><br /><a href="https://toutiao.io/k/2tnj5np">[æ¨è] RabbitMQã€Kafkaã€RocketMQ æ˜¯å¦‚ä½•å®ç°é«˜å¯ç”¨çš„ï¼Ÿ</a><br /><a href="https://toutiao.io/k/6mzds1m">[æ¨è] ç³»ç»Ÿè®¾è®¡ä¹‹è·¯ï¼šå¦‚ä½•è®¾è®¡ä¸€ä¸ª URL çŸ­é“¾æœåŠ¡</a><br /><a href="https://toutiao.io/k/ca8fe6d">[æ¨è] åŠç‚¸å¤©çš„ Docker å›¾å½¢åŒ–å·¥å…· Portainerï¼Œå¿…é¡»æ¨èç»™ä½ </a><br /><a href="https://toutiao.io/k/4sywkcm">[æ¨è] å¾®æœåŠ¡è®¾è®¡åŸåˆ™</a><br /><a href="https://toutiao.io/k/k1o0w99">[æ¨è] å“ˆå•°åœ¨åˆ†å¸ƒå¼æ¶ˆæ¯æ²»ç†å’Œå¾®æœåŠ¡æ²»ç†ä¸­çš„å®è·µ</a><br /><a href="https://toutiao.io/k/gc13z71">[æ¨è] æ•°æ®åˆ†æåå¹´ï¼Œæˆ‘åªæ¨èè¿™äº›ä¹¦</a><br /><hr /><a href="https://github.com/login?return_to=%2Fsyncthing%2Fsyncthing">Open Source Continuous File Synchronization</a><br /><a href="https://github.com/ossrs/srs">SRS is a simple, high efficiency and realtime video server, supports RTMP/WebRTC/HLS/HTTP-FLV/SRT/GB28181.</a><br /><a href="https://github.com/ExpressLRS/ExpressLRS">STM32/ESP32/ESP8285 based High Performance Radio Link for Quads</a><br /><a href="https://github.com/trustwallet/assets">A comprehensive, up-to-date collection of information about several thousands (!) of crypto tokens.</a><br /><a href="https://github.com/positive-security/send-my">Upload arbitrary data via Apple's Find My network.</a><br /><a href="https://github.com/makenotion/notion-sdk-js"></a><br /><a href="https://github.com/AllThingsSmitty/css-protips">A collection of tips to help take your CSS skills pro</a><br /><a href="https://github.com/awslabs/aws-saas-boost"></a><br /><a href="https://github.com/dogecoin/dogecoin">very currency</a><br /><a href="https://github.com/login?return_to=%2Fthedaviddias%2FFront-End-Checklist">ğŸ—‚ The perfect Front-End Checklist for modern websites and meticulous developers</a><br /><a href="https://github.com/intel-isl/PhotorealismEnhancement">Code & Data for Enhancing Photorealism Enhancement</a><br /><a href="https://github.com/login?return_to=%2Fdarylhjd%2Fmangadesk">Terminal client for MangaDex ğŸ“–</a><br /><a href="https://github.com/monk-coder/dust">ç¹å ä¸è¿‡ä¸€æ¬ç»†æ²™</a><br /><a href="https://github.com/h5bp/html5-boilerplate">A professional front-end template for building fast, robust, and adaptable web apps or sites.</a><br /><a href="https://github.com/apache/shardingsphere">Distributed Database Ecosphere</a><br /><a href="https://github.com/OWASP/CheatSheetSeries">The OWASP Cheat Sheet Series was created to provide a concise collection of high value information on specific application security topics.</a><br /><a href="https://github.com/tuvtran/project-based-learning">Curated list of project-based tutorials</a><br /><a href="https://github.com/dromara/sa-token">è¿™å¯èƒ½æ˜¯å²ä¸ŠåŠŸèƒ½æœ€å…¨çš„Javaæƒé™è®¤è¯æ¡†æ¶ï¼ç›®å‰å·²é›†æˆâ€”â€”ç™»å½•è®¤è¯ã€æƒé™è®¤è¯ã€åˆ†å¸ƒå¼Sessionä¼šè¯ã€å¾®æœåŠ¡ç½‘å…³é‰´æƒã€å•ç‚¹ç™»å½•ã€OAuth2.0ã€è¸¢äººä¸‹çº¿ã€Redisé›†æˆã€å‰åå°åˆ†ç¦»ã€è®°ä½æˆ‘æ¨¡å¼ã€æ¨¡æ‹Ÿä»–äººè´¦å·ã€ä¸´æ—¶èº«ä»½åˆ‡æ¢ã€è´¦å·å°ç¦ã€å¤šè´¦å·è®¤è¯ä½“ç³»ã€æ³¨è§£å¼é‰´æƒã€è·¯ç”±æ‹¦æˆªå¼é‰´æƒã€èŠ±å¼tokenç”Ÿæˆã€è‡ªåŠ¨ç»­ç­¾ã€åŒç«¯äº’æ–¥ç™»å½•ã€ä¼šè¯æ²»ç†ã€å¯†ç åŠ å¯†ã€jwté›†æˆã€Springé›†æˆã€WebFluxé›†æˆ...</a><br /><a href="https://github.com/login?return_to=%2Fswar%2FSwar-Chia-Plot-Manager">This is a Cross-Platform Plot Manager for Chia Plotting that is simple, easy-to-use, and reliable.</a><br /><a href="https://github.com/JanVanRyswyck/awesome-talks">Awesome online talks and screencasts</a><br /><a href="https://github.com/google/leveldb">LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.</a><br /><a href="https://github.com/paritytech/substrate">Substrate: The platform for blockchain innovators</a><br /><a href="https://github.com/goldbergyoni/nodebestpractices">âœ… The Node.js best practices list (May 2021)</a><br /><a href="https://github.com/facebook/folly">An open-source C++ library developed and used at Facebook.</a><br /><a href="https://github.com/apache/thrift">Apache Thrift</a><br /><hr />æ•°ç»„ä¸­ä¸¤ä¸ªæ•°çš„æœ€å¤§å¼‚æˆ–å€¼<br /><p>ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ <code>nums</code> ï¼Œè¿”å›<em> </em><code>nums[i] XOR nums[j]</code> çš„æœ€å¤§è¿ç®—ç»“æœï¼Œå…¶ä¸­ <code>0 â‰¤ i â‰¤ j < n</code> ã€‚</p>

<p><strong>è¿›é˜¶ï¼š</strong>ä½ å¯ä»¥åœ¨ <code>O(n)</code> çš„æ—¶é—´è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ</p>

<p>Â </p>

<div class="original__bRMd">
<div>
<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [3,10,5,25,2,8]
<strong>è¾“å‡ºï¼š</strong>28
<strong>è§£é‡Šï¼š</strong>æœ€å¤§è¿ç®—ç»“æœæ˜¯ 5 XOR 25 = 28.</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [0]
<strong>è¾“å‡ºï¼š</strong>0
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [2,4]
<strong>è¾“å‡ºï¼š</strong>6
</pre>

<p><strong>ç¤ºä¾‹ 4ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [8,10,2]
<strong>è¾“å‡ºï¼š</strong>10
</pre>

<p><strong>ç¤ºä¾‹ 5ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>nums = [14,70,53,83,49,91,36,80,92,51,66,70]
<strong>è¾“å‡ºï¼š</strong>127
</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>
	<li><code>0 <= nums[i] <= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
</div>
<br />#### å‰è¨€

å‡è®¾æˆ‘ä»¬åœ¨æ•°ç»„ä¸­é€‰æ‹©äº†å…ƒç´  $a_i$ å’Œ $a_j$ï¼ˆ$i \neq j$ï¼‰ï¼Œä½¿å¾—å®ƒä»¬è¾¾åˆ°æœ€å¤§çš„æŒ‰ä½å¼‚æˆ–è¿ç®—ç»“æœ $x$ï¼š

$$
x = a_i \oplus a_j
$$

å…¶ä¸­ $\oplus$ è¡¨ç¤ºæŒ‰ä½å¼‚æˆ–è¿ç®—ã€‚è¦æƒ³æ±‚å‡º $x$ï¼Œä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨äºŒé‡å¾ªç¯æšä¸¾ $i$ å’Œ $j$ï¼Œä½†è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œä¼šè¶…å‡ºæ—¶é—´é™åˆ¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¯»æ±‚æ—¶é—´å¤æ‚åº¦æ›´ä½çš„åšæ³•ã€‚

æ ¹æ®æŒ‰ä½å¼‚æˆ–è¿ç®—çš„æ€§è´¨ï¼Œ$x = a_i \oplus a_j$ ç­‰ä»·äº $a_j = x \oplus a_i$ã€‚æˆ‘ä»¬å¯ä»¥æ ¹æ®è¿™ä¸€å˜æ¢ï¼Œè®¾è®¡ä¸€ç§ã€Œä»é«˜ä½åˆ°ä½ä½ä¾æ¬¡ç¡®å®š $x$ äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ¯ä¸€ä½ã€çš„æ–¹æ³•ï¼Œä»¥æ­¤å¾—åˆ° $x$ çš„å€¼ã€‚è¯¥æ–¹æ³•çš„ç²¾é«“åœ¨äºï¼š

- ç”±äºæ•°ç»„ä¸­çš„å…ƒç´ éƒ½åœ¨ $[0, 2^{31})$ çš„èŒƒå›´å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†æ¯ä¸€ä¸ªæ•°è¡¨ç¤ºä¸ºä¸€ä¸ªé•¿åº¦ä¸º $31$ ä½çš„äºŒè¿›åˆ¶æ•°ï¼ˆå¦‚æœä¸æ»¡ $31$ ä½ï¼Œåœ¨æœ€é«˜ä½ä¹‹å‰è¡¥ä¸Šè‹¥å¹²ä¸ªå‰å¯¼ $0$ å³å¯ï¼‰ï¼›

- è¿™ $31$ ä¸ªäºŒè¿›åˆ¶ä½ä»ä½ä½åˆ°é«˜ä½ä¾æ¬¡ç¼–å·ä¸º $0, 1, \cdots, 30$ã€‚æˆ‘ä»¬ä»æœ€é«˜ä½ç¬¬ $30$ ä¸ªäºŒè¿›åˆ¶ä½å¼€å§‹ï¼Œä¾æ¬¡ç¡®å®š $x$ çš„æ¯ä¸€ä½æ˜¯ $0$ è¿˜æ˜¯ $1$ï¼›

- ç”±äºæˆ‘ä»¬éœ€è¦æ‰¾å‡ºæœ€å¤§çš„ $x$ï¼Œå› æ­¤åœ¨æšä¸¾æ¯ä¸€ä½æ—¶ï¼Œæˆ‘ä»¬å…ˆåˆ¤æ–­ $x$ çš„è¿™ä¸€ä½æ˜¯å¦èƒ½å–åˆ° $1$ã€‚å¦‚æœèƒ½ï¼Œæˆ‘ä»¬å–è¿™ä¸€ä½ä¸º $1$ï¼Œå¦åˆ™æˆ‘ä»¬å–è¿™ä¸€ä½ä¸º $0$ã€‚

ã€Œåˆ¤æ–­ $x$ çš„æŸä¸€ä½æ˜¯å¦èƒ½å–åˆ° $1$ã€è¿™ä¸€æ­¥éª¤å¹¶ä¸å®¹æ˜“ã€‚ä¸‹é¢ä»‹ç»ä¸¤ç§åˆ¤æ–­çš„æ–¹æ³•ã€‚

#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨

**æ€è·¯ä¸ç®—æ³•**

å‡è®¾æˆ‘ä»¬å·²ç»ç¡®å®šäº† $x$ æœ€é«˜çš„è‹¥å¹²ä¸ªäºŒè¿›åˆ¶ä½ï¼Œå½“å‰æ­£åœ¨ç¡®å®šç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ã€‚æ ¹æ®ã€Œå‰è¨€ã€éƒ¨åˆ†çš„åˆ†æï¼Œæˆ‘ä»¬å¸Œæœ›ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½èƒ½å¤Ÿå–åˆ° $1$ã€‚

æˆ‘ä»¬ç”¨ $\textit{pre}^k(x)$ è¡¨ç¤º $x$ ä»æœ€é«˜ä½ç¬¬ $30$ ä¸ªäºŒè¿›åˆ¶ä½å¼€å§‹ï¼Œåˆ°ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„æ•°ï¼Œé‚£ä¹ˆ $a_j = x \oplus a_i$ è•´å«ç€ï¼š

$$
\textit{pre}^k (a_j) = \textit{pre}^k (x) \oplus \textit{pre}^k (a_i)
$$

ç”±äº $\textit{pre}^k(x)$ å¯¹äºæˆ‘ä»¬æ¥è¯´æ˜¯å·²çŸ¥çš„ï¼Œå› æ­¤æˆ‘ä»¬å°†æ‰€æœ‰çš„ $\textit{pre}^k (a_j)$ æ”¾å…¥å“ˆå¸Œè¡¨ä¸­ï¼Œéšåæšä¸¾ $i$ å¹¶è®¡ç®— $\textit{pre}^k (x) \oplus \textit{pre}^k (a_i)$ã€‚å¦‚æœå…¶å‡ºç°åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œé‚£ä¹ˆè¯´æ˜ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½èƒ½å¤Ÿå–åˆ° $1$ï¼Œå¦åˆ™ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º $0$ã€‚

æœ¬æ–¹æ³•è‹¥ä»…é˜…è¯»æ–‡å­—ï¼Œç†è§£èµ·æ¥å¯èƒ½è¾ƒä¸ºå›°éš¾ï¼Œè¯»è€…å¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ä»¥åŠæ³¨é‡Šã€‚

**ç»†èŠ‚**

è®¡ç®— $\textit{pre}^k(x)$ å¯ä»¥ä½¿ç”¨å³ç§»è¿ç®— $\texttt{>>}$ã€‚

**ä»£ç **

```C++ [sol1-C++]
class Solution {
private:
    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    static constexpr int HIGH_BIT = 30;

public:
    int findMaximumXOR(vector<int>& nums) {
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            unordered_set<int> seen;
            // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
            for (int num: nums) {
                // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
                // åªéœ€å°†å…¶å³ç§» k ä½
                seen.insert(num >> k);
            }

            // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
            int x_next = x * 2 + 1;
            bool found = false;
            
            // æšä¸¾ i
            for (int num: nums) {
                if (seen.count(x_next ^ (num >> k))) {
                    found = true;
                    break;
                }
            }

            if (found) {
                x = x_next;
            }
            else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
                // å³ä¸º x = x*2
                x = x_next - 1;
            }
        }
        return x;
    }
};
```

```Java [sol1-Java]
class Solution {
    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    static final int HIGH_BIT = 30;

    public int findMaximumXOR(int[] nums) {
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            Set<Integer> seen = new HashSet<Integer>();
            // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
            for (int num : nums) {
                // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
                // åªéœ€å°†å…¶å³ç§» k ä½
                seen.add(num >> k);
            }

            // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
            int xNext = x * 2 + 1;
            boolean found = false;
            
            // æšä¸¾ i
            for (int num : nums) {
                if (seen.contains(xNext ^ (num >> k))) {
                    found = true;
                    break;
                }
            }

            if (found) {
                x = xNext;
            } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
                // å³ä¸º x = x*2
                x = xNext - 1;
            }
        }
        return x;
    }
}
```

```C# [sol1-C#]
public class Solution {
    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    const int HIGH_BIT = 30;

    public int FindMaximumXOR(int[] nums) {
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            ISet<int> seen = new HashSet<int>();
            // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
            foreach (int num in nums) {
                // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
                // åªéœ€å°†å…¶å³ç§» k ä½
                seen.Add(num >> k);
            }

            // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
            int xNext = x * 2 + 1;
            bool found = false;
            
            // æšä¸¾ i
            foreach (int num in nums) {
                if (seen.Contains(xNext ^ (num >> k))) {
                    found = true;
                    break;
                }
            }

            if (found) {
                x = xNext;
            } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
                // å³ä¸º x = x*2
                x = xNext - 1;
            }
        }
        return x;
    }
}
```

```Python [sol1-Python3]
class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        # æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
        HIGH_BIT = 30

        x = 0
        for k in range(HIGH_BIT, -1, -1):
            seen = set()
            # å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
            for num in nums:
                # å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
                # åªéœ€å°†å…¶å³ç§» k ä½
                seen.add(num >> k)

            # ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            # æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
            x_next = x * 2 + 1
            found = False
            
            # æšä¸¾ i
            for num in nums:
                if x_next ^ (num >> k) in seen:
                    found = True
                    break

            if found:
                x = x_next
            else:
                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
                # å³ä¸º x = x*2
                x = x_next - 1
        
        return x
```

```JavaScript [sol1-JavaScript]
var findMaximumXOR = function(nums) {
    const HIGH_BIT = 30;
    let x = 0;
    for (let k = HIGH_BIT; k >= 0; --k) {
        const seen = new Set();
        // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
        for (const num of nums) {
            // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            // åªéœ€å°†å…¶å³ç§» k ä½
            seen.add(num >> k);
        }

        // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
        // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
        const xNext = x * 2 + 1;
        let found = false;
        
        // æšä¸¾ i
        for (const num of nums) {
            if (seen.has(xNext ^ (num >> k))) {
                found = true;
                break;
            }
        }

        if (found) {
            x = xNext;
        } else {
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
            // å³ä¸º x = x*2
            x = xNext - 1;
        }
    }
    return x; 
};
```

```go [sol1-Golang]
func findMaximumXOR(nums []int) (x int) {
    const highBit = 30 // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    for k := highBit; k >= 0; k-- {
        // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
        seen := map[int]bool{}
        for _, num := range nums {
            // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            // åªéœ€å°†å…¶å³ç§» k ä½
            seen[num>>k] = true
        }

        // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
        // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
        xNext := x*2 + 1
        found := false

        // æšä¸¾ i
        for _, num := range nums {
            if seen[num>>k^xNext] {
                found = true
                break
            }
        }

        if found {
            x = xNext
        } else {
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
            // å³ä¸º x = x*2
            x = xNext - 1
        }
    }
    return
}
```

```C [sol1-C]
const int HIGH_BIT = 30;

struct HashTable {
    int key;
    UT_hash_handle hh;
};

int findMaximumXOR(int* nums, int numsSize) {
    int x = 0;
    for (int k = HIGH_BIT; k >= 0; --k) {
        struct HashTable* hashTable = NULL;
        // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­
        for (int i = 0; i < numsSize; i++) {
            // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
            // åªéœ€å°†å…¶å³ç§» k ä½
            int x = nums[i] >> k;
            struct HashTable* tmp;
            HASH_FIND_INT(hashTable, &x, tmp);
            if (tmp == NULL) {
                tmp = malloc(sizeof(struct HashTable));
                tmp->key = x;
                HASH_ADD_INT(hashTable, key, tmp);
            }
        }

        // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†
        // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1
        int x_next = x * 2 + 1;
        bool found = false;

        // æšä¸¾ i
        for (int i = 0; i < numsSize; i++) {
            int x = x_next ^ (nums[i] >> k);
            struct HashTable* tmp;
            HASH_FIND_INT(hashTable, &x, tmp);
            if (tmp != NULL) {
                found = true;
                break;
            }
        }

        if (found) {
            x = x_next;
        } else {
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0
            // å³ä¸º x = x*2
            x = x_next - 1;
        }
    }
    return x;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log C)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\textit{nums}$ çš„é•¿åº¦ï¼Œ$C$ æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ èŒƒå›´ï¼Œåœ¨æœ¬é¢˜ä¸­ $C < 2^{31}$ã€‚æšä¸¾ç­”æ¡ˆ $x$ çš„æ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log C)$ï¼Œåœ¨æ¯ä¸€æ¬¡æšä¸¾çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ $O(n)$ çš„æ—¶é—´è¿›è¡Œåˆ¤æ–­ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log C)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºå“ˆå¸Œè¡¨éœ€è¦ä½¿ç”¨çš„ç©ºé—´ã€‚

#### æ–¹æ³•äºŒï¼šå­—å…¸æ ‘

**æ€è·¯ä¸ç®—æ³•**

æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†æ•°ç»„ä¸­çš„å…ƒç´ çœ‹æˆé•¿åº¦ä¸º $31$ çš„å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²ä¸­åªåŒ…å« $0$ å’Œ $1$ã€‚å¦‚æœæˆ‘ä»¬å°†å­—ç¬¦ä¸²æ”¾å…¥å­—å…¸æ ‘ä¸­ï¼Œé‚£ä¹ˆåœ¨å­—å…¸æ ‘ä¸­æŸ¥è¯¢ä¸€ä¸ªå­—ç¬¦ä¸²çš„è¿‡ç¨‹ï¼Œæ°å¥½å°±æ˜¯ä»é«˜ä½å¼€å§‹ç¡®å®šæ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½çš„è¿‡ç¨‹ã€‚å­—å…¸æ ‘çš„å…·ä½“é€»è¾‘ä»¥åŠå®ç°å¯ä»¥å‚è€ƒã€Œ[208. å®ç° Trieï¼ˆå‰ç¼€æ ‘ï¼‰çš„å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/)ã€ï¼Œè¿™é‡Œæˆ‘ä»¬åªè¯´æ˜å¦‚ä½•ä½¿ç”¨å­—å…¸æ ‘è§£å†³æœ¬é¢˜ã€‚

æ ¹æ® $x = a_i \oplus a_j$ï¼Œæˆ‘ä»¬æšä¸¾ $a_i$ï¼Œå¹¶å°† $a_0, a_1, \cdots, a_{i-1}$ ä½œä¸º $a_j$ æ”¾å…¥å­—å…¸æ ‘ä¸­ï¼Œå¸Œæœ›æ‰¾å‡ºä½¿å¾— $x$ è¾¾åˆ°æœ€å¤§å€¼çš„ $a_j$ã€‚

å¦‚ä½•æ±‚å‡º $x$ å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ä»å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹è¿›è¡Œéå†ï¼Œéå†çš„ã€Œå‚ç…§å¯¹è±¡ã€ä¸º $a_i$ã€‚åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æ ¹æ® $a_i$ çš„ç¬¬ $x$ ä¸ªäºŒè¿›åˆ¶ä½æ˜¯ $0$ è¿˜æ˜¯ $1$ï¼Œç¡®å®šæˆ‘ä»¬åº”å½“èµ°å‘å“ªä¸ªå­èŠ‚ç‚¹ä»¥ç»§ç»­éå†ã€‚å‡è®¾æˆ‘ä»¬å½“å‰éå†åˆ°äº†ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ï¼š

- å¦‚æœ $a_i$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $0$ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”å½“å¾€è¡¨ç¤º $1$ çš„å­èŠ‚ç‚¹èµ°ï¼Œè¿™æ · $0 \oplus 1 = 1$ï¼Œå¯ä»¥ä½¿å¾— $x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $1$ã€‚å¦‚æœä¸å­˜åœ¨è¡¨ç¤º $1$ çš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½å¾€è¡¨ç¤º $0$ çš„å­èŠ‚ç‚¹èµ°ï¼Œ$x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $0$ï¼›

- å¦‚æœ $a_i$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”å½“å¾€è¡¨ç¤º $0$ çš„å­èŠ‚ç‚¹èµ°ï¼Œè¿™æ · $1 \oplus 0 = 1$ï¼Œå¯ä»¥ä½¿å¾— $x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $1$ã€‚å¦‚æœä¸å­˜åœ¨è¡¨ç¤º $0$ çš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½å¾€è¡¨ç¤º $1$ çš„å­èŠ‚ç‚¹èµ°ï¼Œ$x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $0$ã€‚

å½“éå†å®Œæ‰€æœ‰çš„ $31$ ä¸ªäºŒè¿›åˆ¶ä½åï¼Œæˆ‘ä»¬ä¹Ÿå°±å¾—åˆ°äº† $a_i$ å¯ä»¥é€šè¿‡å¼‚æˆ–è¿ç®—å¾—åˆ°çš„æœ€å¤§ $x$ã€‚è¿™æ ·ä¸€æ¥ï¼Œå¦‚æœæˆ‘ä»¬æšä¸¾äº†æ‰€æœ‰çš„ $a_i$ï¼Œä¹Ÿå°±å¾—åˆ°äº†æœ€ç»ˆçš„ç­”æ¡ˆã€‚

**ç»†èŠ‚**

ç”±äºå­—å…¸æ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šåªæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ†åˆ«è¡¨ç¤º $0$ å’Œ $1$ï¼Œå› æ­¤æœ¬é¢˜ä¸­çš„å­—å…¸æ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ã€‚åœ¨è®¾è®¡å­—å…¸æ ‘çš„æ•°æ®ç»“æ„æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä»¤å·¦å­èŠ‚ç‚¹ $\textit{left}$ è¡¨ç¤º $0$ï¼Œå³å­èŠ‚ç‚¹ $\textit{right}$ è¡¨ç¤º $1$ã€‚

**ä»£ç **

ä¸‹é¢çš„ $\texttt{C++}$ ä»£ç æ²¡æœ‰ææ„å­—å…¸æ ‘çš„ç©ºé—´ã€‚å¦‚æœåœ¨é¢è¯•ä¸­é‡åˆ°äº†æœ¬é¢˜ï¼Œå¯ä»¥å’Œé¢è¯•å®˜è¿›è¡Œæ²Ÿé€šï¼Œè¯¢é—®æ˜¯å¦éœ€è¦ææ„å¯¹åº”çš„ç©ºé—´ã€‚

```C++ [sol2-C++]
struct Trie {
    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹
    Trie* left = nullptr;
    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹
    Trie* right = nullptr;

    Trie() {}
};

class Solution {
private:
    // å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹
    Trie* root = new Trie();
    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    static constexpr int HIGH_BIT = 30;

public:
    void add(int num) {
        Trie* cur = root;
        for (int k = HIGH_BIT; k >= 0; --k) {
            int bit = (num >> k) & 1;
            if (bit == 0) {
                if (!cur->left) {
                    cur->left = new Trie();
                }
                cur = cur->left;
            }
            else {
                if (!cur->right) {
                    cur->right = new Trie();
                }
                cur = cur->right;
            }
        }
    }

    int check(int num) {
        Trie* cur = root;
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            int bit = (num >> k) & 1;
            if (bit == 0) {
                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°
                if (cur->right) {
                    cur = cur->right;
                    x = x * 2 + 1;
                }
                else {
                    cur = cur->left;
                    x = x * 2;
                }
            }
            else {
                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°
                if (cur->left) {
                    cur = cur->left;
                    x = x * 2 + 1;
                }
                else {
                    cur = cur->right;
                    x = x * 2;
                }
            }
        }
        return x;
    }

    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size();
        int x = 0;
        for (int i = 1; i < n; ++i) {
            // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­
            add(nums[i - 1]);
            // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ
            x = max(x, check(nums[i]));
        }
        return x;
    }
};
```

```Java [sol2-Java]
class Solution {
    // å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹
    Trie root = new Trie();
    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    static final int HIGH_BIT = 30;

    public int findMaximumXOR(int[] nums) {
        int n = nums.length;
        int x = 0;
        for (int i = 1; i < n; ++i) {
            // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­
            add(nums[i - 1]);
            // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ
            x = Math.max(x, check(nums[i]));
        }
        return x;
    }

    public void add(int num) {
        Trie cur = root;
        for (int k = HIGH_BIT; k >= 0; --k) {
            int bit = (num >> k) & 1;
            if (bit == 0) {
                if (cur.left == null) {
                    cur.left = new Trie();
                }
                cur = cur.left;
            }
            else {
                if (cur.right == null) {
                    cur.right = new Trie();
                }
                cur = cur.right;
            }
        }
    }

    public int check(int num) {
        Trie cur = root;
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            int bit = (num >> k) & 1;
            if (bit == 0) {
                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°
                if (cur.right != null) {
                    cur = cur.right;
                    x = x * 2 + 1;
                } else {
                    cur = cur.left;
                    x = x * 2;
                }
            } else {
                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°
                if (cur.left != null) {
                    cur = cur.left;
                    x = x * 2 + 1;
                } else {
                    cur = cur.right;
                    x = x * 2;
                }
            }
        }
        return x;
    }
}

class Trie {
    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹
    Trie left = null;
    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹
    Trie right = null;
}
```

```C# [sol2-C#]
public class Solution {
    // å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹
    Trie root = new Trie();
    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
    const int HIGH_BIT = 30;

    public int FindMaximumXOR(int[] nums) {
        int n = nums.Length;
        int x = 0;
        for (int i = 1; i < n; ++i) {
            // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­
            Add(nums[i - 1]);
            // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ
            x = Math.Max(x, Check(nums[i]));
        }
        return x;
    }

    public void Add(int num) {
        Trie cur = root;
        for (int k = HIGH_BIT; k >= 0; --k) {
            int bit = (num >> k) & 1;
            if (bit == 0) {
                if (cur.left == null) {
                    cur.left = new Trie();
                }
                cur = cur.left;
            }
            else {
                if (cur.right == null) {
                    cur.right = new Trie();
                }
                cur = cur.right;
            }
        }
    }

    public int Check(int num) {
        Trie cur = root;
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            int bit = (num >> k) & 1;
            if (bit == 0) {
                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°
                if (cur.right != null) {
                    cur = cur.right;
                    x = x * 2 + 1;
                } else {
                    cur = cur.left;
                    x = x * 2;
                }
            } else {
                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°
                if (cur.left != null) {
                    cur = cur.left;
                    x = x * 2 + 1;
                } else {
                    cur = cur.right;
                    x = x * 2;
                }
            }
        }
        return x;
    }
}

class Trie {
    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹
    public Trie left = null;
    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹
    public Trie right = null;
}
```

```Python [sol2-Python3]
class Trie:
    def __init__(self):
        # å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹
        self.left = None
        # å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹
        self.right = None

class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        # å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹
        root = Trie()
        # æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30
        HIGH_BIT = 30

        def add(num: int):
            cur = root
            for k in range(HIGH_BIT, -1, -1):
                bit = (num >> k) & 1
                if bit == 0:
                    if not cur.left:
                        cur.left = Trie()
                    cur = cur.left
                else:
                    if not cur.right:
                        cur.right = Trie()
                    cur = cur.right

        def check(num: int) -> int:
            cur = root
            x = 0
            for k in range(HIGH_BIT, -1, -1):
                bit = (num >> k) & 1
                if bit == 0:
                    # a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°
                    if cur.right:
                        cur = cur.right
                        x = x * 2 + 1
                    else:
                        cur = cur.left
                        x = x * 2
                else:
                    # a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°
                    if cur.left:
                        cur = cur.left
                        x = x * 2 + 1
                    else:
                        cur = cur.right
                        x = x * 2
            return x

        n = len(nums)
        x = 0
        for i in range(1, n):
            # å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­
            add(nums[i - 1])
            # å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ
            x = max(x, check(nums[i]))

        return x
```

```go [sol2-Golang]
const highBit = 30

type trie struct {
    left, right *trie
}

func (t *trie) add(num int) {
    cur := t
    for i := highBit; i >= 0; i-- {
        bit := num >> i & 1
        if bit == 0 {
            if cur.left == nil {
                cur.left = &trie{}
            }
            cur = cur.left
        } else {
            if cur.right == nil {
                cur.right = &trie{}
            }
            cur = cur.right
        }
    }
}

func (t *trie) check(num int) (x int) {
    cur := t
    for i := highBit; i >= 0; i-- {
        bit := num >> i & 1
        if bit == 0 {
            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°
            if cur.right != nil {
                cur = cur.right
                x = x*2 + 1
            } else {
                cur = cur.left
                x = x * 2
            }
        } else {
            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°
            if cur.left != nil {
                cur = cur.left
                x = x*2 + 1
            } else {
                cur = cur.right
                x = x * 2
            }
        }
    }
    return
}

func findMaximumXOR(nums []int) (x int) {
    root := &trie{}
    for i := 1; i < len(nums); i++ {
        // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­
        root.add(nums[i-1])
        // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ
        x = max(x, root.check(nums[i]))
    }
    return
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

```C [sol2-C]
const int HIGH_BIT = 30;

struct Trie {
    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹
    struct Trie* left;
    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹
    struct Trie* right;
};

struct Trie* createTrie() {
    struct Trie* ret = malloc(sizeof(struct Trie));
    ret->left = ret->right = NULL;
    return ret;
}

void add(struct Trie* root, int num) {
    struct Trie* cur = root;
    for (int k = HIGH_BIT; k >= 0; --k) {
        int bit = (num >> k) & 1;
        if (bit == 0) {
            if (!cur->left) {
                cur->left = createTrie();
            }
            cur = cur->left;
        } else {
            if (!cur->right) {
                cur->right = createTrie();
            }
            cur = cur->right;
        }
    }
}

int check(struct Trie* root, int num) {
    struct Trie* cur = root;
    int x = 0;
    for (int k = HIGH_BIT; k >= 0; --k) {
        int bit = (num >> k) & 1;
        if (bit == 0) {
            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°
            if (cur->right) {
                cur = cur->right;
                x = x * 2 + 1;
            } else {
                cur = cur->left;
                x = x * 2;
            }
        } else {
            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°
            if (cur->left) {
                cur = cur->left;
                x = x * 2 + 1;
            } else {
                cur = cur->right;
                x = x * 2;
            }
        }
    }
    return x;
}

int findMaximumXOR(int* nums, int numsSize) {
    struct Trie* root = createTrie();
    int x = 0;
    for (int i = 1; i < numsSize; ++i) {
        // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­
        add(root, nums[i - 1]);
        // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ
        x = fmax(x, check(root, nums[i]));
    }
    return x;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log C)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\textit{nums}$ çš„é•¿åº¦ï¼Œ$C$ æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ èŒƒå›´ï¼Œåœ¨æœ¬é¢˜ä¸­ $C < 2^{31}$ã€‚æˆ‘ä»¬éœ€è¦å°† $a_0$ åˆ° $a_{n-2}$ åŠ å…¥å­—å…¸æ ‘ä¸­ï¼Œå¹¶ä¸”éœ€è¦ä»¥ $a_1$ åˆ° $a_{n-1}$ ä½œä¸ºã€Œå‚ç…§å¯¹è±¡ã€åœ¨å­—å…¸æ ‘ä¸Šè¿›è¡Œéå†ï¼Œæ¯ä¸€é¡¹æ“ä½œçš„å•æ¬¡æ—¶é—´å¤æ‚åº¦ä¸º $O(\log C)$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \log C)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(n \log C)$ã€‚æ¯ä¸€ä¸ªå…ƒç´ åœ¨å­—å…¸æ ‘ä¸­éœ€è¦ä½¿ç”¨ $O(\log C)$ çš„ç©ºé—´ï¼Œå› æ­¤æ€»ç©ºé—´å¤æ‚åº¦ä¸º $O(n \log C)$ã€‚