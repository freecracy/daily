# 2021å¹´05æœˆ23æ—¥ code
<a href="https://toutiao.io/k/t1o49fm">ä¼ä¸šå¾®ä¿¡ä¸‡äº¿çº§æ—¥å¿—æ£€ç´¢ç³»ç»Ÿ</a><br /><a href="https://toutiao.io/k/458js9n">çŠ¶æ€ç®¡ç†æœ¬åº”å¦‚æ­¤ç®€å•</a><br /><a href="https://toutiao.io/k/2gko5th">å¦‚ä½•äº•äº•æœ‰æ¡çš„ç®¡ç†å¼€å‘ä»»åŠ¡ï¼ˆé™„ä»»åŠ¡ç®¡ç†æ¨¡æ¿ï¼‰</a><br /><a href="https://toutiao.io/k/q62fiq2">å¦‚é—ªç”µåˆ’ç ´é›¨å¤œï¼Œè¿™äº›å¼€æºé¡¹ç›®ç¬é—´ç‚¹äº®äº†å‘½ä»¤è¡Œ</a><br /><a href="https://toutiao.io/k/p2gl29o">èŠèŠéƒ¨ç½²åœ¨ Docker å®¹å™¨é‡Œé¢çš„ Spring Boot é¡¹ç›®å¦‚ä½•å¯ç”¨ Arthas</a><br /><a href="https://toutiao.io/k/nnicr2q">Redis ç ´éšœä¹‹è·¯ï¼ˆå››ï¼‰ï¼šJedis åŸºæœ¬ä½¿ç”¨</a><br /><a href="https://toutiao.io/k/rb0xb1h">æµ·åº·ä¸‰å¹´å¼€å‘ç¤¾æ‹›ï¼šå››é¢é€šè¿‡</a><br /><a href="https://toutiao.io/k/cr3hf19">Android 12 Beta ç‰ˆå‘å¸ƒï¼Œè¯¸å¤šäº®ç‚¹ä¸å®¹é”™è¿‡</a><br /><a href="https://toutiao.io/k/3j55yw0">Android ä¹‹ App å¯åŠ¨ä¼˜åŒ–å’Œä¼˜é›…è¿‡æ¸¡åŠ¨ç”»å…¨é¢è§£æ</a><br /><a href="https://toutiao.io/k/4036fkc">GUI ç•Œé¢å¦‚ä½•è®¾è®¡ï¼Ÿ</a><br /><a href="https://toutiao.io/k/4sywkcm">[æ¨è] å¾®æœåŠ¡è®¾è®¡åŸåˆ™</a><br /><a href="https://toutiao.io/k/moooo7c">[æ¨è] æˆ‘ï¼Œç®¡ç† 100 å¤šäººæŠ€æœ¯å›¢é˜Ÿçš„äºŒä¸‰äº‹</a><br /><a href="https://toutiao.io/k/w8wyj2e">[æ¨è] æ¶ˆæ¯é˜Ÿåˆ—æŠŠæ¶ˆæ¯å¼„ä¸¢äº†æ€ä¹ˆåŠï¼Ÿ</a><br /><a href="https://toutiao.io/k/3byclqk">[æ¨è] è¿™ä¸ª GitHub é¡¹ç›®èƒ½å…‹éš†ä½ çš„å£°éŸ³</a><br /><a href="https://toutiao.io/k/jt9e5bq">[æ¨è] åŠ¨å›¾å›¾è§£ï¼æ—¢ç„¶ IP å±‚ä¼šåˆ†ç‰‡ï¼Œä¸ºä»€ä¹ˆ TCP å±‚ä¹Ÿè¿˜è¦åˆ†æ®µï¼Ÿ</a><br /><a href="https://toutiao.io/k/pfig936">[æ¨è] 75 å¼ å›¾å¸¦ä½ äº†è§£ç½‘ç»œè®¾å¤‡ã€ç½‘ç»œåœ°å€è§„åˆ’ã€é™æ€è·¯ç”±ã€å®æˆ˜æ¼”ç»ƒ </a><br /><a href="https://toutiao.io/k/0hjw87u">[æ¨è] æ—¥è®¢å•é‡è¾¾åˆ° 100 ä¸‡å•åï¼Œæˆ‘ä»¬åšäº†è®¢å•ä¸­å¿ƒé‡æ„</a><br /><a href="https://toutiao.io/k/bjis3t4">[æ¨è] 36 å¼ å›¾è¯¦è§£ç½‘ç»œåŸºç¡€çŸ¥è¯†</a><br /><a href="https://toutiao.io/k/ca8fe6d">[æ¨è] åŠç‚¸å¤©çš„ Docker å›¾å½¢åŒ–å·¥å…· Portainerï¼Œå¿…é¡»æ¨èç»™ä½ </a><br /><a href="https://toutiao.io/k/gc13z71">[æ¨è] æ•°æ®åˆ†æåå¹´ï¼Œæˆ‘åªæ¨èè¿™äº›ä¹¦</a><br /><a href="https://toutiao.io/k/9yex08q">[æ¨è] æˆ‘æŠŠè¿™ä¸ªè½¯ä»¶ï¼Œæ¨èç»™äº†æ€»ç›‘</a><br /><a href="https://toutiao.io/k/gs6z30z">[æ¨è] è½»è½»æ¾æ¾æ‰“å°ç½‘é¡µå¹¶ç”Ÿæˆ pdf æ–‡æ¡£</a><br /><a href="https://toutiao.io/k/r3kppel">[æ¨è] WebRTC çš„å‰ä¸–ä»Šç”Ÿ</a><br /><a href="https://toutiao.io/k/2tnj5np">[æ¨è] RabbitMQã€Kafkaã€RocketMQ æ˜¯å¦‚ä½•å®ç°é«˜å¯ç”¨çš„ï¼Ÿ</a><br /><a href="https://toutiao.io/k/wa52n1g">[æ¨è] é«˜å¹¶å‘ï¼Œæˆ‘æŠŠæ¡ä¸ä½å•Š</a><br /><hr /><a href="https://github.com/minio/minio">High Performance, Kubernetes Native Object Storage</a><br /><a href="https://github.com/google/googletest">GoogleTest - Google Testing and Mocking Framework</a><br /><a href="https://github.com/dotnet/maui">.NET MAUI is the .NET Multi-platform App UI, a framework for building native device applications spanning mobile, tablet, and desktop.</a><br /><a href="https://github.com/mehdihadeli/awesome-software-architecture">A curated list of awesome articles and resources to learn and practice about software architecture, patterns, and principles.</a><br /><a href="https://github.com/iptv-org/iptv">Collection of publicly available IPTV channels from all over the world</a><br /><a href="https://github.com/ZLMediaKit/ZLMediaKit">A lightweight RTSP/RTMP/HTTP/HLS/HTTP-FLV/WebSocket-FLV/HTTP-TS/HTTP-fMP4/WebSocket-TS/WebSocket-fMP4/GB28181/WebRTC server and client framework based on C++11</a><br /><a href="https://github.com/carykh/PrisonersDilemmaTournament">Watch This Place's awesome video about iterated Prisoner's Dilemma for context! https://www.youtube.com/watch?v=BOvAbjfJ0x0</a><br /><a href="https://github.com/ashishpatel26/500-AI-Machine-learning-Deep-learning-Computer-vision-NLP-Projects-with-code">500 AI Machine learning Deep learning Computer vision NLP Projects with code</a><br /><a href="https://github.com/pytorch/fairseq">Facebook AI Research Sequence-to-Sequence Toolkit written in Python.</a><br /><a href="https://github.com/Aayush9029/Native-Youtube">Personal APp</a><br /><a href="https://github.com/juce-framework/JUCE">JUCE is an open-source cross-platform C++ application framework for desktop and mobile applications, including VST, VST3, AU, AUv3, RTAS and AAX audio plug-ins.</a><br /><a href="https://github.com/appwrite/appwrite">Appwrite is a secure end-to-end backend server for Web, Mobile, and Flutter developers that is packaged as a set of Docker containers for easy deployment ğŸš€</a><br /><a href="https://github.com/flutter/flutter">Flutter makes it easy and fast to build beautiful apps for mobile and beyond.</a><br /><a href="https://github.com/anncwb/vue-vben-admin">âœ¨ âœ¨ âœ¨ A vue3 style Admin based on Vite2, vue3.0, ant-design-vue 2.x, typescriptï¼Œvuex,vue-router,Efforts to update in progress...</a><br /><a href="https://github.com/981011512/--">åœè½¦åœºç³»ç»Ÿæºç ï¼Œåœè½¦åœºå°ç¨‹åºï¼Œæ™ºèƒ½åœè½¦ï¼ŒParking systemï¼Œã€åŠŸèƒ½ä»‹ç»ã€‘ï¼šâ‘ å…¼å®¹å¸‚é¢ä¸Šä¸»æµçš„å¤šå®¶ç›¸æœºï¼Œç†è®ºä¸Šå…¼å®¹æ‰€æœ‰ç¡¬ä»¶ï¼Œå¯çµæ´»æ‰©å±•ï¼Œâ‘¡ç›¸æœºè¯†åˆ«åæ•°æ®è‡ªåŠ¨ä¸Šä¼ åˆ°äº‘ç«¯å¹¶è®°å½•ï¼Œæ ¡éªŒç›¸æœºå”¯ä¸€idå’Œç¡¬ä»¶åºåˆ—å·ï¼Œé˜²æ­¢éæ³•æ•°æ®å½•å…¥ï¼Œâ‘¢ç”¨æˆ·æ‰‹æœºæŸ¥è¯¢åœè½¦è®°å½•è¯¦æƒ…å¯è‡ªä¸»ç¼´è´¹(æ”¯æŒå¾®ä¿¡ï¼Œæ”¯ä»˜å®ï¼Œé“¶è¡Œæ¥å£æ”¯ä»˜ï¼Œæ”¯æŒæ¯ä¸ªåœè½¦åœºæŒ‡å®šä¸åŒçš„å•†æˆ·è¿›è¡Œæ”¶æ¬¾)ï¼Œæ”¯ä»˜åå‡ºåœºåœ¨å…è´¹æ—¶é—´å†…ä¼šè‡ªåŠ¨æŠ¬æ†ã€‚â‘£æ”¯æŒappä¸ŠæŸ¥è¯¢é™„è¿‘åœè½¦åœº(å¯¼èˆªï¼Œå¯ç”¨è½¦ä½æ•°ï¼Œåœè½¦åœºè´¹ç”¨ï¼Œä¼˜æƒ åˆ¸ï¼Œè¯„åˆ†ï¼Œè¯„è®ºç­‰)ï¼Œå¯é¢„çº¦è½¦ä½ã€‚â‘¤æ–­ç”µæ–­ç½‘æ”¯æŒå²—äº­äººå‘˜ä½¿ç”¨appå¯æ¥ç®¡ç¡¬ä»¶è¿›è¡Œåœè½¦è®°å½•çš„å½•å…¥ã€‚ ã€æŠ€æœ¯æ¶æ„ã€‘ï¼šåç«¯å¼€å‘è¯­è¨€javaï¼Œæ¡†æ¶oauth2+springboot2+dubbleï¼Œæ•°æ®åº“mysql/mongodb/redisï¼Œå³æ—¶é€šè®¯åº•å±‚æ¡†æ¶netâ€¦</a><br /><a href="https://github.com/lyswhut/lx-music-mobile">ä¸€ä¸ªåŸºäº React native å¼€å‘çš„éŸ³ä¹è½¯ä»¶ã€‚</a><br /><a href="https://github.com/geekcomputers/Python">My Python Examples</a><br /><a href="https://github.com/docker/awesome-compose">Awesome Docker Compose samples</a><br /><a href="https://github.com/jackfrued/Python-100-Days">Python - 100å¤©ä»æ–°æ‰‹åˆ°å¤§å¸ˆ</a><br /><a href="https://github.com/alfonsrv/impf-botpy">Impf Bot.py ğŸâš¡ â€“ Automatisierung fÃ¼r den Corona ImpfterminService Bot</a><br /><a href="https://github.com/hashicorp/vault">A tool for secrets management, encryption as a service, and privileged access management</a><br /><a href="https://github.com/WeChat-Big-Data-Challenge-2021/WeChat_Big_Data_Challenge"></a><br /><a href="https://github.com/golang/go">The Go programming language</a><br /><a href="https://github.com/facebook/react-native">A framework for building native apps with React.</a><br /><a href="https://github.com/sonnysangha/Amazon-starter-template-nextjs">This is the Official Starter template for the AMAZON 5 Day challenge (The SECRET Challenge!) - Next.js | React.js | Tailwind CSS | Redux | Tailwind | Firebase</a><br /><hr />ä¸æ•°ç»„ä¸­å…ƒç´ çš„æœ€å¤§å¼‚æˆ–å€¼<br /><p>ç»™ä½ ä¸€ä¸ªç”±éè´Ÿæ•´æ•°ç»„æˆçš„æ•°ç»„ <code>nums</code> ã€‚å¦æœ‰ä¸€ä¸ªæŸ¥è¯¢æ•°ç»„ <code>queries</code> ï¼Œå…¶ä¸­ <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code> ã€‚</p>

<p>ç¬¬ <code>i</code> ä¸ªæŸ¥è¯¢çš„ç­”æ¡ˆæ˜¯ <code>x<sub>i</sub></code> å’Œä»»ä½• <code>nums</code> æ•°ç»„ä¸­ä¸è¶…è¿‡ <code>m<sub>i</sub></code> çš„å…ƒç´ æŒ‰ä½å¼‚æˆ–ï¼ˆ<code>XOR</code>ï¼‰å¾—åˆ°çš„æœ€å¤§å€¼ã€‚æ¢å¥è¯è¯´ï¼Œç­”æ¡ˆæ˜¯ <code>max(nums[j] XOR x<sub>i</sub>)</code> ï¼Œå…¶ä¸­æ‰€æœ‰ <code>j</code> å‡æ»¡è¶³ <code>nums[j] &lt;= m<sub>i</sub></code> ã€‚å¦‚æœ <code>nums</code> ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äº <code>m<sub>i</sub></code>ï¼Œæœ€ç»ˆç­”æ¡ˆå°±æ˜¯ <code>-1</code> ã€‚</p>

<p>è¿”å›ä¸€ä¸ªæ•´æ•°æ•°ç»„<em> </em><code>answer</code><em> </em>ä½œä¸ºæŸ¥è¯¢çš„ç­”æ¡ˆï¼Œå…¶ä¸­<em> </em><code>answer.length == queries.length</code><em> </em>ä¸”<em> </em><code>answer[i]</code><em> </em>æ˜¯ç¬¬<em> </em><code>i</code><em> </em>ä¸ªæŸ¥è¯¢çš„ç­”æ¡ˆã€‚</p>

<p>Â </p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
<strong>è¾“å‡ºï¼š</strong>[3,3,7]
<strong>è§£é‡Šï¼š</strong>
1) 0 å’Œ 1 æ˜¯ä»…æœ‰çš„ä¸¤ä¸ªä¸è¶…è¿‡ 1 çš„æ•´æ•°ã€‚0 XOR 3 = 3 è€Œ 1 XOR 3 = 2 ã€‚äºŒè€…ä¸­çš„æ›´å¤§å€¼æ˜¯ 3 ã€‚
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
<strong>è¾“å‡ºï¼š</strong>[15,-1,5]
</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>
	<li><code>queries[i].length == 2</code></li>
	<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
<br />#### å‰è¨€

æœ¬æ–‡éœ€è¦è¯»è€…äº†è§£å­—å…¸æ ‘çš„ç›¸å…³çŸ¥è¯†ï¼Œå»ºè®®è¯»è€…å°è¯•è§£å†³ã€Œ[208. å®ç° Trie (å‰ç¼€æ ‘)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)ã€ï¼Œåœ¨å……åˆ†ç†è§£è¯¥é¢˜åšæ³•åç»§ç»­é˜…è¯»ã€‚

#### æ–¹æ³•ä¸€ï¼šç¦»çº¿è¯¢é—® + å­—å…¸æ ‘

**æ€è·¯**

æˆ‘ä»¬å…ˆæ¥è§£å†³ä¸€ä¸ªå¼±åŒ–ç‰ˆçš„é—®é¢˜ï¼šå»æ‰è¯¢é—®ä¸­ $m_i$ çš„é™åˆ¶ï¼Œå¦‚ä½•æ±‚ $x_i$ ä¸ $\textit{nums}$ æ•°ç»„ä»»æ„å…ƒç´ çš„å¼‚æˆ–æœ€å¤§å€¼ï¼Ÿ

æˆ‘ä»¬å¯ä»¥å°† $\textit{nums}$ ä¸­çš„æ¯ä¸ªå…ƒç´ çœ‹ä½œä¸€ä¸ªé•¿ä¸º $L$ çš„äºŒè¿›åˆ¶ä¸²ï¼Œå°†å…¶æ’å…¥å­—å…¸æ ‘ä¸­ã€‚

ä¾‹å¦‚ $\textit{nums}=[3,10,5,25,2]$ï¼Œå– $L=5$ï¼Œå¯¹åº”çš„äºŒè¿›åˆ¶ä¸²ä¸º $[00011,01010,00101,11001,00010]$ï¼Œå°†å…¶æ’å…¥å­—å…¸æ ‘åå¾—åˆ°çš„ç»“æœå¦‚ä¸‹å›¾ã€‚

![fig1](https://assets.leetcode-cn.com/solution-static/1707/1.png)

ä¸ºäº†æœ€å¤§åŒ–å¼‚æˆ–å€¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å­—å…¸æ ‘ä¸­è¿›è¡Œä¸€æ¬¡ä¸æ£€ç´¢å­—ç¬¦ä¸²ç±»ä¼¼çš„è¿‡ç¨‹ï¼Œä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œç”±äºå¼‚æˆ–è¿ç®—å…·æœ‰ã€Œç›¸åŒå¾— $0$ï¼Œä¸åŒå¾— $1$ã€çš„æ€§è´¨ï¼Œä¸ºäº†å°½å¯èƒ½å¤šåœ°å–åˆ° $1$ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸€æ­¥å¯»æ‰¾ä¸å½“å‰ä½ç›¸åçš„å­èŠ‚ç‚¹ï¼Œè‹¥è¯¥èŠ‚ç‚¹å­˜åœ¨åˆ™å°†æŒ‡é’ˆç§»åŠ¨åˆ°è¯¥èŠ‚ç‚¹ï¼Œå¦åˆ™åªèƒ½ç§»åŠ¨åˆ°ä¸å½“å‰ä½ç›¸åŒçš„å­èŠ‚ç‚¹ã€‚ï¼ˆæ³¨æ„ç”±äºæ’å…¥å’ŒæŸ¥è¯¢çš„äºŒè¿›åˆ¶ä¸²é•¿åº¦å‡ä¸º $L$ï¼Œéå¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹ä¸­ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªæ˜¯éç©ºèŠ‚ç‚¹ï¼‰

ä»¥ $x_i=25=(11001)_2$ ä¸ºä¾‹ï¼Œä¸‹å›¾å±•ç¤ºäº†æ±‚å–æœ€å¤§å¼‚æˆ–å€¼çš„è¿‡ç¨‹ã€‚

![fig2](https://assets.leetcode-cn.com/solution-static/1707/2.png)

å›åˆ°åŸé—®é¢˜ï¼Œç”±äºå…¨éƒ¨è¯¢é—®å·²ç»ç»™å‡ºï¼Œæˆ‘ä»¬ä¸ä¸€å®šè¦æŒ‰é¡ºåºå›ç­”è¯¢é—®ï¼Œè€Œæ˜¯æŒ‰ç…§ $m_i$ ä»å°åˆ°å¤§çš„é¡ºåºå›ç­”ã€‚

é¦–å…ˆå°†æ•°ç»„ $\textit{nums}$ ä»å°åˆ°å¤§æ’åºï¼Œå°†è¯¢é—®æŒ‰ç…§ $m_i$ çš„å¤§å°ä»å°åˆ°å¤§æ’åºã€‚

åœ¨å›ç­”æ¯ä¸ªè¯¢é—®å‰ï¼Œå°†æ‰€æœ‰ä¸è¶…è¿‡ $m_i$ çš„ $\textit{nums}$ å…ƒç´ æ’å…¥å­—å…¸åºä¸­ï¼Œç”±äº $\textit{nums}$ å·²ç»æ’å¥½åºï¼Œæˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªæŒ‡å‘ $\textit{nums}$ æ•°ç»„å…ƒç´ çš„ä¸‹æ ‡ $\textit{idx}$ï¼Œåˆå§‹å€¼ä¸º $0$ï¼Œæ¯æ’å…¥ä¸€ä¸ªå…ƒç´ å°±å°† $\textit{idx}$ åŠ ä¸€ã€‚å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œæˆ‘ä»¬å¯ä»¥ä¸æ–­æ’å…¥æ»¡è¶³ $\textit{nums}[\textit{idx}]\le m_i$ çš„å…ƒç´ ï¼Œç›´è‡³ä¸æ»¡è¶³è¯¥æ¡ä»¶æˆ– $\textit{idx}$ æŒ‡å‘äº†æ•°ç»„æœ«å°¾ã€‚

æ­¤æ—¶å­—å…¸æ ‘ä¸­çš„å…ƒç´ å°±æ˜¯ $\textit{nums}$ ä¸­æ‰€æœ‰ä¸è¶…è¿‡ $m_i$ çš„å…ƒç´ ï¼Œè¿™æ ·å°±è½¬æ¢æˆäº†å¼±åŒ–ç‰ˆçš„é—®é¢˜ã€‚

ä»£ç å®ç°æ—¶ï¼Œç”±äº $\textit{nums}$ å…ƒç´ ä¸è¶…è¿‡ $10^9$ï¼Œä¸ºç®€å•èµ·è§ï¼Œå¯å– $L=30$ï¼Œå³ $10^9$ çš„äºŒè¿›åˆ¶ä¸²çš„é•¿åº¦ã€‚æ­¤å¤–ï¼Œç”±äºå¯¹è¯¢é—®æ’åºä¼šæ‰“ä¹±åŸè¯¢é—®çš„é¡ºåºï¼Œè€Œæˆ‘ä»¬éœ€è¦æŒ‰ç…§åŸè¯¢é—®çš„é¡ºåºè¿”å›ç­”æ¡ˆï¼Œå› æ­¤å¯ä»¥åœ¨æ’åºå‰ï¼Œå¯¹æ¯ä¸ªè¯¢é—®é™„åŠ ä¸€ä¸ªå…¶åœ¨ $\textit{queries}$ ä¸­çš„ä¸‹æ ‡ã€‚

**ä»£ç **

```C++ [sol1-C++]
class Trie {
public:
    const int L = 30;

    Trie* children[2] = {};

    void insert(int val) {
        Trie* node = this;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node->children[bit] == nullptr) {
                node->children[bit] = new Trie();
            }
            node = node->children[bit];
        }
    }

    int getMaxXor(int val) {
        int ans = 0;
        Trie* node = this;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node->children[bit ^ 1] != nullptr) {
                ans |= 1 << i;
                bit ^= 1;
            }
            node = node->children[bit];
        }
        return ans;
    }
};

class Solution {
public:
    vector<int> maximizeXor(vector<int> &nums, vector<vector<int>> &queries) {
        sort(nums.begin(), nums.end());
        int numQ = queries.size();
        for (int i = 0; i < numQ; ++i) {
            queries[i].push_back(i);
        }
        sort(queries.begin(), queries.end(), [](auto &x, auto &y) { return x[1] < y[1]; });

        vector<int> ans(numQ);
        Trie* t = new Trie();
        int idx = 0, n = nums.size();
        for (auto &q : queries) {
            int x = q[0], m = q[1], qid = q[2];
            while (idx < n && nums[idx] <= m) {
                t->insert(nums[idx]);
                ++idx;
            }
            if (idx == 0) { // å­—å…¸æ ‘ä¸ºç©º
                ans[qid] = -1;
            } else {
                ans[qid] = t->getMaxXor(x);
            }
        }
        return ans;
    }
};
```

```Java [sol1-Java]
class Solution {
    public int[] maximizeXor(int[] nums, int[][] queries) {
        Arrays.sort(nums);
        int numQ = queries.length;
        int[][] newQueries = new int[numQ][3];
        for (int i = 0; i < numQ; ++i) {
            newQueries[i][0] = queries[i][0];
            newQueries[i][1] = queries[i][1];
            newQueries[i][2] = i;
        }
        Arrays.sort(newQueries, new Comparator<int[]>() {
            public int compare(int[] query1, int[] query2) {
                return query1[1] - query2[1];
            }
        });

        int[] ans = new int[numQ];
        Trie trie = new Trie();
        int idx = 0, n = nums.length;
        for (int[] query : newQueries) {
            int x = query[0], m = query[1], qid = query[2];
            while (idx < n && nums[idx] <= m) {
                trie.insert(nums[idx]);
                ++idx;
            }
            if (idx == 0) { // å­—å…¸æ ‘ä¸ºç©º
                ans[qid] = -1;
            } else {
                ans[qid] = trie.getMaxXor(x);
            }
        }
        return ans;
    }
}

class Trie {
    static final int L = 30;
    Trie[] children = new Trie[2];

    public void insert(int val) {
        Trie node = this;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit] == null) {
                node.children[bit] = new Trie();
            }
            node = node.children[bit];
        }
    }

    public int getMaxXor(int val) {
        int ans = 0;
        Trie node = this;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit ^ 1] != null) {
                ans |= 1 << i;
                bit ^= 1;
            }
            node = node.children[bit];
        }
        return ans;
    }
}
```

```C# [sol1-C#]
public class Solution {
    public int[] MaximizeXor(int[] nums, int[][] queries) {
        Array.Sort(nums);
        int numQ = queries.Length;
        Tuple<int, int, int>[] newQueries = new Tuple<int, int, int>[numQ];
        for (int i = 0; i < numQ; ++i) {
            newQueries[i] = new Tuple<int, int, int>(queries[i][0], queries[i][1], i);
        }
        Array.Sort<Tuple<int, int, int>>(newQueries,
            delegate(Tuple<int, int, int> query1, Tuple<int, int, int> query2) {
                return query1.Item2 - query2.Item2;
            }
        );

        int[] ans = new int[numQ];
        Trie trie = new Trie();
        int idx = 0, n = nums.Length;
        foreach (Tuple<int, int, int> query in newQueries) {
            int x = query.Item1, m = query.Item2, qid = query.Item3;
            while (idx < n && nums[idx] <= m) {
                trie.Insert(nums[idx]);
                ++idx;
            }
            if (idx == 0) { // å­—å…¸æ ‘ä¸ºç©º
                ans[qid] = -1;
            } else {
                ans[qid] = trie.GetMaxXor(x);
            }
        }
        return ans;
    }
}

class Trie {
    const int L = 30;
    Trie[] children = new Trie[2];

    public void Insert(int val) {
        Trie node = this;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit] == null) {
                node.children[bit] = new Trie();
            }
            node = node.children[bit];
        }
    }

    public int GetMaxXor(int val) {
        int ans = 0;
        Trie node = this;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit ^ 1] != null) {
                ans |= 1 << i;
                bit ^= 1;
            }
            node = node.children[bit];
        }
        return ans;
    }
}
```

```go [sol1-Golang]
const L = 30

type trie struct {
    children [2]*trie
}

func (t *trie) insert(val int) {
    node := t
    for i := L - 1; i >= 0; i-- {
        bit := val >> i & 1
        if node.children[bit] == nil {
            node.children[bit] = &trie{}
        }
        node = node.children[bit]
    }
}

func (t *trie) getMaxXor(val int) (ans int) {
    node := t
    for i := L - 1; i >= 0; i-- {
        bit := val >> i & 1
        if node.children[bit^1] != nil {
            ans |= 1 << i
            bit ^= 1
        }
        node = node.children[bit]
    }
    return
}

func maximizeXor(nums []int, queries [][]int) []int {
    sort.Ints(nums)
    for i := range queries {
        queries[i] = append(queries[i], i)
    }
    sort.Slice(queries, func(i, j int) bool { return queries[i][1] < queries[j][1] })

    ans := make([]int, len(queries))
    t := &trie{}
    idx, n := 0, len(nums)
    for _, q := range queries {
        x, m, qid := q[0], q[1], q[2]
        for idx < n && nums[idx] <= m {
            t.insert(nums[idx])
            idx++
        }
        if idx == 0 { // å­—å…¸æ ‘ä¸ºç©º
            ans[qid] = -1
        } else {
            ans[qid] = t.getMaxXor(x)
        }
    }
    return ans
}
```

```Python [sol1-Python3]
class Trie:
    L = 30

    def __init__(self):
        self.left = None
        self.right = None

    def insert(self, val: int):
        node = self
        for i in range(Trie.L, -1, -1):
            bit = (val >> i) & 1
            if bit == 0:
                if not node.left:
                    node.left = Trie()
                node = node.left
            else:
                if not node.right:
                    node.right = Trie()
                node = node.right
    
    def getMaxXor(self, val: int) -> int:
        ans, node = 0, self
        for i in range(Trie.L, -1, -1):
            bit = (val >> i) & 1
            check = False
            if bit == 0:
                if node.right:
                    node = node.right
                    check = True
                else:
                    node = node.left
            else:
                if node.left:
                    node = node.left
                    check = True
                else:
                    node = node.right
            if check:
                ans |= 1 << i
        return ans


class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n, q = len(nums), len(queries)
        nums.sort()
        queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda query: query[1])
        
        ans = [0] * q
        t = Trie()
        idx = 0
        for x, m, qid in queries:
            while idx < n and nums[idx] <= m:
                t.insert(nums[idx])
                idx += 1
            if idx == 0:
                # å­—å…¸æ ‘ä¸ºç©º
                ans[qid] = -1
            else:
                ans[qid] = t.getMaxXor(x)
        
        return ans
```

```C [sol1-C]
const int L = 30;

struct TrieNode {
    struct TrieNode* children[2];
};

struct TrieNode* createTrieNode() {
    struct TrieNode* ret = malloc(sizeof(struct TrieNode));
    ret->children[0] = ret->children[1] = NULL;
    return ret;
};

void insert(struct TrieNode* root, int val) {
    struct TrieNode* node = root;
    for (int i = L - 1; i >= 0; --i) {
        int bit = (val >> i) & 1;
        if (node->children[bit] == NULL) {
            node->children[bit] = createTrieNode();
        }
        node = node->children[bit];
    }
}

int getMaxXor(struct TrieNode* root, int val) {
    int ans = 0;
    struct TrieNode* node = root;
    for (int i = L - 1; i >= 0; --i) {
        int bit = (val >> i) & 1;
        if (node->children[bit ^ 1] != NULL) {
            ans |= 1 << i;
            bit ^= 1;
        }
        node = node->children[bit];
    }
    return ans;
}

int cmp1(int* a, int* b) {
    return *a - *b;
}

int cmp2(int** a, int** b) {
    return (*a)[1] - (*b)[1];
}

int* maximizeXor(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {
    qsort(nums, numsSize, sizeof(int), cmp1);
    for (int i = 0; i < queriesSize; ++i) {
        queries[i] = realloc(queries[i], sizeof(int) * 3);
        queries[i][2] = i;
    }
    qsort(queries, queriesSize, sizeof(int*), cmp2);
    int* ans = malloc(sizeof(int) * queriesSize);
    *returnSize = queriesSize;
    struct TrieNode* t = createTrieNode();
    int idx = 0, n = numsSize;
    for (int i = 0; i < queriesSize; i++) {
        int x = queries[i][0], m = queries[i][1], qid = queries[i][2];
        while (idx < n && nums[idx] <= m) {
            insert(t, nums[idx]);
            ++idx;
        }
        if (idx == 0) {  // å­—å…¸æ ‘ä¸ºç©º
            ans[qid] = -1;
        } else {
            ans[qid] = getMaxXor(t, x);
        }
    }
    return ans;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O(N\log N+Q\log Q+(N+Q)\cdot L)$ã€‚å…¶ä¸­ $N$ æ˜¯æ•°ç»„ $\textit{nums}$ çš„é•¿åº¦ï¼Œ$Q$ æ˜¯æ•°ç»„ $\textit{queries}$ çš„é•¿åº¦ï¼Œ$L$ æ˜¯ $\textit{nums}$ ä¸­çš„æ¯ä¸ªå…ƒç´ çš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„é•¿åº¦ï¼Œç®—æ³•ä¸­å›ºå®š $L=30$ã€‚æ’åº $\textit{nums}$ çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N\log N)$ï¼Œæ’åº $\textit{queries}$ çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(Q\log Q)$ï¼Œæ¯æ¬¡æ’å…¥å’ŒæŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(L)$ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N\log N+Q\log Q+(N+Q)\cdot L)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(Q+N\cdot L)$ã€‚æˆ‘ä»¬éœ€è¦ $O(Q)$ çš„ç©ºé—´æ¥å­˜å‚¨æ¯ä¸ªæŸ¥è¯¢åœ¨æ’åºå‰çš„ $\textit{queries}$ ä¸­çš„ä½ç½®ï¼Œä¸” $\textit{nums}$ ä¸­çš„æ¯ä¸ªå…ƒç´ è‡³å¤šéœ€è¦ $O(L)$ ä¸ªå­—å…¸æ ‘èŠ‚ç‚¹æ¥å­˜å‚¨ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(Q+N\cdot L)$ã€‚

#### æ–¹æ³•äºŒï¼šåœ¨çº¿è¯¢é—® + å­—å…¸æ ‘

**æ€è·¯**

æˆ‘ä»¬å¯ä»¥ç»™å­—å…¸æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå€¼ $\textit{min}$ï¼Œè¡¨ç¤ºä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘æ‰€è®°å½•çš„å…ƒç´ çš„æœ€å°å€¼ã€‚ç‰¹åˆ«åœ°ï¼Œæ ¹èŠ‚ç‚¹çš„ $\textit{min}$ è¡¨ç¤ºå­—å…¸æ ‘ä¸Šè®°å½•çš„æ‰€æœ‰å…ƒç´ çš„æœ€å°å€¼ã€‚

é¦–å…ˆå°†æ‰€æœ‰å…ƒç´ æ’å…¥å­—å…¸æ ‘ï¼Œæ’å…¥æ—¶æ›´æ–°å­—å…¸æ ‘å¯¹åº”èŠ‚ç‚¹çš„ $\textit{min}$ å€¼ã€‚

ç„¶åä¾æ¬¡å›ç­”æ¯ä¸ªè¯¢é—®ï¼šè‹¥ $m_i$ å°äºæ ¹èŠ‚ç‚¹çš„ $\textit{min}$ å€¼ï¼Œè¯´æ˜ $\textit{nums}$ ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äº $m_i$ï¼Œè¿”å› $-1$ï¼›å¦åˆ™ï¼Œåšæ³•ç±»ä¼¼æ–¹æ³•ä¸€ï¼Œåªéœ€è¦åœ¨å¾ªç¯å†…é¢å¤–åˆ¤æ–­ä¸å½“å‰ä½ç›¸åçš„å­èŠ‚ç‚¹çš„ $\textit{min}$ æ˜¯å¦ä¸è¶…è¿‡ $m_i$ï¼Œè‹¥ä¸è¶…è¿‡åˆ™å¯ä»¥è½¬ç§»è‡³è¯¥èŠ‚ç‚¹ã€‚

**ä»£ç **

```C++ [sol2-C++]
class Trie {
public:
    const int L = 30;

    Trie* children[2] = {};
    int min = INT_MAX;

    void insert(int val) {
        Trie* node = this;
        node->min = std::min(node->min, val);
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node->children[bit] == nullptr) {
                node->children[bit] = new Trie();
            }
            node = node->children[bit];
            node->min = std::min(node->min, val);
        }
    }

    int getMaxXorWithLimit(int val, int limit) {
        Trie* node = this;
        if (node->min > limit) {
            return -1;
        }
        int ans = 0;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node->children[bit ^ 1] != nullptr && node->children[bit ^ 1]->min <= limit) {
                ans |= 1 << i;
                bit ^= 1;
            }
            node = node->children[bit];
        }
        return ans;
    }
};

class Solution {
public:
    vector<int> maximizeXor(vector<int> &nums, vector<vector<int>> &queries) {
        Trie* t = new Trie();
        for (int val : nums) {
            t->insert(val);
        }
        int numQ = queries.size();
        vector<int> ans(numQ);
        for (int i = 0; i < numQ; ++i) {
            ans[i] = t->getMaxXorWithLimit(queries[i][0], queries[i][1]);
        }
        return ans;
    }
};
```

```Java [sol2-Java]
class Solution {
    public int[] maximizeXor(int[] nums, int[][] queries) {
        Trie trie = new Trie();
        for (int val : nums) {
            trie.insert(val);
        }
        int numQ = queries.length;
        int[] ans = new int[numQ];
        for (int i = 0; i < numQ; ++i) {
            ans[i] = trie.getMaxXorWithLimit(queries[i][0], queries[i][1]);
        }
        return ans;
    }
}

class Trie {
    static final int L = 30;
    Trie[] children = new Trie[2];
    int min = Integer.MAX_VALUE;

    public void insert(int val) {
        Trie node = this;
        node.min = Math.min(node.min, val);
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit] == null) {
                node.children[bit] = new Trie();
            }
            node = node.children[bit];
            node.min = Math.min(node.min, val);
        }
    }

    public int getMaxXorWithLimit(int val, int limit) {
        Trie node = this;
        if (node.min > limit) {
            return -1;
        }
        int ans = 0;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit ^ 1] != null && node.children[bit ^ 1].min <= limit) {
                ans |= 1 << i;
                bit ^= 1;
            }
            node = node.children[bit];
        }
        return ans;
    }
}
```

```C# [sol2-C#]
public class Solution {
    public int[] MaximizeXor(int[] nums, int[][] queries) {
        Trie trie = new Trie();
        foreach (int val in nums) {
            trie.Insert(val);
        }
        int numQ = queries.Length;
        int[] ans = new int[numQ];
        for (int i = 0; i < numQ; ++i) {
            ans[i] = trie.GetMaxXorWithLimit(queries[i][0], queries[i][1]);
        }
        return ans;
    }
}

class Trie {
    const int L = 30;
    Trie[] children = new Trie[2];
    int min = int.MaxValue;

    public void Insert(int val) {
        Trie node = this;
        node.min = Math.Min(node.min, val);
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit] == null) {
                node.children[bit] = new Trie();
            }
            node = node.children[bit];
            node.min = Math.Min(node.min, val);
        }
    }

    public int GetMaxXorWithLimit(int val, int limit) {
        Trie node = this;
        if (node.min > limit) {
            return -1;
        }
        int ans = 0;
        for (int i = L - 1; i >= 0; --i) {
            int bit = (val >> i) & 1;
            if (node.children[bit ^ 1] != null && node.children[bit ^ 1].min <= limit) {
                ans |= 1 << i;
                bit ^= 1;
            }
            node = node.children[bit];
        }
        return ans;
    }
}
```

```go [sol2-Golang]
const L = 30

type trie struct {
    children [2]*trie
    min      int
}

func (t *trie) insert(val int) {
    node := t
    if val < node.min {
        node.min = val
    }
    for i := L - 1; i >= 0; i-- {
        bit := val >> i & 1
        if node.children[bit] == nil {
            node.children[bit] = &trie{min: val}
        }
        node = node.children[bit]
        if val < node.min {
            node.min = val
        }
    }
}

func (t *trie) getMaxXorWithLimit(val, limit int) (ans int) {
    node := t
    if node.min > limit {
        return -1
    }
    for i := L - 1; i >= 0; i-- {
        bit := val >> i & 1
        if node.children[bit^1] != nil && node.children[bit^1].min <= limit {
            ans |= 1 << i
            bit ^= 1
        }
        node = node.children[bit]
    }
    return
}

func maximizeXor(nums []int, queries [][]int) []int {
    t := &trie{min: math.MaxInt32}
    for _, val := range nums {
        t.insert(val)
    }
    ans := make([]int, len(queries))
    for i, q := range queries {
        ans[i] = t.getMaxXorWithLimit(q[0], q[1])
    }
    return ans
}
```

```Python [sol2-Python3]
class Trie:
    L = 30

    def __init__(self):
        self.left = None
        self.right = None
        self.min_value = float("inf")

    def insert(self, val: int):
        node = self
        node.min_value = min(node.min_value, val)
        for i in range(Trie.L, -1, -1):
            bit = (val >> i) & 1
            if bit == 0:
                if not node.left:
                    node.left = Trie()
                node = node.left
            else:
                if not node.right:
                    node.right = Trie()
                node = node.right
            node.min_value = min(node.min_value, val)
    
    def getMaxXorWithLimit(self, val: int, limit: int) -> int:
        node = self
        if node.min_value > limit:
            return -1
        
        ans = 0
        for i in range(Trie.L, -1, -1):
            bit = (val >> i) & 1
            check = False
            if bit == 0:
                if node.right and node.right.min_value <= limit:
                    node = node.right
                    check = True
                else:
                    node = node.left
            else:
                if node.left and node.left.min_value <= limit:
                    node = node.left
                    check = True
                else:
                    node = node.right
            if check:
                ans |= 1 << i
        return ans


class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        t = Trie()
        for val in nums:
            t.insert(val)
        
        q = len(queries)
        ans = [0] * q
        for i, (x, m) in enumerate(queries):
            ans[i] = t.getMaxXorWithLimit(x, m)
        
        return ans
```

```C [sol2-C]
const int L = 30;

struct TrieNode {
    int minn;
    struct TrieNode* children[2];
};

struct TrieNode* createTrieNode() {
    struct TrieNode* ret = malloc(sizeof(struct TrieNode));
    ret->minn = INT_MAX;
    ret->children[0] = ret->children[1] = NULL;
    return ret;
};

void insert(struct TrieNode* root, int val) {
    struct TrieNode* node = root;
    node->minn = fmin(node->minn, val);
    for (int i = L - 1; i >= 0; --i) {
        int bit = (val >> i) & 1;
        if (node->children[bit] == NULL) {
            node->children[bit] = createTrieNode();
        }
        node = node->children[bit];
        node->minn = fmin(node->minn, val);
    }
}

int getMaxXorWithLimit(struct TrieNode* root, int val, int limit) {
    struct TrieNode* node = root;
    if (node->minn > limit) {
        return -1;
    }
    int ans = 0;
    for (int i = L - 1; i >= 0; --i) {
        int bit = (val >> i) & 1;
        if (node->children[bit ^ 1] != NULL && node->children[bit ^ 1]->minn <= limit) {
            ans |= 1 << i;
            bit ^= 1;
        }
        node = node->children[bit];
    }
    return ans;
}

int* maximizeXor(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {
    struct TrieNode* t = createTrieNode();
    for (int i = 0; i < numsSize; i++) {
        insert(t, nums[i]);
    }
    int* ans = malloc(sizeof(int) * queriesSize);
    *returnSize = queriesSize;
    for (int i = 0; i < queriesSize; ++i) {
        ans[i] = getMaxXorWithLimit(t, queries[i][0], queries[i][1]);
    }
    return ans;
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼š$O((N+Q)\cdot L)$ã€‚ç›¸è¾ƒæ–¹æ³•ä¸€ï¼Œæ–¹æ³•äºŒæ²¡æœ‰æ’åºçš„è¿‡ç¨‹ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º $O((N+Q)\cdot L)$ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼š$O(N\cdot L)$ã€‚ç©ºé—´å¤æ‚åº¦ä¸è€ƒè™‘è¿”å›å€¼ï¼Œè€Œ $\textit{nums}$ ä¸­çš„æ¯ä¸ªå…ƒç´ è‡³å¤šéœ€è¦ $O(L)$ ä¸ªå­—å…¸æ ‘èŠ‚ç‚¹æ¥å­˜å‚¨ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(N\cdot L)$ã€‚